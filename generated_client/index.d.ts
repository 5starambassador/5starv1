
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model ReferralLead
 * 
 */
export type ReferralLead = $Result.DefaultSelection<Prisma.$ReferralLeadPayload>
/**
 * Model BenefitSlab
 * 
 */
export type BenefitSlab = $Result.DefaultSelection<Prisma.$BenefitSlabPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model LeadManagementSettings
 * 
 */
export type LeadManagementSettings = $Result.DefaultSelection<Prisma.$LeadManagementSettingsPayload>
/**
 * Model SecuritySettings
 * 
 */
export type SecuritySettings = $Result.DefaultSelection<Prisma.$SecuritySettingsPayload>
/**
 * Model DataRetentionSettings
 * 
 */
export type DataRetentionSettings = $Result.DefaultSelection<Prisma.$DataRetentionSettingsPayload>
/**
 * Model RolePermissions
 * 
 */
export type RolePermissions = $Result.DefaultSelection<Prisma.$RolePermissionsPayload>
/**
 * Model Settlement
 * 
 */
export type Settlement = $Result.DefaultSelection<Prisma.$SettlementPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model SupportTicket
 * 
 */
export type SupportTicket = $Result.DefaultSelection<Prisma.$SupportTicketPayload>
/**
 * Model TicketMessage
 * 
 */
export type TicketMessage = $Result.DefaultSelection<Prisma.$TicketMessagePayload>
/**
 * Model Campus
 * 
 */
export type Campus = $Result.DefaultSelection<Prisma.$CampusPayload>
/**
 * Model CampusTarget
 * 
 */
export type CampusTarget = $Result.DefaultSelection<Prisma.$CampusTargetPayload>
/**
 * Model GradeFee
 * 
 */
export type GradeFee = $Result.DefaultSelection<Prisma.$GradeFeePayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model MarketingAsset
 * 
 */
export type MarketingAsset = $Result.DefaultSelection<Prisma.$MarketingAssetPayload>
/**
 * Model OtpVerification
 * 
 */
export type OtpVerification = $Result.DefaultSelection<Prisma.$OtpVerificationPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignLog
 * 
 */
export type CampaignLog = $Result.DefaultSelection<Prisma.$CampaignLogPayload>
/**
 * Model RateLimit
 * 
 */
export type RateLimit = $Result.DefaultSelection<Prisma.$RateLimitPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Parent: 'Parent',
  Staff: 'Staff',
  Alumni: 'Alumni',
  Others: 'Others'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AccountStatus: {
  Active: 'Active',
  Inactive: 'Inactive',
  Pending: 'Pending',
  Suspended: 'Suspended',
  Deletion_Requested: 'Deletion_Requested',
  Deleted: 'Deleted'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const FeeType: {
  OTP: 'OTP',
  WOTP: 'WOTP'
};

export type FeeType = (typeof FeeType)[keyof typeof FeeType]


export const LeadStatus: {
  New: 'New',
  Interested: 'Interested',
  Contacted: 'Contacted',
  Follow_up: 'Follow_up',
  Confirmed: 'Confirmed',
  Admitted: 'Admitted',
  Closed: 'Closed',
  Rejected: 'Rejected'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const AdminRole: {
  Super_Admin: 'Super_Admin',
  Finance_Admin: 'Finance_Admin',
  Campus_Head: 'Campus_Head',
  Admission_Admin: 'Admission_Admin',
  Campus_Admin: 'Campus_Admin'
};

export type AdminRole = (typeof AdminRole)[keyof typeof AdminRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type FeeType = $Enums.FeeType

export const FeeType: typeof $Enums.FeeType

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type AdminRole = $Enums.AdminRole

export const AdminRole: typeof $Enums.AdminRole

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.referralLead`: Exposes CRUD operations for the **ReferralLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReferralLeads
    * const referralLeads = await prisma.referralLead.findMany()
    * ```
    */
  get referralLead(): Prisma.ReferralLeadDelegate<ExtArgs>;

  /**
   * `prisma.benefitSlab`: Exposes CRUD operations for the **BenefitSlab** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BenefitSlabs
    * const benefitSlabs = await prisma.benefitSlab.findMany()
    * ```
    */
  get benefitSlab(): Prisma.BenefitSlabDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs>;

  /**
   * `prisma.leadManagementSettings`: Exposes CRUD operations for the **LeadManagementSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeadManagementSettings
    * const leadManagementSettings = await prisma.leadManagementSettings.findMany()
    * ```
    */
  get leadManagementSettings(): Prisma.LeadManagementSettingsDelegate<ExtArgs>;

  /**
   * `prisma.securitySettings`: Exposes CRUD operations for the **SecuritySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecuritySettings
    * const securitySettings = await prisma.securitySettings.findMany()
    * ```
    */
  get securitySettings(): Prisma.SecuritySettingsDelegate<ExtArgs>;

  /**
   * `prisma.dataRetentionSettings`: Exposes CRUD operations for the **DataRetentionSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataRetentionSettings
    * const dataRetentionSettings = await prisma.dataRetentionSettings.findMany()
    * ```
    */
  get dataRetentionSettings(): Prisma.DataRetentionSettingsDelegate<ExtArgs>;

  /**
   * `prisma.rolePermissions`: Exposes CRUD operations for the **RolePermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermissions.findMany()
    * ```
    */
  get rolePermissions(): Prisma.RolePermissionsDelegate<ExtArgs>;

  /**
   * `prisma.settlement`: Exposes CRUD operations for the **Settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settlements
    * const settlements = await prisma.settlement.findMany()
    * ```
    */
  get settlement(): Prisma.SettlementDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.supportTicket`: Exposes CRUD operations for the **SupportTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportTickets
    * const supportTickets = await prisma.supportTicket.findMany()
    * ```
    */
  get supportTicket(): Prisma.SupportTicketDelegate<ExtArgs>;

  /**
   * `prisma.ticketMessage`: Exposes CRUD operations for the **TicketMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketMessages
    * const ticketMessages = await prisma.ticketMessage.findMany()
    * ```
    */
  get ticketMessage(): Prisma.TicketMessageDelegate<ExtArgs>;

  /**
   * `prisma.campus`: Exposes CRUD operations for the **Campus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campuses
    * const campuses = await prisma.campus.findMany()
    * ```
    */
  get campus(): Prisma.CampusDelegate<ExtArgs>;

  /**
   * `prisma.campusTarget`: Exposes CRUD operations for the **CampusTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampusTargets
    * const campusTargets = await prisma.campusTarget.findMany()
    * ```
    */
  get campusTarget(): Prisma.CampusTargetDelegate<ExtArgs>;

  /**
   * `prisma.gradeFee`: Exposes CRUD operations for the **GradeFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GradeFees
    * const gradeFees = await prisma.gradeFee.findMany()
    * ```
    */
  get gradeFee(): Prisma.GradeFeeDelegate<ExtArgs>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs>;

  /**
   * `prisma.marketingAsset`: Exposes CRUD operations for the **MarketingAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingAssets
    * const marketingAssets = await prisma.marketingAsset.findMany()
    * ```
    */
  get marketingAsset(): Prisma.MarketingAssetDelegate<ExtArgs>;

  /**
   * `prisma.otpVerification`: Exposes CRUD operations for the **OtpVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OtpVerifications
    * const otpVerifications = await prisma.otpVerification.findMany()
    * ```
    */
  get otpVerification(): Prisma.OtpVerificationDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignLog`: Exposes CRUD operations for the **CampaignLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignLogs
    * const campaignLogs = await prisma.campaignLog.findMany()
    * ```
    */
  get campaignLog(): Prisma.CampaignLogDelegate<ExtArgs>;

  /**
   * `prisma.rateLimit`: Exposes CRUD operations for the **RateLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RateLimits
    * const rateLimits = await prisma.rateLimit.findMany()
    * ```
    */
  get rateLimit(): Prisma.RateLimitDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Student: 'Student',
    ReferralLead: 'ReferralLead',
    BenefitSlab: 'BenefitSlab',
    Admin: 'Admin',
    SystemSettings: 'SystemSettings',
    AcademicYear: 'AcademicYear',
    LeadManagementSettings: 'LeadManagementSettings',
    SecuritySettings: 'SecuritySettings',
    DataRetentionSettings: 'DataRetentionSettings',
    RolePermissions: 'RolePermissions',
    Settlement: 'Settlement',
    Resource: 'Resource',
    ActivityLog: 'ActivityLog',
    SupportTicket: 'SupportTicket',
    TicketMessage: 'TicketMessage',
    Campus: 'Campus',
    CampusTarget: 'CampusTarget',
    GradeFee: 'GradeFee',
    NotificationSettings: 'NotificationSettings',
    MarketingAsset: 'MarketingAsset',
    OtpVerification: 'OtpVerification',
    Notification: 'Notification',
    Campaign: 'Campaign',
    CampaignLog: 'CampaignLog',
    RateLimit: 'RateLimit'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "student" | "referralLead" | "benefitSlab" | "admin" | "systemSettings" | "academicYear" | "leadManagementSettings" | "securitySettings" | "dataRetentionSettings" | "rolePermissions" | "settlement" | "resource" | "activityLog" | "supportTicket" | "ticketMessage" | "campus" | "campusTarget" | "gradeFee" | "notificationSettings" | "marketingAsset" | "otpVerification" | "notification" | "campaign" | "campaignLog" | "rateLimit"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      ReferralLead: {
        payload: Prisma.$ReferralLeadPayload<ExtArgs>
        fields: Prisma.ReferralLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          findFirst: {
            args: Prisma.ReferralLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          findMany: {
            args: Prisma.ReferralLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>[]
          }
          create: {
            args: Prisma.ReferralLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          createMany: {
            args: Prisma.ReferralLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>[]
          }
          delete: {
            args: Prisma.ReferralLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          update: {
            args: Prisma.ReferralLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          deleteMany: {
            args: Prisma.ReferralLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralLeadPayload>
          }
          aggregate: {
            args: Prisma.ReferralLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferralLead>
          }
          groupBy: {
            args: Prisma.ReferralLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralLeadCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralLeadCountAggregateOutputType> | number
          }
        }
      }
      BenefitSlab: {
        payload: Prisma.$BenefitSlabPayload<ExtArgs>
        fields: Prisma.BenefitSlabFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenefitSlabFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenefitSlabFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          findFirst: {
            args: Prisma.BenefitSlabFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenefitSlabFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          findMany: {
            args: Prisma.BenefitSlabFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>[]
          }
          create: {
            args: Prisma.BenefitSlabCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          createMany: {
            args: Prisma.BenefitSlabCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BenefitSlabCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>[]
          }
          delete: {
            args: Prisma.BenefitSlabDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          update: {
            args: Prisma.BenefitSlabUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          deleteMany: {
            args: Prisma.BenefitSlabDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenefitSlabUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenefitSlabUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitSlabPayload>
          }
          aggregate: {
            args: Prisma.BenefitSlabAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenefitSlab>
          }
          groupBy: {
            args: Prisma.BenefitSlabGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenefitSlabGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenefitSlabCountArgs<ExtArgs>
            result: $Utils.Optional<BenefitSlabCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      LeadManagementSettings: {
        payload: Prisma.$LeadManagementSettingsPayload<ExtArgs>
        fields: Prisma.LeadManagementSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadManagementSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadManagementSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          findFirst: {
            args: Prisma.LeadManagementSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadManagementSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          findMany: {
            args: Prisma.LeadManagementSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>[]
          }
          create: {
            args: Prisma.LeadManagementSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          createMany: {
            args: Prisma.LeadManagementSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadManagementSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>[]
          }
          delete: {
            args: Prisma.LeadManagementSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          update: {
            args: Prisma.LeadManagementSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          deleteMany: {
            args: Prisma.LeadManagementSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadManagementSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadManagementSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadManagementSettingsPayload>
          }
          aggregate: {
            args: Prisma.LeadManagementSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeadManagementSettings>
          }
          groupBy: {
            args: Prisma.LeadManagementSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadManagementSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadManagementSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<LeadManagementSettingsCountAggregateOutputType> | number
          }
        }
      }
      SecuritySettings: {
        payload: Prisma.$SecuritySettingsPayload<ExtArgs>
        fields: Prisma.SecuritySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecuritySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecuritySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          findFirst: {
            args: Prisma.SecuritySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecuritySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          findMany: {
            args: Prisma.SecuritySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>[]
          }
          create: {
            args: Prisma.SecuritySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          createMany: {
            args: Prisma.SecuritySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecuritySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>[]
          }
          delete: {
            args: Prisma.SecuritySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          update: {
            args: Prisma.SecuritySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          deleteMany: {
            args: Prisma.SecuritySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecuritySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SecuritySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecuritySettingsPayload>
          }
          aggregate: {
            args: Prisma.SecuritySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecuritySettings>
          }
          groupBy: {
            args: Prisma.SecuritySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecuritySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecuritySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SecuritySettingsCountAggregateOutputType> | number
          }
        }
      }
      DataRetentionSettings: {
        payload: Prisma.$DataRetentionSettingsPayload<ExtArgs>
        fields: Prisma.DataRetentionSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataRetentionSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataRetentionSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          findFirst: {
            args: Prisma.DataRetentionSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataRetentionSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          findMany: {
            args: Prisma.DataRetentionSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>[]
          }
          create: {
            args: Prisma.DataRetentionSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          createMany: {
            args: Prisma.DataRetentionSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataRetentionSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>[]
          }
          delete: {
            args: Prisma.DataRetentionSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          update: {
            args: Prisma.DataRetentionSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          deleteMany: {
            args: Prisma.DataRetentionSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataRetentionSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataRetentionSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataRetentionSettingsPayload>
          }
          aggregate: {
            args: Prisma.DataRetentionSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataRetentionSettings>
          }
          groupBy: {
            args: Prisma.DataRetentionSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataRetentionSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<DataRetentionSettingsCountAggregateOutputType> | number
          }
        }
      }
      RolePermissions: {
        payload: Prisma.$RolePermissionsPayload<ExtArgs>
        fields: Prisma.RolePermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          findMany: {
            args: Prisma.RolePermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          create: {
            args: Prisma.RolePermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          createMany: {
            args: Prisma.RolePermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolePermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>[]
          }
          delete: {
            args: Prisma.RolePermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          update: {
            args: Prisma.RolePermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionsPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermissions>
          }
          groupBy: {
            args: Prisma.RolePermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionsCountAggregateOutputType> | number
          }
        }
      }
      Settlement: {
        payload: Prisma.$SettlementPayload<ExtArgs>
        fields: Prisma.SettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findFirst: {
            args: Prisma.SettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          findMany: {
            args: Prisma.SettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          create: {
            args: Prisma.SettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          createMany: {
            args: Prisma.SettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>[]
          }
          delete: {
            args: Prisma.SettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          update: {
            args: Prisma.SettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          deleteMany: {
            args: Prisma.SettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettlementPayload>
          }
          aggregate: {
            args: Prisma.SettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettlement>
          }
          groupBy: {
            args: Prisma.SettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SettlementCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      SupportTicket: {
        payload: Prisma.$SupportTicketPayload<ExtArgs>
        fields: Prisma.SupportTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findFirst: {
            args: Prisma.SupportTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          findMany: {
            args: Prisma.SupportTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          create: {
            args: Prisma.SupportTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          createMany: {
            args: Prisma.SupportTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>[]
          }
          delete: {
            args: Prisma.SupportTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          update: {
            args: Prisma.SupportTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          deleteMany: {
            args: Prisma.SupportTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupportTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportTicketPayload>
          }
          aggregate: {
            args: Prisma.SupportTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportTicket>
          }
          groupBy: {
            args: Prisma.SupportTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportTicketCountArgs<ExtArgs>
            result: $Utils.Optional<SupportTicketCountAggregateOutputType> | number
          }
        }
      }
      TicketMessage: {
        payload: Prisma.$TicketMessagePayload<ExtArgs>
        fields: Prisma.TicketMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findFirst: {
            args: Prisma.TicketMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          findMany: {
            args: Prisma.TicketMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          create: {
            args: Prisma.TicketMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          createMany: {
            args: Prisma.TicketMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>[]
          }
          delete: {
            args: Prisma.TicketMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          update: {
            args: Prisma.TicketMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          deleteMany: {
            args: Prisma.TicketMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TicketMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMessagePayload>
          }
          aggregate: {
            args: Prisma.TicketMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketMessage>
          }
          groupBy: {
            args: Prisma.TicketMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketMessageCountArgs<ExtArgs>
            result: $Utils.Optional<TicketMessageCountAggregateOutputType> | number
          }
        }
      }
      Campus: {
        payload: Prisma.$CampusPayload<ExtArgs>
        fields: Prisma.CampusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          findFirst: {
            args: Prisma.CampusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          findMany: {
            args: Prisma.CampusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>[]
          }
          create: {
            args: Prisma.CampusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          createMany: {
            args: Prisma.CampusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>[]
          }
          delete: {
            args: Prisma.CampusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          update: {
            args: Prisma.CampusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          deleteMany: {
            args: Prisma.CampusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          aggregate: {
            args: Prisma.CampusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampus>
          }
          groupBy: {
            args: Prisma.CampusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampusCountArgs<ExtArgs>
            result: $Utils.Optional<CampusCountAggregateOutputType> | number
          }
        }
      }
      CampusTarget: {
        payload: Prisma.$CampusTargetPayload<ExtArgs>
        fields: Prisma.CampusTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampusTargetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampusTargetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          findFirst: {
            args: Prisma.CampusTargetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampusTargetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          findMany: {
            args: Prisma.CampusTargetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>[]
          }
          create: {
            args: Prisma.CampusTargetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          createMany: {
            args: Prisma.CampusTargetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampusTargetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>[]
          }
          delete: {
            args: Prisma.CampusTargetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          update: {
            args: Prisma.CampusTargetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          deleteMany: {
            args: Prisma.CampusTargetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampusTargetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampusTargetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusTargetPayload>
          }
          aggregate: {
            args: Prisma.CampusTargetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampusTarget>
          }
          groupBy: {
            args: Prisma.CampusTargetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampusTargetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampusTargetCountArgs<ExtArgs>
            result: $Utils.Optional<CampusTargetCountAggregateOutputType> | number
          }
        }
      }
      GradeFee: {
        payload: Prisma.$GradeFeePayload<ExtArgs>
        fields: Prisma.GradeFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          findFirst: {
            args: Prisma.GradeFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          findMany: {
            args: Prisma.GradeFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>[]
          }
          create: {
            args: Prisma.GradeFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          createMany: {
            args: Prisma.GradeFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>[]
          }
          delete: {
            args: Prisma.GradeFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          update: {
            args: Prisma.GradeFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          deleteMany: {
            args: Prisma.GradeFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradeFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradeFeePayload>
          }
          aggregate: {
            args: Prisma.GradeFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGradeFee>
          }
          groupBy: {
            args: Prisma.GradeFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeFeeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeFeeCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      MarketingAsset: {
        payload: Prisma.$MarketingAssetPayload<ExtArgs>
        fields: Prisma.MarketingAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          findFirst: {
            args: Prisma.MarketingAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          findMany: {
            args: Prisma.MarketingAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>[]
          }
          create: {
            args: Prisma.MarketingAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          createMany: {
            args: Prisma.MarketingAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingAssetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>[]
          }
          delete: {
            args: Prisma.MarketingAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          update: {
            args: Prisma.MarketingAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          deleteMany: {
            args: Prisma.MarketingAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketingAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingAssetPayload>
          }
          aggregate: {
            args: Prisma.MarketingAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingAsset>
          }
          groupBy: {
            args: Prisma.MarketingAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingAssetGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingAssetCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingAssetCountAggregateOutputType> | number
          }
        }
      }
      OtpVerification: {
        payload: Prisma.$OtpVerificationPayload<ExtArgs>
        fields: Prisma.OtpVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          findFirst: {
            args: Prisma.OtpVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          findMany: {
            args: Prisma.OtpVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>[]
          }
          create: {
            args: Prisma.OtpVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          createMany: {
            args: Prisma.OtpVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>[]
          }
          delete: {
            args: Prisma.OtpVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          update: {
            args: Prisma.OtpVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          deleteMany: {
            args: Prisma.OtpVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpVerificationPayload>
          }
          aggregate: {
            args: Prisma.OtpVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtpVerification>
          }
          groupBy: {
            args: Prisma.OtpVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<OtpVerificationCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignLog: {
        payload: Prisma.$CampaignLogPayload<ExtArgs>
        fields: Prisma.CampaignLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          findFirst: {
            args: Prisma.CampaignLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          findMany: {
            args: Prisma.CampaignLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>[]
          }
          create: {
            args: Prisma.CampaignLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          createMany: {
            args: Prisma.CampaignLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>[]
          }
          delete: {
            args: Prisma.CampaignLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          update: {
            args: Prisma.CampaignLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          deleteMany: {
            args: Prisma.CampaignLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignLogPayload>
          }
          aggregate: {
            args: Prisma.CampaignLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignLog>
          }
          groupBy: {
            args: Prisma.CampaignLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignLogCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignLogCountAggregateOutputType> | number
          }
        }
      }
      RateLimit: {
        payload: Prisma.$RateLimitPayload<ExtArgs>
        fields: Prisma.RateLimitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RateLimitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RateLimitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          findFirst: {
            args: Prisma.RateLimitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RateLimitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          findMany: {
            args: Prisma.RateLimitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>[]
          }
          create: {
            args: Prisma.RateLimitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          createMany: {
            args: Prisma.RateLimitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RateLimitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>[]
          }
          delete: {
            args: Prisma.RateLimitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          update: {
            args: Prisma.RateLimitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          deleteMany: {
            args: Prisma.RateLimitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RateLimitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RateLimitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RateLimitPayload>
          }
          aggregate: {
            args: Prisma.RateLimitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRateLimit>
          }
          groupBy: {
            args: Prisma.RateLimitGroupByArgs<ExtArgs>
            result: $Utils.Optional<RateLimitGroupByOutputType>[]
          }
          count: {
            args: Prisma.RateLimitCountArgs<ExtArgs>
            result: $Utils.Optional<RateLimitCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    referrals: number
    settlements: number
    referredStudents: number
    students: number
    supportTickets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    settlements?: boolean | UserCountOutputTypeCountSettlementsArgs
    referredStudents?: boolean | UserCountOutputTypeCountReferredStudentsArgs
    students?: boolean | UserCountOutputTypeCountStudentsArgs
    supportTickets?: boolean | UserCountOutputTypeCountSupportTicketsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralLeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferredStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    notifications: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | AdminCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type SupportTicketCountOutputType
   */

  export type SupportTicketCountOutputType = {
    messages: number
  }

  export type SupportTicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportTicketCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicketCountOutputType
     */
    select?: SupportTicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportTicketCountOutputType without action
   */
  export type SupportTicketCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
  }


  /**
   * Count Type CampusCountOutputType
   */

  export type CampusCountOutputType = {
    targets: number
    gradeFees: number
    students: number
  }

  export type CampusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targets?: boolean | CampusCountOutputTypeCountTargetsArgs
    gradeFees?: boolean | CampusCountOutputTypeCountGradeFeesArgs
    students?: boolean | CampusCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusCountOutputType
     */
    select?: CampusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampusTargetWhereInput
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountGradeFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeFeeWhereInput
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    logs: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | CampaignCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    userId: number | null
    campusId: number | null
    confirmedReferralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermBenefitPercent: number | null
    lastActiveYear: number | null
    studentFee: number | null
    paymentAmount: number | null
  }

  export type UserSumAggregateOutputType = {
    userId: number | null
    campusId: number | null
    confirmedReferralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermBenefitPercent: number | null
    lastActiveYear: number | null
    studentFee: number | null
    paymentAmount: number | null
  }

  export type UserMinAggregateOutputType = {
    userId: number | null
    fullName: string | null
    mobileNumber: string | null
    childInAchariya: boolean | null
    childName: string | null
    grade: string | null
    campusId: number | null
    bankAccountDetails: string | null
    referralCode: string | null
    confirmedReferralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermBenefitPercent: number | null
    lastActiveYear: number | null
    isFiveStarMember: boolean | null
    assignedCampus: string | null
    studentFee: number | null
    academicYear: string | null
    createdAt: Date | null
    profileImage: string | null
    email: string | null
    address: string | null
    paymentAmount: number | null
    paymentStatus: string | null
    transactionId: string | null
    aadharNo: string | null
    childEprNo: string | null
    empId: string | null
    password: string | null
    deletionRequestedAt: Date | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    benefitStatus: $Enums.AccountStatus | null
  }

  export type UserMaxAggregateOutputType = {
    userId: number | null
    fullName: string | null
    mobileNumber: string | null
    childInAchariya: boolean | null
    childName: string | null
    grade: string | null
    campusId: number | null
    bankAccountDetails: string | null
    referralCode: string | null
    confirmedReferralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermBenefitPercent: number | null
    lastActiveYear: number | null
    isFiveStarMember: boolean | null
    assignedCampus: string | null
    studentFee: number | null
    academicYear: string | null
    createdAt: Date | null
    profileImage: string | null
    email: string | null
    address: string | null
    paymentAmount: number | null
    paymentStatus: string | null
    transactionId: string | null
    aadharNo: string | null
    childEprNo: string | null
    empId: string | null
    password: string | null
    deletionRequestedAt: Date | null
    role: $Enums.UserRole | null
    status: $Enums.AccountStatus | null
    benefitStatus: $Enums.AccountStatus | null
  }

  export type UserCountAggregateOutputType = {
    userId: number
    fullName: number
    mobileNumber: number
    childInAchariya: number
    childName: number
    grade: number
    campusId: number
    bankAccountDetails: number
    referralCode: number
    confirmedReferralCount: number
    yearFeeBenefitPercent: number
    longTermBenefitPercent: number
    lastActiveYear: number
    isFiveStarMember: number
    assignedCampus: number
    studentFee: number
    academicYear: number
    createdAt: number
    profileImage: number
    email: number
    address: number
    paymentAmount: number
    paymentStatus: number
    transactionId: number
    aadharNo: number
    childEprNo: number
    empId: number
    password: number
    deletionRequestedAt: number
    role: number
    status: number
    benefitStatus: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    userId?: true
    campusId?: true
    confirmedReferralCount?: true
    yearFeeBenefitPercent?: true
    longTermBenefitPercent?: true
    lastActiveYear?: true
    studentFee?: true
    paymentAmount?: true
  }

  export type UserSumAggregateInputType = {
    userId?: true
    campusId?: true
    confirmedReferralCount?: true
    yearFeeBenefitPercent?: true
    longTermBenefitPercent?: true
    lastActiveYear?: true
    studentFee?: true
    paymentAmount?: true
  }

  export type UserMinAggregateInputType = {
    userId?: true
    fullName?: true
    mobileNumber?: true
    childInAchariya?: true
    childName?: true
    grade?: true
    campusId?: true
    bankAccountDetails?: true
    referralCode?: true
    confirmedReferralCount?: true
    yearFeeBenefitPercent?: true
    longTermBenefitPercent?: true
    lastActiveYear?: true
    isFiveStarMember?: true
    assignedCampus?: true
    studentFee?: true
    academicYear?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    paymentAmount?: true
    paymentStatus?: true
    transactionId?: true
    aadharNo?: true
    childEprNo?: true
    empId?: true
    password?: true
    deletionRequestedAt?: true
    role?: true
    status?: true
    benefitStatus?: true
  }

  export type UserMaxAggregateInputType = {
    userId?: true
    fullName?: true
    mobileNumber?: true
    childInAchariya?: true
    childName?: true
    grade?: true
    campusId?: true
    bankAccountDetails?: true
    referralCode?: true
    confirmedReferralCount?: true
    yearFeeBenefitPercent?: true
    longTermBenefitPercent?: true
    lastActiveYear?: true
    isFiveStarMember?: true
    assignedCampus?: true
    studentFee?: true
    academicYear?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    paymentAmount?: true
    paymentStatus?: true
    transactionId?: true
    aadharNo?: true
    childEprNo?: true
    empId?: true
    password?: true
    deletionRequestedAt?: true
    role?: true
    status?: true
    benefitStatus?: true
  }

  export type UserCountAggregateInputType = {
    userId?: true
    fullName?: true
    mobileNumber?: true
    childInAchariya?: true
    childName?: true
    grade?: true
    campusId?: true
    bankAccountDetails?: true
    referralCode?: true
    confirmedReferralCount?: true
    yearFeeBenefitPercent?: true
    longTermBenefitPercent?: true
    lastActiveYear?: true
    isFiveStarMember?: true
    assignedCampus?: true
    studentFee?: true
    academicYear?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    paymentAmount?: true
    paymentStatus?: true
    transactionId?: true
    aadharNo?: true
    childEprNo?: true
    empId?: true
    password?: true
    deletionRequestedAt?: true
    role?: true
    status?: true
    benefitStatus?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    userId: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName: string | null
    grade: string | null
    campusId: number | null
    bankAccountDetails: string | null
    referralCode: string | null
    confirmedReferralCount: number
    yearFeeBenefitPercent: number
    longTermBenefitPercent: number
    lastActiveYear: number | null
    isFiveStarMember: boolean
    assignedCampus: string | null
    studentFee: number
    academicYear: string
    createdAt: Date
    profileImage: string | null
    email: string | null
    address: string | null
    paymentAmount: number
    paymentStatus: string
    transactionId: string | null
    aadharNo: string | null
    childEprNo: string | null
    empId: string | null
    password: string | null
    deletionRequestedAt: Date | null
    role: $Enums.UserRole
    status: $Enums.AccountStatus
    benefitStatus: $Enums.AccountStatus
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fullName?: boolean
    mobileNumber?: boolean
    childInAchariya?: boolean
    childName?: boolean
    grade?: boolean
    campusId?: boolean
    bankAccountDetails?: boolean
    referralCode?: boolean
    confirmedReferralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermBenefitPercent?: boolean
    lastActiveYear?: boolean
    isFiveStarMember?: boolean
    assignedCampus?: boolean
    studentFee?: boolean
    academicYear?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    paymentAmount?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    aadharNo?: boolean
    childEprNo?: boolean
    empId?: boolean
    password?: boolean
    deletionRequestedAt?: boolean
    role?: boolean
    status?: boolean
    benefitStatus?: boolean
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    settlements?: boolean | User$settlementsArgs<ExtArgs>
    referredStudents?: boolean | User$referredStudentsArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    fullName?: boolean
    mobileNumber?: boolean
    childInAchariya?: boolean
    childName?: boolean
    grade?: boolean
    campusId?: boolean
    bankAccountDetails?: boolean
    referralCode?: boolean
    confirmedReferralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermBenefitPercent?: boolean
    lastActiveYear?: boolean
    isFiveStarMember?: boolean
    assignedCampus?: boolean
    studentFee?: boolean
    academicYear?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    paymentAmount?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    aadharNo?: boolean
    childEprNo?: boolean
    empId?: boolean
    password?: boolean
    deletionRequestedAt?: boolean
    role?: boolean
    status?: boolean
    benefitStatus?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    userId?: boolean
    fullName?: boolean
    mobileNumber?: boolean
    childInAchariya?: boolean
    childName?: boolean
    grade?: boolean
    campusId?: boolean
    bankAccountDetails?: boolean
    referralCode?: boolean
    confirmedReferralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermBenefitPercent?: boolean
    lastActiveYear?: boolean
    isFiveStarMember?: boolean
    assignedCampus?: boolean
    studentFee?: boolean
    academicYear?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    paymentAmount?: boolean
    paymentStatus?: boolean
    transactionId?: boolean
    aadharNo?: boolean
    childEprNo?: boolean
    empId?: boolean
    password?: boolean
    deletionRequestedAt?: boolean
    role?: boolean
    status?: boolean
    benefitStatus?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    settlements?: boolean | User$settlementsArgs<ExtArgs>
    referredStudents?: boolean | User$referredStudentsArgs<ExtArgs>
    students?: boolean | User$studentsArgs<ExtArgs>
    supportTickets?: boolean | User$supportTicketsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      referrals: Prisma.$ReferralLeadPayload<ExtArgs>[]
      settlements: Prisma.$SettlementPayload<ExtArgs>[]
      referredStudents: Prisma.$StudentPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      supportTickets: Prisma.$SupportTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      fullName: string
      mobileNumber: string
      childInAchariya: boolean
      childName: string | null
      grade: string | null
      campusId: number | null
      bankAccountDetails: string | null
      referralCode: string | null
      confirmedReferralCount: number
      yearFeeBenefitPercent: number
      longTermBenefitPercent: number
      lastActiveYear: number | null
      isFiveStarMember: boolean
      assignedCampus: string | null
      studentFee: number
      academicYear: string
      createdAt: Date
      profileImage: string | null
      email: string | null
      address: string | null
      paymentAmount: number
      paymentStatus: string
      transactionId: string | null
      aadharNo: string | null
      childEprNo: string | null
      empId: string | null
      password: string | null
      deletionRequestedAt: Date | null
      role: $Enums.UserRole
      status: $Enums.AccountStatus
      benefitStatus: $Enums.AccountStatus
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userWithUserIdOnly = await prisma.user.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `userId`
     * const userWithUserIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findMany"> | Null>
    settlements<T extends User$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, User$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findMany"> | Null>
    referredStudents<T extends User$referredStudentsArgs<ExtArgs> = {}>(args?: Subset<T, User$referredStudentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends User$studentsArgs<ExtArgs> = {}>(args?: Subset<T, User$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    supportTickets<T extends User$supportTicketsArgs<ExtArgs> = {}>(args?: Subset<T, User$supportTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly userId: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly mobileNumber: FieldRef<"User", 'String'>
    readonly childInAchariya: FieldRef<"User", 'Boolean'>
    readonly childName: FieldRef<"User", 'String'>
    readonly grade: FieldRef<"User", 'String'>
    readonly campusId: FieldRef<"User", 'Int'>
    readonly bankAccountDetails: FieldRef<"User", 'String'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly confirmedReferralCount: FieldRef<"User", 'Int'>
    readonly yearFeeBenefitPercent: FieldRef<"User", 'Float'>
    readonly longTermBenefitPercent: FieldRef<"User", 'Float'>
    readonly lastActiveYear: FieldRef<"User", 'Int'>
    readonly isFiveStarMember: FieldRef<"User", 'Boolean'>
    readonly assignedCampus: FieldRef<"User", 'String'>
    readonly studentFee: FieldRef<"User", 'Int'>
    readonly academicYear: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly paymentAmount: FieldRef<"User", 'Int'>
    readonly paymentStatus: FieldRef<"User", 'String'>
    readonly transactionId: FieldRef<"User", 'String'>
    readonly aadharNo: FieldRef<"User", 'String'>
    readonly childEprNo: FieldRef<"User", 'String'>
    readonly empId: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly deletionRequestedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'AccountStatus'>
    readonly benefitStatus: FieldRef<"User", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    where?: ReferralLeadWhereInput
    orderBy?: ReferralLeadOrderByWithRelationInput | ReferralLeadOrderByWithRelationInput[]
    cursor?: ReferralLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralLeadScalarFieldEnum | ReferralLeadScalarFieldEnum[]
  }

  /**
   * User.settlements
   */
  export type User$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    where?: SettlementWhereInput
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    cursor?: SettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * User.referredStudents
   */
  export type User$referredStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * User.students
   */
  export type User$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * User.supportTickets
   */
  export type User$supportTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    cursor?: SupportTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    studentId: number | null
    parentId: number | null
    campusId: number | null
    baseFee: number | null
    discountPercent: number | null
    referralLeadId: number | null
    ambassadorId: number | null
    annualFee: number | null
  }

  export type StudentSumAggregateOutputType = {
    studentId: number | null
    parentId: number | null
    campusId: number | null
    baseFee: number | null
    discountPercent: number | null
    referralLeadId: number | null
    ambassadorId: number | null
    annualFee: number | null
  }

  export type StudentMinAggregateOutputType = {
    studentId: number | null
    fullName: string | null
    parentId: number | null
    campusId: number | null
    grade: string | null
    section: string | null
    rollNumber: string | null
    academicYear: string | null
    status: string | null
    baseFee: number | null
    discountPercent: number | null
    referralLeadId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ambassadorId: number | null
    admissionNumber: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
  }

  export type StudentMaxAggregateOutputType = {
    studentId: number | null
    fullName: string | null
    parentId: number | null
    campusId: number | null
    grade: string | null
    section: string | null
    rollNumber: string | null
    academicYear: string | null
    status: string | null
    baseFee: number | null
    discountPercent: number | null
    referralLeadId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    ambassadorId: number | null
    admissionNumber: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
  }

  export type StudentCountAggregateOutputType = {
    studentId: number
    fullName: number
    parentId: number
    campusId: number
    grade: number
    section: number
    rollNumber: number
    academicYear: number
    status: number
    baseFee: number
    discountPercent: number
    referralLeadId: number
    createdAt: number
    updatedAt: number
    ambassadorId: number
    admissionNumber: number
    selectedFeeType: number
    annualFee: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    studentId?: true
    parentId?: true
    campusId?: true
    baseFee?: true
    discountPercent?: true
    referralLeadId?: true
    ambassadorId?: true
    annualFee?: true
  }

  export type StudentSumAggregateInputType = {
    studentId?: true
    parentId?: true
    campusId?: true
    baseFee?: true
    discountPercent?: true
    referralLeadId?: true
    ambassadorId?: true
    annualFee?: true
  }

  export type StudentMinAggregateInputType = {
    studentId?: true
    fullName?: true
    parentId?: true
    campusId?: true
    grade?: true
    section?: true
    rollNumber?: true
    academicYear?: true
    status?: true
    baseFee?: true
    discountPercent?: true
    referralLeadId?: true
    createdAt?: true
    updatedAt?: true
    ambassadorId?: true
    admissionNumber?: true
    selectedFeeType?: true
    annualFee?: true
  }

  export type StudentMaxAggregateInputType = {
    studentId?: true
    fullName?: true
    parentId?: true
    campusId?: true
    grade?: true
    section?: true
    rollNumber?: true
    academicYear?: true
    status?: true
    baseFee?: true
    discountPercent?: true
    referralLeadId?: true
    createdAt?: true
    updatedAt?: true
    ambassadorId?: true
    admissionNumber?: true
    selectedFeeType?: true
    annualFee?: true
  }

  export type StudentCountAggregateInputType = {
    studentId?: true
    fullName?: true
    parentId?: true
    campusId?: true
    grade?: true
    section?: true
    rollNumber?: true
    academicYear?: true
    status?: true
    baseFee?: true
    discountPercent?: true
    referralLeadId?: true
    createdAt?: true
    updatedAt?: true
    ambassadorId?: true
    admissionNumber?: true
    selectedFeeType?: true
    annualFee?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    studentId: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section: string | null
    rollNumber: string | null
    academicYear: string
    status: string
    baseFee: number
    discountPercent: number
    referralLeadId: number | null
    createdAt: Date
    updatedAt: Date
    ambassadorId: number | null
    admissionNumber: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentId?: boolean
    fullName?: boolean
    parentId?: boolean
    campusId?: boolean
    grade?: boolean
    section?: boolean
    rollNumber?: boolean
    academicYear?: boolean
    status?: boolean
    baseFee?: boolean
    discountPercent?: boolean
    referralLeadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambassadorId?: boolean
    admissionNumber?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
    ambassador?: boolean | Student$ambassadorArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parent?: boolean | UserDefaultArgs<ExtArgs>
    referralLead?: boolean | Student$referralLeadArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentId?: boolean
    fullName?: boolean
    parentId?: boolean
    campusId?: boolean
    grade?: boolean
    section?: boolean
    rollNumber?: boolean
    academicYear?: boolean
    status?: boolean
    baseFee?: boolean
    discountPercent?: boolean
    referralLeadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambassadorId?: boolean
    admissionNumber?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
    ambassador?: boolean | Student$ambassadorArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parent?: boolean | UserDefaultArgs<ExtArgs>
    referralLead?: boolean | Student$referralLeadArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    studentId?: boolean
    fullName?: boolean
    parentId?: boolean
    campusId?: boolean
    grade?: boolean
    section?: boolean
    rollNumber?: boolean
    academicYear?: boolean
    status?: boolean
    baseFee?: boolean
    discountPercent?: boolean
    referralLeadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ambassadorId?: boolean
    admissionNumber?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambassador?: boolean | Student$ambassadorArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parent?: boolean | UserDefaultArgs<ExtArgs>
    referralLead?: boolean | Student$referralLeadArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ambassador?: boolean | Student$ambassadorArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parent?: boolean | UserDefaultArgs<ExtArgs>
    referralLead?: boolean | Student$referralLeadArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      ambassador: Prisma.$UserPayload<ExtArgs> | null
      campus: Prisma.$CampusPayload<ExtArgs>
      parent: Prisma.$UserPayload<ExtArgs>
      referralLead: Prisma.$ReferralLeadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      studentId: number
      fullName: string
      parentId: number
      campusId: number
      grade: string
      section: string | null
      rollNumber: string | null
      academicYear: string
      status: string
      baseFee: number
      discountPercent: number
      referralLeadId: number | null
      createdAt: Date
      updatedAt: Date
      ambassadorId: number | null
      admissionNumber: string | null
      selectedFeeType: $Enums.FeeType | null
      annualFee: number | null
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `studentId`
     * const studentWithStudentIdOnly = await prisma.student.findMany({ select: { studentId: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `studentId`
     * const studentWithStudentIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { studentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ambassador<T extends Student$ambassadorArgs<ExtArgs> = {}>(args?: Subset<T, Student$ambassadorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    referralLead<T extends Student$referralLeadArgs<ExtArgs> = {}>(args?: Subset<T, Student$referralLeadArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly studentId: FieldRef<"Student", 'Int'>
    readonly fullName: FieldRef<"Student", 'String'>
    readonly parentId: FieldRef<"Student", 'Int'>
    readonly campusId: FieldRef<"Student", 'Int'>
    readonly grade: FieldRef<"Student", 'String'>
    readonly section: FieldRef<"Student", 'String'>
    readonly rollNumber: FieldRef<"Student", 'String'>
    readonly academicYear: FieldRef<"Student", 'String'>
    readonly status: FieldRef<"Student", 'String'>
    readonly baseFee: FieldRef<"Student", 'Int'>
    readonly discountPercent: FieldRef<"Student", 'Float'>
    readonly referralLeadId: FieldRef<"Student", 'Int'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
    readonly ambassadorId: FieldRef<"Student", 'Int'>
    readonly admissionNumber: FieldRef<"Student", 'String'>
    readonly selectedFeeType: FieldRef<"Student", 'FeeType'>
    readonly annualFee: FieldRef<"Student", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.ambassador
   */
  export type Student$ambassadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Student.referralLead
   */
  export type Student$referralLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    where?: ReferralLeadWhereInput
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model ReferralLead
   */

  export type AggregateReferralLead = {
    _count: ReferralLeadCountAggregateOutputType | null
    _avg: ReferralLeadAvgAggregateOutputType | null
    _sum: ReferralLeadSumAggregateOutputType | null
    _min: ReferralLeadMinAggregateOutputType | null
    _max: ReferralLeadMaxAggregateOutputType | null
  }

  export type ReferralLeadAvgAggregateOutputType = {
    leadId: number | null
    userId: number | null
    campusId: number | null
    annualFee: number | null
  }

  export type ReferralLeadSumAggregateOutputType = {
    leadId: number | null
    userId: number | null
    campusId: number | null
    annualFee: number | null
  }

  export type ReferralLeadMinAggregateOutputType = {
    leadId: number | null
    userId: number | null
    parentName: string | null
    parentMobile: string | null
    campusId: number | null
    campus: string | null
    gradeInterested: string | null
    admittedYear: string | null
    confirmedDate: Date | null
    createdAt: Date | null
    studentName: string | null
    leadStatus: $Enums.LeadStatus | null
    admissionNumber: string | null
    section: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
  }

  export type ReferralLeadMaxAggregateOutputType = {
    leadId: number | null
    userId: number | null
    parentName: string | null
    parentMobile: string | null
    campusId: number | null
    campus: string | null
    gradeInterested: string | null
    admittedYear: string | null
    confirmedDate: Date | null
    createdAt: Date | null
    studentName: string | null
    leadStatus: $Enums.LeadStatus | null
    admissionNumber: string | null
    section: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
  }

  export type ReferralLeadCountAggregateOutputType = {
    leadId: number
    userId: number
    parentName: number
    parentMobile: number
    campusId: number
    campus: number
    gradeInterested: number
    admittedYear: number
    confirmedDate: number
    createdAt: number
    studentName: number
    leadStatus: number
    admissionNumber: number
    section: number
    selectedFeeType: number
    annualFee: number
    _all: number
  }


  export type ReferralLeadAvgAggregateInputType = {
    leadId?: true
    userId?: true
    campusId?: true
    annualFee?: true
  }

  export type ReferralLeadSumAggregateInputType = {
    leadId?: true
    userId?: true
    campusId?: true
    annualFee?: true
  }

  export type ReferralLeadMinAggregateInputType = {
    leadId?: true
    userId?: true
    parentName?: true
    parentMobile?: true
    campusId?: true
    campus?: true
    gradeInterested?: true
    admittedYear?: true
    confirmedDate?: true
    createdAt?: true
    studentName?: true
    leadStatus?: true
    admissionNumber?: true
    section?: true
    selectedFeeType?: true
    annualFee?: true
  }

  export type ReferralLeadMaxAggregateInputType = {
    leadId?: true
    userId?: true
    parentName?: true
    parentMobile?: true
    campusId?: true
    campus?: true
    gradeInterested?: true
    admittedYear?: true
    confirmedDate?: true
    createdAt?: true
    studentName?: true
    leadStatus?: true
    admissionNumber?: true
    section?: true
    selectedFeeType?: true
    annualFee?: true
  }

  export type ReferralLeadCountAggregateInputType = {
    leadId?: true
    userId?: true
    parentName?: true
    parentMobile?: true
    campusId?: true
    campus?: true
    gradeInterested?: true
    admittedYear?: true
    confirmedDate?: true
    createdAt?: true
    studentName?: true
    leadStatus?: true
    admissionNumber?: true
    section?: true
    selectedFeeType?: true
    annualFee?: true
    _all?: true
  }

  export type ReferralLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralLead to aggregate.
     */
    where?: ReferralLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLeads to fetch.
     */
    orderBy?: ReferralLeadOrderByWithRelationInput | ReferralLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReferralLeads
    **/
    _count?: true | ReferralLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralLeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralLeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralLeadMaxAggregateInputType
  }

  export type GetReferralLeadAggregateType<T extends ReferralLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateReferralLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferralLead[P]>
      : GetScalarType<T[P], AggregateReferralLead[P]>
  }




  export type ReferralLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralLeadWhereInput
    orderBy?: ReferralLeadOrderByWithAggregationInput | ReferralLeadOrderByWithAggregationInput[]
    by: ReferralLeadScalarFieldEnum[] | ReferralLeadScalarFieldEnum
    having?: ReferralLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralLeadCountAggregateInputType | true
    _avg?: ReferralLeadAvgAggregateInputType
    _sum?: ReferralLeadSumAggregateInputType
    _min?: ReferralLeadMinAggregateInputType
    _max?: ReferralLeadMaxAggregateInputType
  }

  export type ReferralLeadGroupByOutputType = {
    leadId: number
    userId: number
    parentName: string
    parentMobile: string
    campusId: number | null
    campus: string | null
    gradeInterested: string | null
    admittedYear: string | null
    confirmedDate: Date | null
    createdAt: Date
    studentName: string | null
    leadStatus: $Enums.LeadStatus
    admissionNumber: string | null
    section: string | null
    selectedFeeType: $Enums.FeeType | null
    annualFee: number | null
    _count: ReferralLeadCountAggregateOutputType | null
    _avg: ReferralLeadAvgAggregateOutputType | null
    _sum: ReferralLeadSumAggregateOutputType | null
    _min: ReferralLeadMinAggregateOutputType | null
    _max: ReferralLeadMaxAggregateOutputType | null
  }

  type GetReferralLeadGroupByPayload<T extends ReferralLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralLeadGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralLeadGroupByOutputType[P]>
        }
      >
    >


  export type ReferralLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    userId?: boolean
    parentName?: boolean
    parentMobile?: boolean
    campusId?: boolean
    campus?: boolean
    gradeInterested?: boolean
    admittedYear?: boolean
    confirmedDate?: boolean
    createdAt?: boolean
    studentName?: boolean
    leadStatus?: boolean
    admissionNumber?: boolean
    section?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | ReferralLead$studentArgs<ExtArgs>
  }, ExtArgs["result"]["referralLead"]>

  export type ReferralLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    leadId?: boolean
    userId?: boolean
    parentName?: boolean
    parentMobile?: boolean
    campusId?: boolean
    campus?: boolean
    gradeInterested?: boolean
    admittedYear?: boolean
    confirmedDate?: boolean
    createdAt?: boolean
    studentName?: boolean
    leadStatus?: boolean
    admissionNumber?: boolean
    section?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referralLead"]>

  export type ReferralLeadSelectScalar = {
    leadId?: boolean
    userId?: boolean
    parentName?: boolean
    parentMobile?: boolean
    campusId?: boolean
    campus?: boolean
    gradeInterested?: boolean
    admittedYear?: boolean
    confirmedDate?: boolean
    createdAt?: boolean
    studentName?: boolean
    leadStatus?: boolean
    admissionNumber?: boolean
    section?: boolean
    selectedFeeType?: boolean
    annualFee?: boolean
  }

  export type ReferralLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    student?: boolean | ReferralLead$studentArgs<ExtArgs>
  }
  export type ReferralLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReferralLead"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      leadId: number
      userId: number
      parentName: string
      parentMobile: string
      campusId: number | null
      campus: string | null
      gradeInterested: string | null
      admittedYear: string | null
      confirmedDate: Date | null
      createdAt: Date
      studentName: string | null
      leadStatus: $Enums.LeadStatus
      admissionNumber: string | null
      section: string | null
      selectedFeeType: $Enums.FeeType | null
      annualFee: number | null
    }, ExtArgs["result"]["referralLead"]>
    composites: {}
  }

  type ReferralLeadGetPayload<S extends boolean | null | undefined | ReferralLeadDefaultArgs> = $Result.GetResult<Prisma.$ReferralLeadPayload, S>

  type ReferralLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReferralLeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReferralLeadCountAggregateInputType | true
    }

  export interface ReferralLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReferralLead'], meta: { name: 'ReferralLead' } }
    /**
     * Find zero or one ReferralLead that matches the filter.
     * @param {ReferralLeadFindUniqueArgs} args - Arguments to find a ReferralLead
     * @example
     * // Get one ReferralLead
     * const referralLead = await prisma.referralLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralLeadFindUniqueArgs>(args: SelectSubset<T, ReferralLeadFindUniqueArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReferralLead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReferralLeadFindUniqueOrThrowArgs} args - Arguments to find a ReferralLead
     * @example
     * // Get one ReferralLead
     * const referralLead = await prisma.referralLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReferralLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadFindFirstArgs} args - Arguments to find a ReferralLead
     * @example
     * // Get one ReferralLead
     * const referralLead = await prisma.referralLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralLeadFindFirstArgs>(args?: SelectSubset<T, ReferralLeadFindFirstArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReferralLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadFindFirstOrThrowArgs} args - Arguments to find a ReferralLead
     * @example
     * // Get one ReferralLead
     * const referralLead = await prisma.referralLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReferralLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReferralLeads
     * const referralLeads = await prisma.referralLead.findMany()
     * 
     * // Get first 10 ReferralLeads
     * const referralLeads = await prisma.referralLead.findMany({ take: 10 })
     * 
     * // Only select the `leadId`
     * const referralLeadWithLeadIdOnly = await prisma.referralLead.findMany({ select: { leadId: true } })
     * 
     */
    findMany<T extends ReferralLeadFindManyArgs>(args?: SelectSubset<T, ReferralLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReferralLead.
     * @param {ReferralLeadCreateArgs} args - Arguments to create a ReferralLead.
     * @example
     * // Create one ReferralLead
     * const ReferralLead = await prisma.referralLead.create({
     *   data: {
     *     // ... data to create a ReferralLead
     *   }
     * })
     * 
     */
    create<T extends ReferralLeadCreateArgs>(args: SelectSubset<T, ReferralLeadCreateArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReferralLeads.
     * @param {ReferralLeadCreateManyArgs} args - Arguments to create many ReferralLeads.
     * @example
     * // Create many ReferralLeads
     * const referralLead = await prisma.referralLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralLeadCreateManyArgs>(args?: SelectSubset<T, ReferralLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReferralLeads and returns the data saved in the database.
     * @param {ReferralLeadCreateManyAndReturnArgs} args - Arguments to create many ReferralLeads.
     * @example
     * // Create many ReferralLeads
     * const referralLead = await prisma.referralLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReferralLeads and only return the `leadId`
     * const referralLeadWithLeadIdOnly = await prisma.referralLead.createManyAndReturn({ 
     *   select: { leadId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReferralLead.
     * @param {ReferralLeadDeleteArgs} args - Arguments to delete one ReferralLead.
     * @example
     * // Delete one ReferralLead
     * const ReferralLead = await prisma.referralLead.delete({
     *   where: {
     *     // ... filter to delete one ReferralLead
     *   }
     * })
     * 
     */
    delete<T extends ReferralLeadDeleteArgs>(args: SelectSubset<T, ReferralLeadDeleteArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReferralLead.
     * @param {ReferralLeadUpdateArgs} args - Arguments to update one ReferralLead.
     * @example
     * // Update one ReferralLead
     * const referralLead = await prisma.referralLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralLeadUpdateArgs>(args: SelectSubset<T, ReferralLeadUpdateArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReferralLeads.
     * @param {ReferralLeadDeleteManyArgs} args - Arguments to filter ReferralLeads to delete.
     * @example
     * // Delete a few ReferralLeads
     * const { count } = await prisma.referralLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralLeadDeleteManyArgs>(args?: SelectSubset<T, ReferralLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReferralLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReferralLeads
     * const referralLead = await prisma.referralLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralLeadUpdateManyArgs>(args: SelectSubset<T, ReferralLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReferralLead.
     * @param {ReferralLeadUpsertArgs} args - Arguments to update or create a ReferralLead.
     * @example
     * // Update or create a ReferralLead
     * const referralLead = await prisma.referralLead.upsert({
     *   create: {
     *     // ... data to create a ReferralLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReferralLead we want to update
     *   }
     * })
     */
    upsert<T extends ReferralLeadUpsertArgs>(args: SelectSubset<T, ReferralLeadUpsertArgs<ExtArgs>>): Prisma__ReferralLeadClient<$Result.GetResult<Prisma.$ReferralLeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReferralLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadCountArgs} args - Arguments to filter ReferralLeads to count.
     * @example
     * // Count the number of ReferralLeads
     * const count = await prisma.referralLead.count({
     *   where: {
     *     // ... the filter for the ReferralLeads we want to count
     *   }
     * })
    **/
    count<T extends ReferralLeadCountArgs>(
      args?: Subset<T, ReferralLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReferralLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralLeadAggregateArgs>(args: Subset<T, ReferralLeadAggregateArgs>): Prisma.PrismaPromise<GetReferralLeadAggregateType<T>>

    /**
     * Group by ReferralLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralLeadGroupByArgs['orderBy'] }
        : { orderBy?: ReferralLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReferralLead model
   */
  readonly fields: ReferralLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReferralLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends ReferralLead$studentArgs<ExtArgs> = {}>(args?: Subset<T, ReferralLead$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReferralLead model
   */ 
  interface ReferralLeadFieldRefs {
    readonly leadId: FieldRef<"ReferralLead", 'Int'>
    readonly userId: FieldRef<"ReferralLead", 'Int'>
    readonly parentName: FieldRef<"ReferralLead", 'String'>
    readonly parentMobile: FieldRef<"ReferralLead", 'String'>
    readonly campusId: FieldRef<"ReferralLead", 'Int'>
    readonly campus: FieldRef<"ReferralLead", 'String'>
    readonly gradeInterested: FieldRef<"ReferralLead", 'String'>
    readonly admittedYear: FieldRef<"ReferralLead", 'String'>
    readonly confirmedDate: FieldRef<"ReferralLead", 'DateTime'>
    readonly createdAt: FieldRef<"ReferralLead", 'DateTime'>
    readonly studentName: FieldRef<"ReferralLead", 'String'>
    readonly leadStatus: FieldRef<"ReferralLead", 'LeadStatus'>
    readonly admissionNumber: FieldRef<"ReferralLead", 'String'>
    readonly section: FieldRef<"ReferralLead", 'String'>
    readonly selectedFeeType: FieldRef<"ReferralLead", 'FeeType'>
    readonly annualFee: FieldRef<"ReferralLead", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReferralLead findUnique
   */
  export type ReferralLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLead to fetch.
     */
    where: ReferralLeadWhereUniqueInput
  }

  /**
   * ReferralLead findUniqueOrThrow
   */
  export type ReferralLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLead to fetch.
     */
    where: ReferralLeadWhereUniqueInput
  }

  /**
   * ReferralLead findFirst
   */
  export type ReferralLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLead to fetch.
     */
    where?: ReferralLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLeads to fetch.
     */
    orderBy?: ReferralLeadOrderByWithRelationInput | ReferralLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralLeads.
     */
    cursor?: ReferralLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralLeads.
     */
    distinct?: ReferralLeadScalarFieldEnum | ReferralLeadScalarFieldEnum[]
  }

  /**
   * ReferralLead findFirstOrThrow
   */
  export type ReferralLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLead to fetch.
     */
    where?: ReferralLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLeads to fetch.
     */
    orderBy?: ReferralLeadOrderByWithRelationInput | ReferralLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReferralLeads.
     */
    cursor?: ReferralLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReferralLeads.
     */
    distinct?: ReferralLeadScalarFieldEnum | ReferralLeadScalarFieldEnum[]
  }

  /**
   * ReferralLead findMany
   */
  export type ReferralLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter, which ReferralLeads to fetch.
     */
    where?: ReferralLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReferralLeads to fetch.
     */
    orderBy?: ReferralLeadOrderByWithRelationInput | ReferralLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReferralLeads.
     */
    cursor?: ReferralLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReferralLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReferralLeads.
     */
    skip?: number
    distinct?: ReferralLeadScalarFieldEnum | ReferralLeadScalarFieldEnum[]
  }

  /**
   * ReferralLead create
   */
  export type ReferralLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a ReferralLead.
     */
    data: XOR<ReferralLeadCreateInput, ReferralLeadUncheckedCreateInput>
  }

  /**
   * ReferralLead createMany
   */
  export type ReferralLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReferralLeads.
     */
    data: ReferralLeadCreateManyInput | ReferralLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReferralLead createManyAndReturn
   */
  export type ReferralLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReferralLeads.
     */
    data: ReferralLeadCreateManyInput | ReferralLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReferralLead update
   */
  export type ReferralLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a ReferralLead.
     */
    data: XOR<ReferralLeadUpdateInput, ReferralLeadUncheckedUpdateInput>
    /**
     * Choose, which ReferralLead to update.
     */
    where: ReferralLeadWhereUniqueInput
  }

  /**
   * ReferralLead updateMany
   */
  export type ReferralLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReferralLeads.
     */
    data: XOR<ReferralLeadUpdateManyMutationInput, ReferralLeadUncheckedUpdateManyInput>
    /**
     * Filter which ReferralLeads to update
     */
    where?: ReferralLeadWhereInput
  }

  /**
   * ReferralLead upsert
   */
  export type ReferralLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the ReferralLead to update in case it exists.
     */
    where: ReferralLeadWhereUniqueInput
    /**
     * In case the ReferralLead found by the `where` argument doesn't exist, create a new ReferralLead with this data.
     */
    create: XOR<ReferralLeadCreateInput, ReferralLeadUncheckedCreateInput>
    /**
     * In case the ReferralLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralLeadUpdateInput, ReferralLeadUncheckedUpdateInput>
  }

  /**
   * ReferralLead delete
   */
  export type ReferralLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
    /**
     * Filter which ReferralLead to delete.
     */
    where: ReferralLeadWhereUniqueInput
  }

  /**
   * ReferralLead deleteMany
   */
  export type ReferralLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReferralLeads to delete
     */
    where?: ReferralLeadWhereInput
  }

  /**
   * ReferralLead.student
   */
  export type ReferralLead$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * ReferralLead without action
   */
  export type ReferralLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReferralLead
     */
    select?: ReferralLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralLeadInclude<ExtArgs> | null
  }


  /**
   * Model BenefitSlab
   */

  export type AggregateBenefitSlab = {
    _count: BenefitSlabCountAggregateOutputType | null
    _avg: BenefitSlabAvgAggregateOutputType | null
    _sum: BenefitSlabSumAggregateOutputType | null
    _min: BenefitSlabMinAggregateOutputType | null
    _max: BenefitSlabMaxAggregateOutputType | null
  }

  export type BenefitSlabAvgAggregateOutputType = {
    slabId: number | null
    referralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermExtraPercent: number | null
    baseLongTermPercent: number | null
  }

  export type BenefitSlabSumAggregateOutputType = {
    slabId: number | null
    referralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermExtraPercent: number | null
    baseLongTermPercent: number | null
  }

  export type BenefitSlabMinAggregateOutputType = {
    slabId: number | null
    tierName: string | null
    referralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermExtraPercent: number | null
    baseLongTermPercent: number | null
    description: string | null
  }

  export type BenefitSlabMaxAggregateOutputType = {
    slabId: number | null
    tierName: string | null
    referralCount: number | null
    yearFeeBenefitPercent: number | null
    longTermExtraPercent: number | null
    baseLongTermPercent: number | null
    description: string | null
  }

  export type BenefitSlabCountAggregateOutputType = {
    slabId: number
    tierName: number
    referralCount: number
    yearFeeBenefitPercent: number
    longTermExtraPercent: number
    baseLongTermPercent: number
    description: number
    _all: number
  }


  export type BenefitSlabAvgAggregateInputType = {
    slabId?: true
    referralCount?: true
    yearFeeBenefitPercent?: true
    longTermExtraPercent?: true
    baseLongTermPercent?: true
  }

  export type BenefitSlabSumAggregateInputType = {
    slabId?: true
    referralCount?: true
    yearFeeBenefitPercent?: true
    longTermExtraPercent?: true
    baseLongTermPercent?: true
  }

  export type BenefitSlabMinAggregateInputType = {
    slabId?: true
    tierName?: true
    referralCount?: true
    yearFeeBenefitPercent?: true
    longTermExtraPercent?: true
    baseLongTermPercent?: true
    description?: true
  }

  export type BenefitSlabMaxAggregateInputType = {
    slabId?: true
    tierName?: true
    referralCount?: true
    yearFeeBenefitPercent?: true
    longTermExtraPercent?: true
    baseLongTermPercent?: true
    description?: true
  }

  export type BenefitSlabCountAggregateInputType = {
    slabId?: true
    tierName?: true
    referralCount?: true
    yearFeeBenefitPercent?: true
    longTermExtraPercent?: true
    baseLongTermPercent?: true
    description?: true
    _all?: true
  }

  export type BenefitSlabAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenefitSlab to aggregate.
     */
    where?: BenefitSlabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitSlabs to fetch.
     */
    orderBy?: BenefitSlabOrderByWithRelationInput | BenefitSlabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenefitSlabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitSlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitSlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BenefitSlabs
    **/
    _count?: true | BenefitSlabCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BenefitSlabAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BenefitSlabSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenefitSlabMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenefitSlabMaxAggregateInputType
  }

  export type GetBenefitSlabAggregateType<T extends BenefitSlabAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefitSlab]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefitSlab[P]>
      : GetScalarType<T[P], AggregateBenefitSlab[P]>
  }




  export type BenefitSlabGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenefitSlabWhereInput
    orderBy?: BenefitSlabOrderByWithAggregationInput | BenefitSlabOrderByWithAggregationInput[]
    by: BenefitSlabScalarFieldEnum[] | BenefitSlabScalarFieldEnum
    having?: BenefitSlabScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefitSlabCountAggregateInputType | true
    _avg?: BenefitSlabAvgAggregateInputType
    _sum?: BenefitSlabSumAggregateInputType
    _min?: BenefitSlabMinAggregateInputType
    _max?: BenefitSlabMaxAggregateInputType
  }

  export type BenefitSlabGroupByOutputType = {
    slabId: number
    tierName: string | null
    referralCount: number
    yearFeeBenefitPercent: number
    longTermExtraPercent: number
    baseLongTermPercent: number
    description: string | null
    _count: BenefitSlabCountAggregateOutputType | null
    _avg: BenefitSlabAvgAggregateOutputType | null
    _sum: BenefitSlabSumAggregateOutputType | null
    _min: BenefitSlabMinAggregateOutputType | null
    _max: BenefitSlabMaxAggregateOutputType | null
  }

  type GetBenefitSlabGroupByPayload<T extends BenefitSlabGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenefitSlabGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefitSlabGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefitSlabGroupByOutputType[P]>
            : GetScalarType<T[P], BenefitSlabGroupByOutputType[P]>
        }
      >
    >


  export type BenefitSlabSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    slabId?: boolean
    tierName?: boolean
    referralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermExtraPercent?: boolean
    baseLongTermPercent?: boolean
    description?: boolean
  }, ExtArgs["result"]["benefitSlab"]>

  export type BenefitSlabSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    slabId?: boolean
    tierName?: boolean
    referralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermExtraPercent?: boolean
    baseLongTermPercent?: boolean
    description?: boolean
  }, ExtArgs["result"]["benefitSlab"]>

  export type BenefitSlabSelectScalar = {
    slabId?: boolean
    tierName?: boolean
    referralCount?: boolean
    yearFeeBenefitPercent?: boolean
    longTermExtraPercent?: boolean
    baseLongTermPercent?: boolean
    description?: boolean
  }


  export type $BenefitSlabPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BenefitSlab"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      slabId: number
      tierName: string | null
      referralCount: number
      yearFeeBenefitPercent: number
      longTermExtraPercent: number
      baseLongTermPercent: number
      description: string | null
    }, ExtArgs["result"]["benefitSlab"]>
    composites: {}
  }

  type BenefitSlabGetPayload<S extends boolean | null | undefined | BenefitSlabDefaultArgs> = $Result.GetResult<Prisma.$BenefitSlabPayload, S>

  type BenefitSlabCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BenefitSlabFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BenefitSlabCountAggregateInputType | true
    }

  export interface BenefitSlabDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BenefitSlab'], meta: { name: 'BenefitSlab' } }
    /**
     * Find zero or one BenefitSlab that matches the filter.
     * @param {BenefitSlabFindUniqueArgs} args - Arguments to find a BenefitSlab
     * @example
     * // Get one BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenefitSlabFindUniqueArgs>(args: SelectSubset<T, BenefitSlabFindUniqueArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BenefitSlab that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BenefitSlabFindUniqueOrThrowArgs} args - Arguments to find a BenefitSlab
     * @example
     * // Get one BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenefitSlabFindUniqueOrThrowArgs>(args: SelectSubset<T, BenefitSlabFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BenefitSlab that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabFindFirstArgs} args - Arguments to find a BenefitSlab
     * @example
     * // Get one BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenefitSlabFindFirstArgs>(args?: SelectSubset<T, BenefitSlabFindFirstArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BenefitSlab that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabFindFirstOrThrowArgs} args - Arguments to find a BenefitSlab
     * @example
     * // Get one BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenefitSlabFindFirstOrThrowArgs>(args?: SelectSubset<T, BenefitSlabFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BenefitSlabs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BenefitSlabs
     * const benefitSlabs = await prisma.benefitSlab.findMany()
     * 
     * // Get first 10 BenefitSlabs
     * const benefitSlabs = await prisma.benefitSlab.findMany({ take: 10 })
     * 
     * // Only select the `slabId`
     * const benefitSlabWithSlabIdOnly = await prisma.benefitSlab.findMany({ select: { slabId: true } })
     * 
     */
    findMany<T extends BenefitSlabFindManyArgs>(args?: SelectSubset<T, BenefitSlabFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BenefitSlab.
     * @param {BenefitSlabCreateArgs} args - Arguments to create a BenefitSlab.
     * @example
     * // Create one BenefitSlab
     * const BenefitSlab = await prisma.benefitSlab.create({
     *   data: {
     *     // ... data to create a BenefitSlab
     *   }
     * })
     * 
     */
    create<T extends BenefitSlabCreateArgs>(args: SelectSubset<T, BenefitSlabCreateArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BenefitSlabs.
     * @param {BenefitSlabCreateManyArgs} args - Arguments to create many BenefitSlabs.
     * @example
     * // Create many BenefitSlabs
     * const benefitSlab = await prisma.benefitSlab.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenefitSlabCreateManyArgs>(args?: SelectSubset<T, BenefitSlabCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BenefitSlabs and returns the data saved in the database.
     * @param {BenefitSlabCreateManyAndReturnArgs} args - Arguments to create many BenefitSlabs.
     * @example
     * // Create many BenefitSlabs
     * const benefitSlab = await prisma.benefitSlab.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BenefitSlabs and only return the `slabId`
     * const benefitSlabWithSlabIdOnly = await prisma.benefitSlab.createManyAndReturn({ 
     *   select: { slabId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BenefitSlabCreateManyAndReturnArgs>(args?: SelectSubset<T, BenefitSlabCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BenefitSlab.
     * @param {BenefitSlabDeleteArgs} args - Arguments to delete one BenefitSlab.
     * @example
     * // Delete one BenefitSlab
     * const BenefitSlab = await prisma.benefitSlab.delete({
     *   where: {
     *     // ... filter to delete one BenefitSlab
     *   }
     * })
     * 
     */
    delete<T extends BenefitSlabDeleteArgs>(args: SelectSubset<T, BenefitSlabDeleteArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BenefitSlab.
     * @param {BenefitSlabUpdateArgs} args - Arguments to update one BenefitSlab.
     * @example
     * // Update one BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenefitSlabUpdateArgs>(args: SelectSubset<T, BenefitSlabUpdateArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BenefitSlabs.
     * @param {BenefitSlabDeleteManyArgs} args - Arguments to filter BenefitSlabs to delete.
     * @example
     * // Delete a few BenefitSlabs
     * const { count } = await prisma.benefitSlab.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenefitSlabDeleteManyArgs>(args?: SelectSubset<T, BenefitSlabDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BenefitSlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BenefitSlabs
     * const benefitSlab = await prisma.benefitSlab.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenefitSlabUpdateManyArgs>(args: SelectSubset<T, BenefitSlabUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BenefitSlab.
     * @param {BenefitSlabUpsertArgs} args - Arguments to update or create a BenefitSlab.
     * @example
     * // Update or create a BenefitSlab
     * const benefitSlab = await prisma.benefitSlab.upsert({
     *   create: {
     *     // ... data to create a BenefitSlab
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BenefitSlab we want to update
     *   }
     * })
     */
    upsert<T extends BenefitSlabUpsertArgs>(args: SelectSubset<T, BenefitSlabUpsertArgs<ExtArgs>>): Prisma__BenefitSlabClient<$Result.GetResult<Prisma.$BenefitSlabPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BenefitSlabs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabCountArgs} args - Arguments to filter BenefitSlabs to count.
     * @example
     * // Count the number of BenefitSlabs
     * const count = await prisma.benefitSlab.count({
     *   where: {
     *     // ... the filter for the BenefitSlabs we want to count
     *   }
     * })
    **/
    count<T extends BenefitSlabCountArgs>(
      args?: Subset<T, BenefitSlabCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitSlabCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BenefitSlab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitSlabAggregateArgs>(args: Subset<T, BenefitSlabAggregateArgs>): Prisma.PrismaPromise<GetBenefitSlabAggregateType<T>>

    /**
     * Group by BenefitSlab.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitSlabGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenefitSlabGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenefitSlabGroupByArgs['orderBy'] }
        : { orderBy?: BenefitSlabGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenefitSlabGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefitSlabGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BenefitSlab model
   */
  readonly fields: BenefitSlabFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BenefitSlab.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenefitSlabClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BenefitSlab model
   */ 
  interface BenefitSlabFieldRefs {
    readonly slabId: FieldRef<"BenefitSlab", 'Int'>
    readonly tierName: FieldRef<"BenefitSlab", 'String'>
    readonly referralCount: FieldRef<"BenefitSlab", 'Int'>
    readonly yearFeeBenefitPercent: FieldRef<"BenefitSlab", 'Float'>
    readonly longTermExtraPercent: FieldRef<"BenefitSlab", 'Float'>
    readonly baseLongTermPercent: FieldRef<"BenefitSlab", 'Float'>
    readonly description: FieldRef<"BenefitSlab", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BenefitSlab findUnique
   */
  export type BenefitSlabFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter, which BenefitSlab to fetch.
     */
    where: BenefitSlabWhereUniqueInput
  }

  /**
   * BenefitSlab findUniqueOrThrow
   */
  export type BenefitSlabFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter, which BenefitSlab to fetch.
     */
    where: BenefitSlabWhereUniqueInput
  }

  /**
   * BenefitSlab findFirst
   */
  export type BenefitSlabFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter, which BenefitSlab to fetch.
     */
    where?: BenefitSlabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitSlabs to fetch.
     */
    orderBy?: BenefitSlabOrderByWithRelationInput | BenefitSlabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenefitSlabs.
     */
    cursor?: BenefitSlabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitSlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitSlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenefitSlabs.
     */
    distinct?: BenefitSlabScalarFieldEnum | BenefitSlabScalarFieldEnum[]
  }

  /**
   * BenefitSlab findFirstOrThrow
   */
  export type BenefitSlabFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter, which BenefitSlab to fetch.
     */
    where?: BenefitSlabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitSlabs to fetch.
     */
    orderBy?: BenefitSlabOrderByWithRelationInput | BenefitSlabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BenefitSlabs.
     */
    cursor?: BenefitSlabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitSlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitSlabs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BenefitSlabs.
     */
    distinct?: BenefitSlabScalarFieldEnum | BenefitSlabScalarFieldEnum[]
  }

  /**
   * BenefitSlab findMany
   */
  export type BenefitSlabFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter, which BenefitSlabs to fetch.
     */
    where?: BenefitSlabWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BenefitSlabs to fetch.
     */
    orderBy?: BenefitSlabOrderByWithRelationInput | BenefitSlabOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BenefitSlabs.
     */
    cursor?: BenefitSlabWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BenefitSlabs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BenefitSlabs.
     */
    skip?: number
    distinct?: BenefitSlabScalarFieldEnum | BenefitSlabScalarFieldEnum[]
  }

  /**
   * BenefitSlab create
   */
  export type BenefitSlabCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * The data needed to create a BenefitSlab.
     */
    data: XOR<BenefitSlabCreateInput, BenefitSlabUncheckedCreateInput>
  }

  /**
   * BenefitSlab createMany
   */
  export type BenefitSlabCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BenefitSlabs.
     */
    data: BenefitSlabCreateManyInput | BenefitSlabCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BenefitSlab createManyAndReturn
   */
  export type BenefitSlabCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BenefitSlabs.
     */
    data: BenefitSlabCreateManyInput | BenefitSlabCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BenefitSlab update
   */
  export type BenefitSlabUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * The data needed to update a BenefitSlab.
     */
    data: XOR<BenefitSlabUpdateInput, BenefitSlabUncheckedUpdateInput>
    /**
     * Choose, which BenefitSlab to update.
     */
    where: BenefitSlabWhereUniqueInput
  }

  /**
   * BenefitSlab updateMany
   */
  export type BenefitSlabUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BenefitSlabs.
     */
    data: XOR<BenefitSlabUpdateManyMutationInput, BenefitSlabUncheckedUpdateManyInput>
    /**
     * Filter which BenefitSlabs to update
     */
    where?: BenefitSlabWhereInput
  }

  /**
   * BenefitSlab upsert
   */
  export type BenefitSlabUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * The filter to search for the BenefitSlab to update in case it exists.
     */
    where: BenefitSlabWhereUniqueInput
    /**
     * In case the BenefitSlab found by the `where` argument doesn't exist, create a new BenefitSlab with this data.
     */
    create: XOR<BenefitSlabCreateInput, BenefitSlabUncheckedCreateInput>
    /**
     * In case the BenefitSlab was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenefitSlabUpdateInput, BenefitSlabUncheckedUpdateInput>
  }

  /**
   * BenefitSlab delete
   */
  export type BenefitSlabDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
    /**
     * Filter which BenefitSlab to delete.
     */
    where: BenefitSlabWhereUniqueInput
  }

  /**
   * BenefitSlab deleteMany
   */
  export type BenefitSlabDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BenefitSlabs to delete
     */
    where?: BenefitSlabWhereInput
  }

  /**
   * BenefitSlab without action
   */
  export type BenefitSlabDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BenefitSlab
     */
    select?: BenefitSlabSelect<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    adminId: number | null
  }

  export type AdminSumAggregateOutputType = {
    adminId: number | null
  }

  export type AdminMinAggregateOutputType = {
    adminId: number | null
    adminName: string | null
    adminMobile: string | null
    assignedCampus: string | null
    createdAt: Date | null
    profileImage: string | null
    email: string | null
    address: string | null
    password: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AccountStatus | null
  }

  export type AdminMaxAggregateOutputType = {
    adminId: number | null
    adminName: string | null
    adminMobile: string | null
    assignedCampus: string | null
    createdAt: Date | null
    profileImage: string | null
    email: string | null
    address: string | null
    password: string | null
    role: $Enums.AdminRole | null
    status: $Enums.AccountStatus | null
  }

  export type AdminCountAggregateOutputType = {
    adminId: number
    adminName: number
    adminMobile: number
    assignedCampus: number
    createdAt: number
    profileImage: number
    email: number
    address: number
    password: number
    role: number
    status: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    adminId?: true
  }

  export type AdminSumAggregateInputType = {
    adminId?: true
  }

  export type AdminMinAggregateInputType = {
    adminId?: true
    adminName?: true
    adminMobile?: true
    assignedCampus?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    password?: true
    role?: true
    status?: true
  }

  export type AdminMaxAggregateInputType = {
    adminId?: true
    adminName?: true
    adminMobile?: true
    assignedCampus?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    password?: true
    role?: true
    status?: true
  }

  export type AdminCountAggregateInputType = {
    adminId?: true
    adminName?: true
    adminMobile?: true
    assignedCampus?: true
    createdAt?: true
    profileImage?: true
    email?: true
    address?: true
    password?: true
    role?: true
    status?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    adminId: number
    adminName: string
    adminMobile: string
    assignedCampus: string | null
    createdAt: Date
    profileImage: string | null
    email: string | null
    address: string | null
    password: string | null
    role: $Enums.AdminRole
    status: $Enums.AccountStatus
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    adminId?: boolean
    adminName?: boolean
    adminMobile?: boolean
    assignedCampus?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    notifications?: boolean | Admin$notificationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    adminId?: boolean
    adminName?: boolean
    adminMobile?: boolean
    assignedCampus?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    adminId?: boolean
    adminName?: boolean
    adminMobile?: boolean
    assignedCampus?: boolean
    createdAt?: boolean
    profileImage?: boolean
    email?: boolean
    address?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | Admin$notificationsArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      adminId: number
      adminName: string
      adminMobile: string
      assignedCampus: string | null
      createdAt: Date
      profileImage: string | null
      email: string | null
      address: string | null
      password: string | null
      role: $Enums.AdminRole
      status: $Enums.AccountStatus
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `adminId`
     * const adminWithAdminIdOnly = await prisma.admin.findMany({ select: { adminId: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `adminId`
     * const adminWithAdminIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { adminId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends Admin$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly adminId: FieldRef<"Admin", 'Int'>
    readonly adminName: FieldRef<"Admin", 'String'>
    readonly adminMobile: FieldRef<"Admin", 'String'>
    readonly assignedCampus: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly profileImage: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly address: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'AdminRole'>
    readonly status: FieldRef<"Admin", 'AccountStatus'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin.notifications
   */
  export type Admin$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsAvgAggregateOutputType = {
    id: number | null
    defaultStudentFee: number | null
  }

  export type SystemSettingsSumAggregateOutputType = {
    id: number | null
    defaultStudentFee: number | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: number | null
    allowNewRegistrations: boolean | null
    defaultStudentFee: number | null
    maintenanceMode: boolean | null
    staffReferralText: string | null
    parentReferralText: string | null
    staffWelcomeMessage: string | null
    parentWelcomeMessage: string | null
    updatedAt: Date | null
    updatedBy: string | null
    alumniReferralText: string | null
    alumniWelcomeMessage: string | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: number | null
    allowNewRegistrations: boolean | null
    defaultStudentFee: number | null
    maintenanceMode: boolean | null
    staffReferralText: string | null
    parentReferralText: string | null
    staffWelcomeMessage: string | null
    parentWelcomeMessage: string | null
    updatedAt: Date | null
    updatedBy: string | null
    alumniReferralText: string | null
    alumniWelcomeMessage: string | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    allowNewRegistrations: number
    defaultStudentFee: number
    maintenanceMode: number
    staffReferralText: number
    parentReferralText: number
    staffWelcomeMessage: number
    parentWelcomeMessage: number
    updatedAt: number
    updatedBy: number
    alumniReferralText: number
    alumniWelcomeMessage: number
    _all: number
  }


  export type SystemSettingsAvgAggregateInputType = {
    id?: true
    defaultStudentFee?: true
  }

  export type SystemSettingsSumAggregateInputType = {
    id?: true
    defaultStudentFee?: true
  }

  export type SystemSettingsMinAggregateInputType = {
    id?: true
    allowNewRegistrations?: true
    defaultStudentFee?: true
    maintenanceMode?: true
    staffReferralText?: true
    parentReferralText?: true
    staffWelcomeMessage?: true
    parentWelcomeMessage?: true
    updatedAt?: true
    updatedBy?: true
    alumniReferralText?: true
    alumniWelcomeMessage?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    allowNewRegistrations?: true
    defaultStudentFee?: true
    maintenanceMode?: true
    staffReferralText?: true
    parentReferralText?: true
    staffWelcomeMessage?: true
    parentWelcomeMessage?: true
    updatedAt?: true
    updatedBy?: true
    alumniReferralText?: true
    alumniWelcomeMessage?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    allowNewRegistrations?: true
    defaultStudentFee?: true
    maintenanceMode?: true
    staffReferralText?: true
    parentReferralText?: true
    staffWelcomeMessage?: true
    parentWelcomeMessage?: true
    updatedAt?: true
    updatedBy?: true
    alumniReferralText?: true
    alumniWelcomeMessage?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _avg?: SystemSettingsAvgAggregateInputType
    _sum?: SystemSettingsSumAggregateInputType
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: number
    allowNewRegistrations: boolean
    defaultStudentFee: number
    maintenanceMode: boolean
    staffReferralText: string | null
    parentReferralText: string | null
    staffWelcomeMessage: string | null
    parentWelcomeMessage: string | null
    updatedAt: Date
    updatedBy: string | null
    alumniReferralText: string | null
    alumniWelcomeMessage: string | null
    _count: SystemSettingsCountAggregateOutputType | null
    _avg: SystemSettingsAvgAggregateOutputType | null
    _sum: SystemSettingsSumAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    allowNewRegistrations?: boolean
    defaultStudentFee?: boolean
    maintenanceMode?: boolean
    staffReferralText?: boolean
    parentReferralText?: boolean
    staffWelcomeMessage?: boolean
    parentWelcomeMessage?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    alumniReferralText?: boolean
    alumniWelcomeMessage?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    allowNewRegistrations?: boolean
    defaultStudentFee?: boolean
    maintenanceMode?: boolean
    staffReferralText?: boolean
    parentReferralText?: boolean
    staffWelcomeMessage?: boolean
    parentWelcomeMessage?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    alumniReferralText?: boolean
    alumniWelcomeMessage?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    allowNewRegistrations?: boolean
    defaultStudentFee?: boolean
    maintenanceMode?: boolean
    staffReferralText?: boolean
    parentReferralText?: boolean
    staffWelcomeMessage?: boolean
    parentWelcomeMessage?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    alumniReferralText?: boolean
    alumniWelcomeMessage?: boolean
  }


  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      allowNewRegistrations: boolean
      defaultStudentFee: number
      maintenanceMode: boolean
      staffReferralText: string | null
      parentReferralText: string | null
      staffWelcomeMessage: string | null
      parentWelcomeMessage: string | null
      updatedAt: Date
      updatedBy: string | null
      alumniReferralText: string | null
      alumniWelcomeMessage: string | null
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */ 
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'Int'>
    readonly allowNewRegistrations: FieldRef<"SystemSettings", 'Boolean'>
    readonly defaultStudentFee: FieldRef<"SystemSettings", 'Int'>
    readonly maintenanceMode: FieldRef<"SystemSettings", 'Boolean'>
    readonly staffReferralText: FieldRef<"SystemSettings", 'String'>
    readonly parentReferralText: FieldRef<"SystemSettings", 'String'>
    readonly staffWelcomeMessage: FieldRef<"SystemSettings", 'String'>
    readonly parentWelcomeMessage: FieldRef<"SystemSettings", 'String'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"SystemSettings", 'String'>
    readonly alumniReferralText: FieldRef<"SystemSettings", 'String'>
    readonly alumniWelcomeMessage: FieldRef<"SystemSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
  }


  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearAvgAggregateOutputType = {
    id: number | null
  }

  export type AcademicYearSumAggregateOutputType = {
    id: number | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: number | null
    year: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: number | null
    year: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isCurrent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    year: number
    startDate: number
    endDate: number
    isActive: number
    isCurrent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AcademicYearAvgAggregateInputType = {
    id?: true
  }

  export type AcademicYearSumAggregateInputType = {
    id?: true
  }

  export type AcademicYearMinAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    year?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isCurrent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _avg?: AcademicYearAvgAggregateInputType
    _sum?: AcademicYearSumAggregateInputType
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: number
    year: string
    startDate: Date
    endDate: Date
    isActive: boolean
    isCurrent: boolean
    createdAt: Date
    updatedAt: Date
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    year?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      year: string
      startDate: Date
      endDate: Date
      isActive: boolean
      isCurrent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */ 
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'Int'>
    readonly year: FieldRef<"AcademicYear", 'String'>
    readonly startDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly endDate: FieldRef<"AcademicYear", 'DateTime'>
    readonly isActive: FieldRef<"AcademicYear", 'Boolean'>
    readonly isCurrent: FieldRef<"AcademicYear", 'Boolean'>
    readonly createdAt: FieldRef<"AcademicYear", 'DateTime'>
    readonly updatedAt: FieldRef<"AcademicYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
  }


  /**
   * Model LeadManagementSettings
   */

  export type AggregateLeadManagementSettings = {
    _count: LeadManagementSettingsCountAggregateOutputType | null
    _avg: LeadManagementSettingsAvgAggregateOutputType | null
    _sum: LeadManagementSettingsSumAggregateOutputType | null
    _min: LeadManagementSettingsMinAggregateOutputType | null
    _max: LeadManagementSettingsMaxAggregateOutputType | null
  }

  export type LeadManagementSettingsAvgAggregateOutputType = {
    id: number | null
    leadStaleDays: number | null
    followupEscalationDays: number | null
  }

  export type LeadManagementSettingsSumAggregateOutputType = {
    id: number | null
    leadStaleDays: number | null
    followupEscalationDays: number | null
  }

  export type LeadManagementSettingsMinAggregateOutputType = {
    id: number | null
    autoAssignLeads: boolean | null
    leadStaleDays: number | null
    followupEscalationDays: number | null
    duplicateDetectionEnabled: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type LeadManagementSettingsMaxAggregateOutputType = {
    id: number | null
    autoAssignLeads: boolean | null
    leadStaleDays: number | null
    followupEscalationDays: number | null
    duplicateDetectionEnabled: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type LeadManagementSettingsCountAggregateOutputType = {
    id: number
    autoAssignLeads: number
    leadStaleDays: number
    followupEscalationDays: number
    duplicateDetectionEnabled: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type LeadManagementSettingsAvgAggregateInputType = {
    id?: true
    leadStaleDays?: true
    followupEscalationDays?: true
  }

  export type LeadManagementSettingsSumAggregateInputType = {
    id?: true
    leadStaleDays?: true
    followupEscalationDays?: true
  }

  export type LeadManagementSettingsMinAggregateInputType = {
    id?: true
    autoAssignLeads?: true
    leadStaleDays?: true
    followupEscalationDays?: true
    duplicateDetectionEnabled?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type LeadManagementSettingsMaxAggregateInputType = {
    id?: true
    autoAssignLeads?: true
    leadStaleDays?: true
    followupEscalationDays?: true
    duplicateDetectionEnabled?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type LeadManagementSettingsCountAggregateInputType = {
    id?: true
    autoAssignLeads?: true
    leadStaleDays?: true
    followupEscalationDays?: true
    duplicateDetectionEnabled?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type LeadManagementSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadManagementSettings to aggregate.
     */
    where?: LeadManagementSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadManagementSettings to fetch.
     */
    orderBy?: LeadManagementSettingsOrderByWithRelationInput | LeadManagementSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadManagementSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadManagementSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadManagementSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeadManagementSettings
    **/
    _count?: true | LeadManagementSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadManagementSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadManagementSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadManagementSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadManagementSettingsMaxAggregateInputType
  }

  export type GetLeadManagementSettingsAggregateType<T extends LeadManagementSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLeadManagementSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeadManagementSettings[P]>
      : GetScalarType<T[P], AggregateLeadManagementSettings[P]>
  }




  export type LeadManagementSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadManagementSettingsWhereInput
    orderBy?: LeadManagementSettingsOrderByWithAggregationInput | LeadManagementSettingsOrderByWithAggregationInput[]
    by: LeadManagementSettingsScalarFieldEnum[] | LeadManagementSettingsScalarFieldEnum
    having?: LeadManagementSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadManagementSettingsCountAggregateInputType | true
    _avg?: LeadManagementSettingsAvgAggregateInputType
    _sum?: LeadManagementSettingsSumAggregateInputType
    _min?: LeadManagementSettingsMinAggregateInputType
    _max?: LeadManagementSettingsMaxAggregateInputType
  }

  export type LeadManagementSettingsGroupByOutputType = {
    id: number
    autoAssignLeads: boolean
    leadStaleDays: number
    followupEscalationDays: number
    duplicateDetectionEnabled: boolean
    updatedAt: Date
    updatedBy: string | null
    _count: LeadManagementSettingsCountAggregateOutputType | null
    _avg: LeadManagementSettingsAvgAggregateOutputType | null
    _sum: LeadManagementSettingsSumAggregateOutputType | null
    _min: LeadManagementSettingsMinAggregateOutputType | null
    _max: LeadManagementSettingsMaxAggregateOutputType | null
  }

  type GetLeadManagementSettingsGroupByPayload<T extends LeadManagementSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadManagementSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadManagementSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadManagementSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], LeadManagementSettingsGroupByOutputType[P]>
        }
      >
    >


  export type LeadManagementSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autoAssignLeads?: boolean
    leadStaleDays?: boolean
    followupEscalationDays?: boolean
    duplicateDetectionEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["leadManagementSettings"]>

  export type LeadManagementSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    autoAssignLeads?: boolean
    leadStaleDays?: boolean
    followupEscalationDays?: boolean
    duplicateDetectionEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["leadManagementSettings"]>

  export type LeadManagementSettingsSelectScalar = {
    id?: boolean
    autoAssignLeads?: boolean
    leadStaleDays?: boolean
    followupEscalationDays?: boolean
    duplicateDetectionEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $LeadManagementSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeadManagementSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      autoAssignLeads: boolean
      leadStaleDays: number
      followupEscalationDays: number
      duplicateDetectionEnabled: boolean
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["leadManagementSettings"]>
    composites: {}
  }

  type LeadManagementSettingsGetPayload<S extends boolean | null | undefined | LeadManagementSettingsDefaultArgs> = $Result.GetResult<Prisma.$LeadManagementSettingsPayload, S>

  type LeadManagementSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadManagementSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadManagementSettingsCountAggregateInputType | true
    }

  export interface LeadManagementSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeadManagementSettings'], meta: { name: 'LeadManagementSettings' } }
    /**
     * Find zero or one LeadManagementSettings that matches the filter.
     * @param {LeadManagementSettingsFindUniqueArgs} args - Arguments to find a LeadManagementSettings
     * @example
     * // Get one LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadManagementSettingsFindUniqueArgs>(args: SelectSubset<T, LeadManagementSettingsFindUniqueArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeadManagementSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadManagementSettingsFindUniqueOrThrowArgs} args - Arguments to find a LeadManagementSettings
     * @example
     * // Get one LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadManagementSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadManagementSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeadManagementSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsFindFirstArgs} args - Arguments to find a LeadManagementSettings
     * @example
     * // Get one LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadManagementSettingsFindFirstArgs>(args?: SelectSubset<T, LeadManagementSettingsFindFirstArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeadManagementSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsFindFirstOrThrowArgs} args - Arguments to find a LeadManagementSettings
     * @example
     * // Get one LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadManagementSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadManagementSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeadManagementSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findMany()
     * 
     * // Get first 10 LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadManagementSettingsWithIdOnly = await prisma.leadManagementSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadManagementSettingsFindManyArgs>(args?: SelectSubset<T, LeadManagementSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeadManagementSettings.
     * @param {LeadManagementSettingsCreateArgs} args - Arguments to create a LeadManagementSettings.
     * @example
     * // Create one LeadManagementSettings
     * const LeadManagementSettings = await prisma.leadManagementSettings.create({
     *   data: {
     *     // ... data to create a LeadManagementSettings
     *   }
     * })
     * 
     */
    create<T extends LeadManagementSettingsCreateArgs>(args: SelectSubset<T, LeadManagementSettingsCreateArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeadManagementSettings.
     * @param {LeadManagementSettingsCreateManyArgs} args - Arguments to create many LeadManagementSettings.
     * @example
     * // Create many LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadManagementSettingsCreateManyArgs>(args?: SelectSubset<T, LeadManagementSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeadManagementSettings and returns the data saved in the database.
     * @param {LeadManagementSettingsCreateManyAndReturnArgs} args - Arguments to create many LeadManagementSettings.
     * @example
     * // Create many LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeadManagementSettings and only return the `id`
     * const leadManagementSettingsWithIdOnly = await prisma.leadManagementSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadManagementSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadManagementSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeadManagementSettings.
     * @param {LeadManagementSettingsDeleteArgs} args - Arguments to delete one LeadManagementSettings.
     * @example
     * // Delete one LeadManagementSettings
     * const LeadManagementSettings = await prisma.leadManagementSettings.delete({
     *   where: {
     *     // ... filter to delete one LeadManagementSettings
     *   }
     * })
     * 
     */
    delete<T extends LeadManagementSettingsDeleteArgs>(args: SelectSubset<T, LeadManagementSettingsDeleteArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeadManagementSettings.
     * @param {LeadManagementSettingsUpdateArgs} args - Arguments to update one LeadManagementSettings.
     * @example
     * // Update one LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadManagementSettingsUpdateArgs>(args: SelectSubset<T, LeadManagementSettingsUpdateArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeadManagementSettings.
     * @param {LeadManagementSettingsDeleteManyArgs} args - Arguments to filter LeadManagementSettings to delete.
     * @example
     * // Delete a few LeadManagementSettings
     * const { count } = await prisma.leadManagementSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadManagementSettingsDeleteManyArgs>(args?: SelectSubset<T, LeadManagementSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeadManagementSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadManagementSettingsUpdateManyArgs>(args: SelectSubset<T, LeadManagementSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeadManagementSettings.
     * @param {LeadManagementSettingsUpsertArgs} args - Arguments to update or create a LeadManagementSettings.
     * @example
     * // Update or create a LeadManagementSettings
     * const leadManagementSettings = await prisma.leadManagementSettings.upsert({
     *   create: {
     *     // ... data to create a LeadManagementSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeadManagementSettings we want to update
     *   }
     * })
     */
    upsert<T extends LeadManagementSettingsUpsertArgs>(args: SelectSubset<T, LeadManagementSettingsUpsertArgs<ExtArgs>>): Prisma__LeadManagementSettingsClient<$Result.GetResult<Prisma.$LeadManagementSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeadManagementSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsCountArgs} args - Arguments to filter LeadManagementSettings to count.
     * @example
     * // Count the number of LeadManagementSettings
     * const count = await prisma.leadManagementSettings.count({
     *   where: {
     *     // ... the filter for the LeadManagementSettings we want to count
     *   }
     * })
    **/
    count<T extends LeadManagementSettingsCountArgs>(
      args?: Subset<T, LeadManagementSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadManagementSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeadManagementSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadManagementSettingsAggregateArgs>(args: Subset<T, LeadManagementSettingsAggregateArgs>): Prisma.PrismaPromise<GetLeadManagementSettingsAggregateType<T>>

    /**
     * Group by LeadManagementSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadManagementSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadManagementSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadManagementSettingsGroupByArgs['orderBy'] }
        : { orderBy?: LeadManagementSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadManagementSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadManagementSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeadManagementSettings model
   */
  readonly fields: LeadManagementSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeadManagementSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadManagementSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeadManagementSettings model
   */ 
  interface LeadManagementSettingsFieldRefs {
    readonly id: FieldRef<"LeadManagementSettings", 'Int'>
    readonly autoAssignLeads: FieldRef<"LeadManagementSettings", 'Boolean'>
    readonly leadStaleDays: FieldRef<"LeadManagementSettings", 'Int'>
    readonly followupEscalationDays: FieldRef<"LeadManagementSettings", 'Int'>
    readonly duplicateDetectionEnabled: FieldRef<"LeadManagementSettings", 'Boolean'>
    readonly updatedAt: FieldRef<"LeadManagementSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"LeadManagementSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LeadManagementSettings findUnique
   */
  export type LeadManagementSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter, which LeadManagementSettings to fetch.
     */
    where: LeadManagementSettingsWhereUniqueInput
  }

  /**
   * LeadManagementSettings findUniqueOrThrow
   */
  export type LeadManagementSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter, which LeadManagementSettings to fetch.
     */
    where: LeadManagementSettingsWhereUniqueInput
  }

  /**
   * LeadManagementSettings findFirst
   */
  export type LeadManagementSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter, which LeadManagementSettings to fetch.
     */
    where?: LeadManagementSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadManagementSettings to fetch.
     */
    orderBy?: LeadManagementSettingsOrderByWithRelationInput | LeadManagementSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadManagementSettings.
     */
    cursor?: LeadManagementSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadManagementSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadManagementSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadManagementSettings.
     */
    distinct?: LeadManagementSettingsScalarFieldEnum | LeadManagementSettingsScalarFieldEnum[]
  }

  /**
   * LeadManagementSettings findFirstOrThrow
   */
  export type LeadManagementSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter, which LeadManagementSettings to fetch.
     */
    where?: LeadManagementSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadManagementSettings to fetch.
     */
    orderBy?: LeadManagementSettingsOrderByWithRelationInput | LeadManagementSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeadManagementSettings.
     */
    cursor?: LeadManagementSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadManagementSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadManagementSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeadManagementSettings.
     */
    distinct?: LeadManagementSettingsScalarFieldEnum | LeadManagementSettingsScalarFieldEnum[]
  }

  /**
   * LeadManagementSettings findMany
   */
  export type LeadManagementSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter, which LeadManagementSettings to fetch.
     */
    where?: LeadManagementSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeadManagementSettings to fetch.
     */
    orderBy?: LeadManagementSettingsOrderByWithRelationInput | LeadManagementSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeadManagementSettings.
     */
    cursor?: LeadManagementSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeadManagementSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeadManagementSettings.
     */
    skip?: number
    distinct?: LeadManagementSettingsScalarFieldEnum | LeadManagementSettingsScalarFieldEnum[]
  }

  /**
   * LeadManagementSettings create
   */
  export type LeadManagementSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a LeadManagementSettings.
     */
    data: XOR<LeadManagementSettingsCreateInput, LeadManagementSettingsUncheckedCreateInput>
  }

  /**
   * LeadManagementSettings createMany
   */
  export type LeadManagementSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeadManagementSettings.
     */
    data: LeadManagementSettingsCreateManyInput | LeadManagementSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadManagementSettings createManyAndReturn
   */
  export type LeadManagementSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeadManagementSettings.
     */
    data: LeadManagementSettingsCreateManyInput | LeadManagementSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeadManagementSettings update
   */
  export type LeadManagementSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a LeadManagementSettings.
     */
    data: XOR<LeadManagementSettingsUpdateInput, LeadManagementSettingsUncheckedUpdateInput>
    /**
     * Choose, which LeadManagementSettings to update.
     */
    where: LeadManagementSettingsWhereUniqueInput
  }

  /**
   * LeadManagementSettings updateMany
   */
  export type LeadManagementSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeadManagementSettings.
     */
    data: XOR<LeadManagementSettingsUpdateManyMutationInput, LeadManagementSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LeadManagementSettings to update
     */
    where?: LeadManagementSettingsWhereInput
  }

  /**
   * LeadManagementSettings upsert
   */
  export type LeadManagementSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the LeadManagementSettings to update in case it exists.
     */
    where: LeadManagementSettingsWhereUniqueInput
    /**
     * In case the LeadManagementSettings found by the `where` argument doesn't exist, create a new LeadManagementSettings with this data.
     */
    create: XOR<LeadManagementSettingsCreateInput, LeadManagementSettingsUncheckedCreateInput>
    /**
     * In case the LeadManagementSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadManagementSettingsUpdateInput, LeadManagementSettingsUncheckedUpdateInput>
  }

  /**
   * LeadManagementSettings delete
   */
  export type LeadManagementSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
    /**
     * Filter which LeadManagementSettings to delete.
     */
    where: LeadManagementSettingsWhereUniqueInput
  }

  /**
   * LeadManagementSettings deleteMany
   */
  export type LeadManagementSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeadManagementSettings to delete
     */
    where?: LeadManagementSettingsWhereInput
  }

  /**
   * LeadManagementSettings without action
   */
  export type LeadManagementSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadManagementSettings
     */
    select?: LeadManagementSettingsSelect<ExtArgs> | null
  }


  /**
   * Model SecuritySettings
   */

  export type AggregateSecuritySettings = {
    _count: SecuritySettingsCountAggregateOutputType | null
    _avg: SecuritySettingsAvgAggregateOutputType | null
    _sum: SecuritySettingsSumAggregateOutputType | null
    _min: SecuritySettingsMinAggregateOutputType | null
    _max: SecuritySettingsMaxAggregateOutputType | null
  }

  export type SecuritySettingsAvgAggregateOutputType = {
    id: number | null
    sessionTimeoutMinutes: number | null
    maxLoginAttempts: number | null
    passwordResetExpiryHours: number | null
  }

  export type SecuritySettingsSumAggregateOutputType = {
    id: number | null
    sessionTimeoutMinutes: number | null
    maxLoginAttempts: number | null
    passwordResetExpiryHours: number | null
  }

  export type SecuritySettingsMinAggregateOutputType = {
    id: number | null
    sessionTimeoutMinutes: number | null
    maxLoginAttempts: number | null
    passwordResetExpiryHours: number | null
    twoFactorAuthEnabled: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
    ipWhitelist: string | null
  }

  export type SecuritySettingsMaxAggregateOutputType = {
    id: number | null
    sessionTimeoutMinutes: number | null
    maxLoginAttempts: number | null
    passwordResetExpiryHours: number | null
    twoFactorAuthEnabled: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
    ipWhitelist: string | null
  }

  export type SecuritySettingsCountAggregateOutputType = {
    id: number
    sessionTimeoutMinutes: number
    maxLoginAttempts: number
    passwordResetExpiryHours: number
    twoFactorAuthEnabled: number
    updatedAt: number
    updatedBy: number
    ipWhitelist: number
    _all: number
  }


  export type SecuritySettingsAvgAggregateInputType = {
    id?: true
    sessionTimeoutMinutes?: true
    maxLoginAttempts?: true
    passwordResetExpiryHours?: true
  }

  export type SecuritySettingsSumAggregateInputType = {
    id?: true
    sessionTimeoutMinutes?: true
    maxLoginAttempts?: true
    passwordResetExpiryHours?: true
  }

  export type SecuritySettingsMinAggregateInputType = {
    id?: true
    sessionTimeoutMinutes?: true
    maxLoginAttempts?: true
    passwordResetExpiryHours?: true
    twoFactorAuthEnabled?: true
    updatedAt?: true
    updatedBy?: true
    ipWhitelist?: true
  }

  export type SecuritySettingsMaxAggregateInputType = {
    id?: true
    sessionTimeoutMinutes?: true
    maxLoginAttempts?: true
    passwordResetExpiryHours?: true
    twoFactorAuthEnabled?: true
    updatedAt?: true
    updatedBy?: true
    ipWhitelist?: true
  }

  export type SecuritySettingsCountAggregateInputType = {
    id?: true
    sessionTimeoutMinutes?: true
    maxLoginAttempts?: true
    passwordResetExpiryHours?: true
    twoFactorAuthEnabled?: true
    updatedAt?: true
    updatedBy?: true
    ipWhitelist?: true
    _all?: true
  }

  export type SecuritySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecuritySettings to aggregate.
     */
    where?: SecuritySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySettings to fetch.
     */
    orderBy?: SecuritySettingsOrderByWithRelationInput | SecuritySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SecuritySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SecuritySettings
    **/
    _count?: true | SecuritySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SecuritySettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SecuritySettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SecuritySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SecuritySettingsMaxAggregateInputType
  }

  export type GetSecuritySettingsAggregateType<T extends SecuritySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSecuritySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecuritySettings[P]>
      : GetScalarType<T[P], AggregateSecuritySettings[P]>
  }




  export type SecuritySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecuritySettingsWhereInput
    orderBy?: SecuritySettingsOrderByWithAggregationInput | SecuritySettingsOrderByWithAggregationInput[]
    by: SecuritySettingsScalarFieldEnum[] | SecuritySettingsScalarFieldEnum
    having?: SecuritySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecuritySettingsCountAggregateInputType | true
    _avg?: SecuritySettingsAvgAggregateInputType
    _sum?: SecuritySettingsSumAggregateInputType
    _min?: SecuritySettingsMinAggregateInputType
    _max?: SecuritySettingsMaxAggregateInputType
  }

  export type SecuritySettingsGroupByOutputType = {
    id: number
    sessionTimeoutMinutes: number
    maxLoginAttempts: number
    passwordResetExpiryHours: number
    twoFactorAuthEnabled: boolean
    updatedAt: Date
    updatedBy: string | null
    ipWhitelist: string | null
    _count: SecuritySettingsCountAggregateOutputType | null
    _avg: SecuritySettingsAvgAggregateOutputType | null
    _sum: SecuritySettingsSumAggregateOutputType | null
    _min: SecuritySettingsMinAggregateOutputType | null
    _max: SecuritySettingsMaxAggregateOutputType | null
  }

  type GetSecuritySettingsGroupByPayload<T extends SecuritySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecuritySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecuritySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecuritySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SecuritySettingsGroupByOutputType[P]>
        }
      >
    >


  export type SecuritySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionTimeoutMinutes?: boolean
    maxLoginAttempts?: boolean
    passwordResetExpiryHours?: boolean
    twoFactorAuthEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ipWhitelist?: boolean
  }, ExtArgs["result"]["securitySettings"]>

  export type SecuritySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionTimeoutMinutes?: boolean
    maxLoginAttempts?: boolean
    passwordResetExpiryHours?: boolean
    twoFactorAuthEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ipWhitelist?: boolean
  }, ExtArgs["result"]["securitySettings"]>

  export type SecuritySettingsSelectScalar = {
    id?: boolean
    sessionTimeoutMinutes?: boolean
    maxLoginAttempts?: boolean
    passwordResetExpiryHours?: boolean
    twoFactorAuthEnabled?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    ipWhitelist?: boolean
  }


  export type $SecuritySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecuritySettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionTimeoutMinutes: number
      maxLoginAttempts: number
      passwordResetExpiryHours: number
      twoFactorAuthEnabled: boolean
      updatedAt: Date
      updatedBy: string | null
      ipWhitelist: string | null
    }, ExtArgs["result"]["securitySettings"]>
    composites: {}
  }

  type SecuritySettingsGetPayload<S extends boolean | null | undefined | SecuritySettingsDefaultArgs> = $Result.GetResult<Prisma.$SecuritySettingsPayload, S>

  type SecuritySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SecuritySettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SecuritySettingsCountAggregateInputType | true
    }

  export interface SecuritySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecuritySettings'], meta: { name: 'SecuritySettings' } }
    /**
     * Find zero or one SecuritySettings that matches the filter.
     * @param {SecuritySettingsFindUniqueArgs} args - Arguments to find a SecuritySettings
     * @example
     * // Get one SecuritySettings
     * const securitySettings = await prisma.securitySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecuritySettingsFindUniqueArgs>(args: SelectSubset<T, SecuritySettingsFindUniqueArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SecuritySettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SecuritySettingsFindUniqueOrThrowArgs} args - Arguments to find a SecuritySettings
     * @example
     * // Get one SecuritySettings
     * const securitySettings = await prisma.securitySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecuritySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SecuritySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SecuritySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsFindFirstArgs} args - Arguments to find a SecuritySettings
     * @example
     * // Get one SecuritySettings
     * const securitySettings = await prisma.securitySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecuritySettingsFindFirstArgs>(args?: SelectSubset<T, SecuritySettingsFindFirstArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SecuritySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsFindFirstOrThrowArgs} args - Arguments to find a SecuritySettings
     * @example
     * // Get one SecuritySettings
     * const securitySettings = await prisma.securitySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecuritySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SecuritySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SecuritySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecuritySettings
     * const securitySettings = await prisma.securitySettings.findMany()
     * 
     * // Get first 10 SecuritySettings
     * const securitySettings = await prisma.securitySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const securitySettingsWithIdOnly = await prisma.securitySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SecuritySettingsFindManyArgs>(args?: SelectSubset<T, SecuritySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SecuritySettings.
     * @param {SecuritySettingsCreateArgs} args - Arguments to create a SecuritySettings.
     * @example
     * // Create one SecuritySettings
     * const SecuritySettings = await prisma.securitySettings.create({
     *   data: {
     *     // ... data to create a SecuritySettings
     *   }
     * })
     * 
     */
    create<T extends SecuritySettingsCreateArgs>(args: SelectSubset<T, SecuritySettingsCreateArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SecuritySettings.
     * @param {SecuritySettingsCreateManyArgs} args - Arguments to create many SecuritySettings.
     * @example
     * // Create many SecuritySettings
     * const securitySettings = await prisma.securitySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SecuritySettingsCreateManyArgs>(args?: SelectSubset<T, SecuritySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecuritySettings and returns the data saved in the database.
     * @param {SecuritySettingsCreateManyAndReturnArgs} args - Arguments to create many SecuritySettings.
     * @example
     * // Create many SecuritySettings
     * const securitySettings = await prisma.securitySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SecuritySettings and only return the `id`
     * const securitySettingsWithIdOnly = await prisma.securitySettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SecuritySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SecuritySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SecuritySettings.
     * @param {SecuritySettingsDeleteArgs} args - Arguments to delete one SecuritySettings.
     * @example
     * // Delete one SecuritySettings
     * const SecuritySettings = await prisma.securitySettings.delete({
     *   where: {
     *     // ... filter to delete one SecuritySettings
     *   }
     * })
     * 
     */
    delete<T extends SecuritySettingsDeleteArgs>(args: SelectSubset<T, SecuritySettingsDeleteArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SecuritySettings.
     * @param {SecuritySettingsUpdateArgs} args - Arguments to update one SecuritySettings.
     * @example
     * // Update one SecuritySettings
     * const securitySettings = await prisma.securitySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SecuritySettingsUpdateArgs>(args: SelectSubset<T, SecuritySettingsUpdateArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SecuritySettings.
     * @param {SecuritySettingsDeleteManyArgs} args - Arguments to filter SecuritySettings to delete.
     * @example
     * // Delete a few SecuritySettings
     * const { count } = await prisma.securitySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SecuritySettingsDeleteManyArgs>(args?: SelectSubset<T, SecuritySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecuritySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecuritySettings
     * const securitySettings = await prisma.securitySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SecuritySettingsUpdateManyArgs>(args: SelectSubset<T, SecuritySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SecuritySettings.
     * @param {SecuritySettingsUpsertArgs} args - Arguments to update or create a SecuritySettings.
     * @example
     * // Update or create a SecuritySettings
     * const securitySettings = await prisma.securitySettings.upsert({
     *   create: {
     *     // ... data to create a SecuritySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecuritySettings we want to update
     *   }
     * })
     */
    upsert<T extends SecuritySettingsUpsertArgs>(args: SelectSubset<T, SecuritySettingsUpsertArgs<ExtArgs>>): Prisma__SecuritySettingsClient<$Result.GetResult<Prisma.$SecuritySettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SecuritySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsCountArgs} args - Arguments to filter SecuritySettings to count.
     * @example
     * // Count the number of SecuritySettings
     * const count = await prisma.securitySettings.count({
     *   where: {
     *     // ... the filter for the SecuritySettings we want to count
     *   }
     * })
    **/
    count<T extends SecuritySettingsCountArgs>(
      args?: Subset<T, SecuritySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecuritySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecuritySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecuritySettingsAggregateArgs>(args: Subset<T, SecuritySettingsAggregateArgs>): Prisma.PrismaPromise<GetSecuritySettingsAggregateType<T>>

    /**
     * Group by SecuritySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecuritySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SecuritySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecuritySettingsGroupByArgs['orderBy'] }
        : { orderBy?: SecuritySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecuritySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecuritySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecuritySettings model
   */
  readonly fields: SecuritySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecuritySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecuritySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecuritySettings model
   */ 
  interface SecuritySettingsFieldRefs {
    readonly id: FieldRef<"SecuritySettings", 'Int'>
    readonly sessionTimeoutMinutes: FieldRef<"SecuritySettings", 'Int'>
    readonly maxLoginAttempts: FieldRef<"SecuritySettings", 'Int'>
    readonly passwordResetExpiryHours: FieldRef<"SecuritySettings", 'Int'>
    readonly twoFactorAuthEnabled: FieldRef<"SecuritySettings", 'Boolean'>
    readonly updatedAt: FieldRef<"SecuritySettings", 'DateTime'>
    readonly updatedBy: FieldRef<"SecuritySettings", 'String'>
    readonly ipWhitelist: FieldRef<"SecuritySettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SecuritySettings findUnique
   */
  export type SecuritySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter, which SecuritySettings to fetch.
     */
    where: SecuritySettingsWhereUniqueInput
  }

  /**
   * SecuritySettings findUniqueOrThrow
   */
  export type SecuritySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter, which SecuritySettings to fetch.
     */
    where: SecuritySettingsWhereUniqueInput
  }

  /**
   * SecuritySettings findFirst
   */
  export type SecuritySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter, which SecuritySettings to fetch.
     */
    where?: SecuritySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySettings to fetch.
     */
    orderBy?: SecuritySettingsOrderByWithRelationInput | SecuritySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecuritySettings.
     */
    cursor?: SecuritySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecuritySettings.
     */
    distinct?: SecuritySettingsScalarFieldEnum | SecuritySettingsScalarFieldEnum[]
  }

  /**
   * SecuritySettings findFirstOrThrow
   */
  export type SecuritySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter, which SecuritySettings to fetch.
     */
    where?: SecuritySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySettings to fetch.
     */
    orderBy?: SecuritySettingsOrderByWithRelationInput | SecuritySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SecuritySettings.
     */
    cursor?: SecuritySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SecuritySettings.
     */
    distinct?: SecuritySettingsScalarFieldEnum | SecuritySettingsScalarFieldEnum[]
  }

  /**
   * SecuritySettings findMany
   */
  export type SecuritySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter, which SecuritySettings to fetch.
     */
    where?: SecuritySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SecuritySettings to fetch.
     */
    orderBy?: SecuritySettingsOrderByWithRelationInput | SecuritySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SecuritySettings.
     */
    cursor?: SecuritySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SecuritySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SecuritySettings.
     */
    skip?: number
    distinct?: SecuritySettingsScalarFieldEnum | SecuritySettingsScalarFieldEnum[]
  }

  /**
   * SecuritySettings create
   */
  export type SecuritySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a SecuritySettings.
     */
    data: XOR<SecuritySettingsCreateInput, SecuritySettingsUncheckedCreateInput>
  }

  /**
   * SecuritySettings createMany
   */
  export type SecuritySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecuritySettings.
     */
    data: SecuritySettingsCreateManyInput | SecuritySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecuritySettings createManyAndReturn
   */
  export type SecuritySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SecuritySettings.
     */
    data: SecuritySettingsCreateManyInput | SecuritySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecuritySettings update
   */
  export type SecuritySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a SecuritySettings.
     */
    data: XOR<SecuritySettingsUpdateInput, SecuritySettingsUncheckedUpdateInput>
    /**
     * Choose, which SecuritySettings to update.
     */
    where: SecuritySettingsWhereUniqueInput
  }

  /**
   * SecuritySettings updateMany
   */
  export type SecuritySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecuritySettings.
     */
    data: XOR<SecuritySettingsUpdateManyMutationInput, SecuritySettingsUncheckedUpdateManyInput>
    /**
     * Filter which SecuritySettings to update
     */
    where?: SecuritySettingsWhereInput
  }

  /**
   * SecuritySettings upsert
   */
  export type SecuritySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the SecuritySettings to update in case it exists.
     */
    where: SecuritySettingsWhereUniqueInput
    /**
     * In case the SecuritySettings found by the `where` argument doesn't exist, create a new SecuritySettings with this data.
     */
    create: XOR<SecuritySettingsCreateInput, SecuritySettingsUncheckedCreateInput>
    /**
     * In case the SecuritySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecuritySettingsUpdateInput, SecuritySettingsUncheckedUpdateInput>
  }

  /**
   * SecuritySettings delete
   */
  export type SecuritySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
    /**
     * Filter which SecuritySettings to delete.
     */
    where: SecuritySettingsWhereUniqueInput
  }

  /**
   * SecuritySettings deleteMany
   */
  export type SecuritySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecuritySettings to delete
     */
    where?: SecuritySettingsWhereInput
  }

  /**
   * SecuritySettings without action
   */
  export type SecuritySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecuritySettings
     */
    select?: SecuritySettingsSelect<ExtArgs> | null
  }


  /**
   * Model DataRetentionSettings
   */

  export type AggregateDataRetentionSettings = {
    _count: DataRetentionSettingsCountAggregateOutputType | null
    _avg: DataRetentionSettingsAvgAggregateOutputType | null
    _sum: DataRetentionSettingsSumAggregateOutputType | null
    _min: DataRetentionSettingsMinAggregateOutputType | null
    _max: DataRetentionSettingsMaxAggregateOutputType | null
  }

  export type DataRetentionSettingsAvgAggregateOutputType = {
    id: number | null
    keepInactiveDataMonths: number | null
    archiveLeadsAfterDays: number | null
    backupFrequencyDays: number | null
  }

  export type DataRetentionSettingsSumAggregateOutputType = {
    id: number | null
    keepInactiveDataMonths: number | null
    archiveLeadsAfterDays: number | null
    backupFrequencyDays: number | null
  }

  export type DataRetentionSettingsMinAggregateOutputType = {
    id: number | null
    keepInactiveDataMonths: number | null
    archiveLeadsAfterDays: number | null
    backupFrequencyDays: number | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type DataRetentionSettingsMaxAggregateOutputType = {
    id: number | null
    keepInactiveDataMonths: number | null
    archiveLeadsAfterDays: number | null
    backupFrequencyDays: number | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type DataRetentionSettingsCountAggregateOutputType = {
    id: number
    keepInactiveDataMonths: number
    archiveLeadsAfterDays: number
    backupFrequencyDays: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type DataRetentionSettingsAvgAggregateInputType = {
    id?: true
    keepInactiveDataMonths?: true
    archiveLeadsAfterDays?: true
    backupFrequencyDays?: true
  }

  export type DataRetentionSettingsSumAggregateInputType = {
    id?: true
    keepInactiveDataMonths?: true
    archiveLeadsAfterDays?: true
    backupFrequencyDays?: true
  }

  export type DataRetentionSettingsMinAggregateInputType = {
    id?: true
    keepInactiveDataMonths?: true
    archiveLeadsAfterDays?: true
    backupFrequencyDays?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DataRetentionSettingsMaxAggregateInputType = {
    id?: true
    keepInactiveDataMonths?: true
    archiveLeadsAfterDays?: true
    backupFrequencyDays?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type DataRetentionSettingsCountAggregateInputType = {
    id?: true
    keepInactiveDataMonths?: true
    archiveLeadsAfterDays?: true
    backupFrequencyDays?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type DataRetentionSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionSettings to aggregate.
     */
    where?: DataRetentionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionSettings to fetch.
     */
    orderBy?: DataRetentionSettingsOrderByWithRelationInput | DataRetentionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataRetentionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataRetentionSettings
    **/
    _count?: true | DataRetentionSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataRetentionSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataRetentionSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataRetentionSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataRetentionSettingsMaxAggregateInputType
  }

  export type GetDataRetentionSettingsAggregateType<T extends DataRetentionSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateDataRetentionSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataRetentionSettings[P]>
      : GetScalarType<T[P], AggregateDataRetentionSettings[P]>
  }




  export type DataRetentionSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataRetentionSettingsWhereInput
    orderBy?: DataRetentionSettingsOrderByWithAggregationInput | DataRetentionSettingsOrderByWithAggregationInput[]
    by: DataRetentionSettingsScalarFieldEnum[] | DataRetentionSettingsScalarFieldEnum
    having?: DataRetentionSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataRetentionSettingsCountAggregateInputType | true
    _avg?: DataRetentionSettingsAvgAggregateInputType
    _sum?: DataRetentionSettingsSumAggregateInputType
    _min?: DataRetentionSettingsMinAggregateInputType
    _max?: DataRetentionSettingsMaxAggregateInputType
  }

  export type DataRetentionSettingsGroupByOutputType = {
    id: number
    keepInactiveDataMonths: number
    archiveLeadsAfterDays: number
    backupFrequencyDays: number
    updatedAt: Date
    updatedBy: string | null
    _count: DataRetentionSettingsCountAggregateOutputType | null
    _avg: DataRetentionSettingsAvgAggregateOutputType | null
    _sum: DataRetentionSettingsSumAggregateOutputType | null
    _min: DataRetentionSettingsMinAggregateOutputType | null
    _max: DataRetentionSettingsMaxAggregateOutputType | null
  }

  type GetDataRetentionSettingsGroupByPayload<T extends DataRetentionSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataRetentionSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataRetentionSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataRetentionSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], DataRetentionSettingsGroupByOutputType[P]>
        }
      >
    >


  export type DataRetentionSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keepInactiveDataMonths?: boolean
    archiveLeadsAfterDays?: boolean
    backupFrequencyDays?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["dataRetentionSettings"]>

  export type DataRetentionSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keepInactiveDataMonths?: boolean
    archiveLeadsAfterDays?: boolean
    backupFrequencyDays?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["dataRetentionSettings"]>

  export type DataRetentionSettingsSelectScalar = {
    id?: boolean
    keepInactiveDataMonths?: boolean
    archiveLeadsAfterDays?: boolean
    backupFrequencyDays?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $DataRetentionSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataRetentionSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      keepInactiveDataMonths: number
      archiveLeadsAfterDays: number
      backupFrequencyDays: number
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["dataRetentionSettings"]>
    composites: {}
  }

  type DataRetentionSettingsGetPayload<S extends boolean | null | undefined | DataRetentionSettingsDefaultArgs> = $Result.GetResult<Prisma.$DataRetentionSettingsPayload, S>

  type DataRetentionSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataRetentionSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataRetentionSettingsCountAggregateInputType | true
    }

  export interface DataRetentionSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataRetentionSettings'], meta: { name: 'DataRetentionSettings' } }
    /**
     * Find zero or one DataRetentionSettings that matches the filter.
     * @param {DataRetentionSettingsFindUniqueArgs} args - Arguments to find a DataRetentionSettings
     * @example
     * // Get one DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataRetentionSettingsFindUniqueArgs>(args: SelectSubset<T, DataRetentionSettingsFindUniqueArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataRetentionSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataRetentionSettingsFindUniqueOrThrowArgs} args - Arguments to find a DataRetentionSettings
     * @example
     * // Get one DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataRetentionSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, DataRetentionSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataRetentionSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsFindFirstArgs} args - Arguments to find a DataRetentionSettings
     * @example
     * // Get one DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataRetentionSettingsFindFirstArgs>(args?: SelectSubset<T, DataRetentionSettingsFindFirstArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataRetentionSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsFindFirstOrThrowArgs} args - Arguments to find a DataRetentionSettings
     * @example
     * // Get one DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataRetentionSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, DataRetentionSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataRetentionSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findMany()
     * 
     * // Get first 10 DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataRetentionSettingsWithIdOnly = await prisma.dataRetentionSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataRetentionSettingsFindManyArgs>(args?: SelectSubset<T, DataRetentionSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataRetentionSettings.
     * @param {DataRetentionSettingsCreateArgs} args - Arguments to create a DataRetentionSettings.
     * @example
     * // Create one DataRetentionSettings
     * const DataRetentionSettings = await prisma.dataRetentionSettings.create({
     *   data: {
     *     // ... data to create a DataRetentionSettings
     *   }
     * })
     * 
     */
    create<T extends DataRetentionSettingsCreateArgs>(args: SelectSubset<T, DataRetentionSettingsCreateArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataRetentionSettings.
     * @param {DataRetentionSettingsCreateManyArgs} args - Arguments to create many DataRetentionSettings.
     * @example
     * // Create many DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataRetentionSettingsCreateManyArgs>(args?: SelectSubset<T, DataRetentionSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataRetentionSettings and returns the data saved in the database.
     * @param {DataRetentionSettingsCreateManyAndReturnArgs} args - Arguments to create many DataRetentionSettings.
     * @example
     * // Create many DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataRetentionSettings and only return the `id`
     * const dataRetentionSettingsWithIdOnly = await prisma.dataRetentionSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataRetentionSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, DataRetentionSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataRetentionSettings.
     * @param {DataRetentionSettingsDeleteArgs} args - Arguments to delete one DataRetentionSettings.
     * @example
     * // Delete one DataRetentionSettings
     * const DataRetentionSettings = await prisma.dataRetentionSettings.delete({
     *   where: {
     *     // ... filter to delete one DataRetentionSettings
     *   }
     * })
     * 
     */
    delete<T extends DataRetentionSettingsDeleteArgs>(args: SelectSubset<T, DataRetentionSettingsDeleteArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataRetentionSettings.
     * @param {DataRetentionSettingsUpdateArgs} args - Arguments to update one DataRetentionSettings.
     * @example
     * // Update one DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataRetentionSettingsUpdateArgs>(args: SelectSubset<T, DataRetentionSettingsUpdateArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataRetentionSettings.
     * @param {DataRetentionSettingsDeleteManyArgs} args - Arguments to filter DataRetentionSettings to delete.
     * @example
     * // Delete a few DataRetentionSettings
     * const { count } = await prisma.dataRetentionSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataRetentionSettingsDeleteManyArgs>(args?: SelectSubset<T, DataRetentionSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataRetentionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataRetentionSettingsUpdateManyArgs>(args: SelectSubset<T, DataRetentionSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataRetentionSettings.
     * @param {DataRetentionSettingsUpsertArgs} args - Arguments to update or create a DataRetentionSettings.
     * @example
     * // Update or create a DataRetentionSettings
     * const dataRetentionSettings = await prisma.dataRetentionSettings.upsert({
     *   create: {
     *     // ... data to create a DataRetentionSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataRetentionSettings we want to update
     *   }
     * })
     */
    upsert<T extends DataRetentionSettingsUpsertArgs>(args: SelectSubset<T, DataRetentionSettingsUpsertArgs<ExtArgs>>): Prisma__DataRetentionSettingsClient<$Result.GetResult<Prisma.$DataRetentionSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataRetentionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsCountArgs} args - Arguments to filter DataRetentionSettings to count.
     * @example
     * // Count the number of DataRetentionSettings
     * const count = await prisma.dataRetentionSettings.count({
     *   where: {
     *     // ... the filter for the DataRetentionSettings we want to count
     *   }
     * })
    **/
    count<T extends DataRetentionSettingsCountArgs>(
      args?: Subset<T, DataRetentionSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataRetentionSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataRetentionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataRetentionSettingsAggregateArgs>(args: Subset<T, DataRetentionSettingsAggregateArgs>): Prisma.PrismaPromise<GetDataRetentionSettingsAggregateType<T>>

    /**
     * Group by DataRetentionSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataRetentionSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataRetentionSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataRetentionSettingsGroupByArgs['orderBy'] }
        : { orderBy?: DataRetentionSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataRetentionSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataRetentionSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataRetentionSettings model
   */
  readonly fields: DataRetentionSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataRetentionSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataRetentionSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataRetentionSettings model
   */ 
  interface DataRetentionSettingsFieldRefs {
    readonly id: FieldRef<"DataRetentionSettings", 'Int'>
    readonly keepInactiveDataMonths: FieldRef<"DataRetentionSettings", 'Int'>
    readonly archiveLeadsAfterDays: FieldRef<"DataRetentionSettings", 'Int'>
    readonly backupFrequencyDays: FieldRef<"DataRetentionSettings", 'Int'>
    readonly updatedAt: FieldRef<"DataRetentionSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"DataRetentionSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataRetentionSettings findUnique
   */
  export type DataRetentionSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionSettings to fetch.
     */
    where: DataRetentionSettingsWhereUniqueInput
  }

  /**
   * DataRetentionSettings findUniqueOrThrow
   */
  export type DataRetentionSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionSettings to fetch.
     */
    where: DataRetentionSettingsWhereUniqueInput
  }

  /**
   * DataRetentionSettings findFirst
   */
  export type DataRetentionSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionSettings to fetch.
     */
    where?: DataRetentionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionSettings to fetch.
     */
    orderBy?: DataRetentionSettingsOrderByWithRelationInput | DataRetentionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionSettings.
     */
    cursor?: DataRetentionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionSettings.
     */
    distinct?: DataRetentionSettingsScalarFieldEnum | DataRetentionSettingsScalarFieldEnum[]
  }

  /**
   * DataRetentionSettings findFirstOrThrow
   */
  export type DataRetentionSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionSettings to fetch.
     */
    where?: DataRetentionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionSettings to fetch.
     */
    orderBy?: DataRetentionSettingsOrderByWithRelationInput | DataRetentionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataRetentionSettings.
     */
    cursor?: DataRetentionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataRetentionSettings.
     */
    distinct?: DataRetentionSettingsScalarFieldEnum | DataRetentionSettingsScalarFieldEnum[]
  }

  /**
   * DataRetentionSettings findMany
   */
  export type DataRetentionSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter, which DataRetentionSettings to fetch.
     */
    where?: DataRetentionSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataRetentionSettings to fetch.
     */
    orderBy?: DataRetentionSettingsOrderByWithRelationInput | DataRetentionSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataRetentionSettings.
     */
    cursor?: DataRetentionSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataRetentionSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataRetentionSettings.
     */
    skip?: number
    distinct?: DataRetentionSettingsScalarFieldEnum | DataRetentionSettingsScalarFieldEnum[]
  }

  /**
   * DataRetentionSettings create
   */
  export type DataRetentionSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a DataRetentionSettings.
     */
    data: XOR<DataRetentionSettingsCreateInput, DataRetentionSettingsUncheckedCreateInput>
  }

  /**
   * DataRetentionSettings createMany
   */
  export type DataRetentionSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataRetentionSettings.
     */
    data: DataRetentionSettingsCreateManyInput | DataRetentionSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionSettings createManyAndReturn
   */
  export type DataRetentionSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataRetentionSettings.
     */
    data: DataRetentionSettingsCreateManyInput | DataRetentionSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataRetentionSettings update
   */
  export type DataRetentionSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a DataRetentionSettings.
     */
    data: XOR<DataRetentionSettingsUpdateInput, DataRetentionSettingsUncheckedUpdateInput>
    /**
     * Choose, which DataRetentionSettings to update.
     */
    where: DataRetentionSettingsWhereUniqueInput
  }

  /**
   * DataRetentionSettings updateMany
   */
  export type DataRetentionSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataRetentionSettings.
     */
    data: XOR<DataRetentionSettingsUpdateManyMutationInput, DataRetentionSettingsUncheckedUpdateManyInput>
    /**
     * Filter which DataRetentionSettings to update
     */
    where?: DataRetentionSettingsWhereInput
  }

  /**
   * DataRetentionSettings upsert
   */
  export type DataRetentionSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the DataRetentionSettings to update in case it exists.
     */
    where: DataRetentionSettingsWhereUniqueInput
    /**
     * In case the DataRetentionSettings found by the `where` argument doesn't exist, create a new DataRetentionSettings with this data.
     */
    create: XOR<DataRetentionSettingsCreateInput, DataRetentionSettingsUncheckedCreateInput>
    /**
     * In case the DataRetentionSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataRetentionSettingsUpdateInput, DataRetentionSettingsUncheckedUpdateInput>
  }

  /**
   * DataRetentionSettings delete
   */
  export type DataRetentionSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
    /**
     * Filter which DataRetentionSettings to delete.
     */
    where: DataRetentionSettingsWhereUniqueInput
  }

  /**
   * DataRetentionSettings deleteMany
   */
  export type DataRetentionSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataRetentionSettings to delete
     */
    where?: DataRetentionSettingsWhereInput
  }

  /**
   * DataRetentionSettings without action
   */
  export type DataRetentionSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataRetentionSettings
     */
    select?: DataRetentionSettingsSelect<ExtArgs> | null
  }


  /**
   * Model RolePermissions
   */

  export type AggregateRolePermissions = {
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  export type RolePermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type RolePermissionsSumAggregateOutputType = {
    id: number | null
  }

  export type RolePermissionsMinAggregateOutputType = {
    id: number | null
    role: string | null
    analyticsAccess: boolean | null
    analyticsScope: string | null
    userMgmtAccess: boolean | null
    userMgmtScope: string | null
    userMgmtCreate: boolean | null
    userMgmtEdit: boolean | null
    userMgmtDelete: boolean | null
    studentMgmtAccess: boolean | null
    studentMgmtScope: string | null
    adminMgmtAccess: boolean | null
    adminMgmtScope: string | null
    adminMgmtCreate: boolean | null
    adminMgmtEdit: boolean | null
    adminMgmtDelete: boolean | null
    campusPerfAccess: boolean | null
    campusPerfScope: string | null
    reportsAccess: boolean | null
    reportsScope: string | null
    settlementsAccess: boolean | null
    settlementsScope: string | null
    marketingKitAccess: boolean | null
    marketingKitScope: string | null
    auditLogAccess: boolean | null
    auditLogScope: string | null
    supportDeskAccess: boolean | null
    supportDeskScope: string | null
    referralSubmissionAccess: boolean | null
    referralSubmissionScope: string | null
    referralTrackingAccess: boolean | null
    referralTrackingScope: string | null
    savingsCalculatorAccess: boolean | null
    savingsCalculatorScope: string | null
    rulesAccessAccess: boolean | null
    rulesAccessScope: string | null
    settingsAccess: boolean | null
    settingsScope: string | null
    updatedAt: Date | null
    updatedBy: string | null
    studentMgmtCreate: boolean | null
    studentMgmtDelete: boolean | null
    studentMgmtEdit: boolean | null
    deletionHubAccess: boolean | null
    deletionHubScope: string | null
    passwordResetAccess: boolean | null
    passwordResetScope: string | null
    engagementCentreAccess: boolean | null
    engagementCentreScope: string | null
    feeManagementAccess: boolean | null
    feeManagementScope: string | null
  }

  export type RolePermissionsMaxAggregateOutputType = {
    id: number | null
    role: string | null
    analyticsAccess: boolean | null
    analyticsScope: string | null
    userMgmtAccess: boolean | null
    userMgmtScope: string | null
    userMgmtCreate: boolean | null
    userMgmtEdit: boolean | null
    userMgmtDelete: boolean | null
    studentMgmtAccess: boolean | null
    studentMgmtScope: string | null
    adminMgmtAccess: boolean | null
    adminMgmtScope: string | null
    adminMgmtCreate: boolean | null
    adminMgmtEdit: boolean | null
    adminMgmtDelete: boolean | null
    campusPerfAccess: boolean | null
    campusPerfScope: string | null
    reportsAccess: boolean | null
    reportsScope: string | null
    settlementsAccess: boolean | null
    settlementsScope: string | null
    marketingKitAccess: boolean | null
    marketingKitScope: string | null
    auditLogAccess: boolean | null
    auditLogScope: string | null
    supportDeskAccess: boolean | null
    supportDeskScope: string | null
    referralSubmissionAccess: boolean | null
    referralSubmissionScope: string | null
    referralTrackingAccess: boolean | null
    referralTrackingScope: string | null
    savingsCalculatorAccess: boolean | null
    savingsCalculatorScope: string | null
    rulesAccessAccess: boolean | null
    rulesAccessScope: string | null
    settingsAccess: boolean | null
    settingsScope: string | null
    updatedAt: Date | null
    updatedBy: string | null
    studentMgmtCreate: boolean | null
    studentMgmtDelete: boolean | null
    studentMgmtEdit: boolean | null
    deletionHubAccess: boolean | null
    deletionHubScope: string | null
    passwordResetAccess: boolean | null
    passwordResetScope: string | null
    engagementCentreAccess: boolean | null
    engagementCentreScope: string | null
    feeManagementAccess: boolean | null
    feeManagementScope: string | null
  }

  export type RolePermissionsCountAggregateOutputType = {
    id: number
    role: number
    analyticsAccess: number
    analyticsScope: number
    userMgmtAccess: number
    userMgmtScope: number
    userMgmtCreate: number
    userMgmtEdit: number
    userMgmtDelete: number
    studentMgmtAccess: number
    studentMgmtScope: number
    adminMgmtAccess: number
    adminMgmtScope: number
    adminMgmtCreate: number
    adminMgmtEdit: number
    adminMgmtDelete: number
    campusPerfAccess: number
    campusPerfScope: number
    reportsAccess: number
    reportsScope: number
    settlementsAccess: number
    settlementsScope: number
    marketingKitAccess: number
    marketingKitScope: number
    auditLogAccess: number
    auditLogScope: number
    supportDeskAccess: number
    supportDeskScope: number
    referralSubmissionAccess: number
    referralSubmissionScope: number
    referralTrackingAccess: number
    referralTrackingScope: number
    savingsCalculatorAccess: number
    savingsCalculatorScope: number
    rulesAccessAccess: number
    rulesAccessScope: number
    settingsAccess: number
    settingsScope: number
    updatedAt: number
    updatedBy: number
    studentMgmtCreate: number
    studentMgmtDelete: number
    studentMgmtEdit: number
    deletionHubAccess: number
    deletionHubScope: number
    passwordResetAccess: number
    passwordResetScope: number
    engagementCentreAccess: number
    engagementCentreScope: number
    feeManagementAccess: number
    feeManagementScope: number
    _all: number
  }


  export type RolePermissionsAvgAggregateInputType = {
    id?: true
  }

  export type RolePermissionsSumAggregateInputType = {
    id?: true
  }

  export type RolePermissionsMinAggregateInputType = {
    id?: true
    role?: true
    analyticsAccess?: true
    analyticsScope?: true
    userMgmtAccess?: true
    userMgmtScope?: true
    userMgmtCreate?: true
    userMgmtEdit?: true
    userMgmtDelete?: true
    studentMgmtAccess?: true
    studentMgmtScope?: true
    adminMgmtAccess?: true
    adminMgmtScope?: true
    adminMgmtCreate?: true
    adminMgmtEdit?: true
    adminMgmtDelete?: true
    campusPerfAccess?: true
    campusPerfScope?: true
    reportsAccess?: true
    reportsScope?: true
    settlementsAccess?: true
    settlementsScope?: true
    marketingKitAccess?: true
    marketingKitScope?: true
    auditLogAccess?: true
    auditLogScope?: true
    supportDeskAccess?: true
    supportDeskScope?: true
    referralSubmissionAccess?: true
    referralSubmissionScope?: true
    referralTrackingAccess?: true
    referralTrackingScope?: true
    savingsCalculatorAccess?: true
    savingsCalculatorScope?: true
    rulesAccessAccess?: true
    rulesAccessScope?: true
    settingsAccess?: true
    settingsScope?: true
    updatedAt?: true
    updatedBy?: true
    studentMgmtCreate?: true
    studentMgmtDelete?: true
    studentMgmtEdit?: true
    deletionHubAccess?: true
    deletionHubScope?: true
    passwordResetAccess?: true
    passwordResetScope?: true
    engagementCentreAccess?: true
    engagementCentreScope?: true
    feeManagementAccess?: true
    feeManagementScope?: true
  }

  export type RolePermissionsMaxAggregateInputType = {
    id?: true
    role?: true
    analyticsAccess?: true
    analyticsScope?: true
    userMgmtAccess?: true
    userMgmtScope?: true
    userMgmtCreate?: true
    userMgmtEdit?: true
    userMgmtDelete?: true
    studentMgmtAccess?: true
    studentMgmtScope?: true
    adminMgmtAccess?: true
    adminMgmtScope?: true
    adminMgmtCreate?: true
    adminMgmtEdit?: true
    adminMgmtDelete?: true
    campusPerfAccess?: true
    campusPerfScope?: true
    reportsAccess?: true
    reportsScope?: true
    settlementsAccess?: true
    settlementsScope?: true
    marketingKitAccess?: true
    marketingKitScope?: true
    auditLogAccess?: true
    auditLogScope?: true
    supportDeskAccess?: true
    supportDeskScope?: true
    referralSubmissionAccess?: true
    referralSubmissionScope?: true
    referralTrackingAccess?: true
    referralTrackingScope?: true
    savingsCalculatorAccess?: true
    savingsCalculatorScope?: true
    rulesAccessAccess?: true
    rulesAccessScope?: true
    settingsAccess?: true
    settingsScope?: true
    updatedAt?: true
    updatedBy?: true
    studentMgmtCreate?: true
    studentMgmtDelete?: true
    studentMgmtEdit?: true
    deletionHubAccess?: true
    deletionHubScope?: true
    passwordResetAccess?: true
    passwordResetScope?: true
    engagementCentreAccess?: true
    engagementCentreScope?: true
    feeManagementAccess?: true
    feeManagementScope?: true
  }

  export type RolePermissionsCountAggregateInputType = {
    id?: true
    role?: true
    analyticsAccess?: true
    analyticsScope?: true
    userMgmtAccess?: true
    userMgmtScope?: true
    userMgmtCreate?: true
    userMgmtEdit?: true
    userMgmtDelete?: true
    studentMgmtAccess?: true
    studentMgmtScope?: true
    adminMgmtAccess?: true
    adminMgmtScope?: true
    adminMgmtCreate?: true
    adminMgmtEdit?: true
    adminMgmtDelete?: true
    campusPerfAccess?: true
    campusPerfScope?: true
    reportsAccess?: true
    reportsScope?: true
    settlementsAccess?: true
    settlementsScope?: true
    marketingKitAccess?: true
    marketingKitScope?: true
    auditLogAccess?: true
    auditLogScope?: true
    supportDeskAccess?: true
    supportDeskScope?: true
    referralSubmissionAccess?: true
    referralSubmissionScope?: true
    referralTrackingAccess?: true
    referralTrackingScope?: true
    savingsCalculatorAccess?: true
    savingsCalculatorScope?: true
    rulesAccessAccess?: true
    rulesAccessScope?: true
    settingsAccess?: true
    settingsScope?: true
    updatedAt?: true
    updatedBy?: true
    studentMgmtCreate?: true
    studentMgmtDelete?: true
    studentMgmtEdit?: true
    deletionHubAccess?: true
    deletionHubScope?: true
    passwordResetAccess?: true
    passwordResetScope?: true
    engagementCentreAccess?: true
    engagementCentreScope?: true
    feeManagementAccess?: true
    feeManagementScope?: true
    _all?: true
  }

  export type RolePermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to aggregate.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type GetRolePermissionsAggregateType<T extends RolePermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermissions[P]>
      : GetScalarType<T[P], AggregateRolePermissions[P]>
  }




  export type RolePermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionsWhereInput
    orderBy?: RolePermissionsOrderByWithAggregationInput | RolePermissionsOrderByWithAggregationInput[]
    by: RolePermissionsScalarFieldEnum[] | RolePermissionsScalarFieldEnum
    having?: RolePermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionsCountAggregateInputType | true
    _avg?: RolePermissionsAvgAggregateInputType
    _sum?: RolePermissionsSumAggregateInputType
    _min?: RolePermissionsMinAggregateInputType
    _max?: RolePermissionsMaxAggregateInputType
  }

  export type RolePermissionsGroupByOutputType = {
    id: number
    role: string
    analyticsAccess: boolean
    analyticsScope: string
    userMgmtAccess: boolean
    userMgmtScope: string
    userMgmtCreate: boolean
    userMgmtEdit: boolean
    userMgmtDelete: boolean
    studentMgmtAccess: boolean
    studentMgmtScope: string
    adminMgmtAccess: boolean
    adminMgmtScope: string
    adminMgmtCreate: boolean
    adminMgmtEdit: boolean
    adminMgmtDelete: boolean
    campusPerfAccess: boolean
    campusPerfScope: string
    reportsAccess: boolean
    reportsScope: string
    settlementsAccess: boolean
    settlementsScope: string
    marketingKitAccess: boolean
    marketingKitScope: string
    auditLogAccess: boolean
    auditLogScope: string
    supportDeskAccess: boolean
    supportDeskScope: string
    referralSubmissionAccess: boolean
    referralSubmissionScope: string
    referralTrackingAccess: boolean
    referralTrackingScope: string
    savingsCalculatorAccess: boolean
    savingsCalculatorScope: string
    rulesAccessAccess: boolean
    rulesAccessScope: string
    settingsAccess: boolean
    settingsScope: string
    updatedAt: Date
    updatedBy: string | null
    studentMgmtCreate: boolean
    studentMgmtDelete: boolean
    studentMgmtEdit: boolean
    deletionHubAccess: boolean
    deletionHubScope: string
    passwordResetAccess: boolean
    passwordResetScope: string
    engagementCentreAccess: boolean
    engagementCentreScope: string
    feeManagementAccess: boolean
    feeManagementScope: string
    _count: RolePermissionsCountAggregateOutputType | null
    _avg: RolePermissionsAvgAggregateOutputType | null
    _sum: RolePermissionsSumAggregateOutputType | null
    _min: RolePermissionsMinAggregateOutputType | null
    _max: RolePermissionsMaxAggregateOutputType | null
  }

  type GetRolePermissionsGroupByPayload<T extends RolePermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionsGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    analyticsAccess?: boolean
    analyticsScope?: boolean
    userMgmtAccess?: boolean
    userMgmtScope?: boolean
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: boolean
    adminMgmtAccess?: boolean
    adminMgmtScope?: boolean
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: boolean
    reportsAccess?: boolean
    reportsScope?: boolean
    settlementsAccess?: boolean
    settlementsScope?: boolean
    marketingKitAccess?: boolean
    marketingKitScope?: boolean
    auditLogAccess?: boolean
    auditLogScope?: boolean
    supportDeskAccess?: boolean
    supportDeskScope?: boolean
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: boolean
    referralTrackingAccess?: boolean
    referralTrackingScope?: boolean
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: boolean
    rulesAccessAccess?: boolean
    rulesAccessScope?: boolean
    settingsAccess?: boolean
    settingsScope?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: boolean
    passwordResetAccess?: boolean
    passwordResetScope?: boolean
    engagementCentreAccess?: boolean
    engagementCentreScope?: boolean
    feeManagementAccess?: boolean
    feeManagementScope?: boolean
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    analyticsAccess?: boolean
    analyticsScope?: boolean
    userMgmtAccess?: boolean
    userMgmtScope?: boolean
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: boolean
    adminMgmtAccess?: boolean
    adminMgmtScope?: boolean
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: boolean
    reportsAccess?: boolean
    reportsScope?: boolean
    settlementsAccess?: boolean
    settlementsScope?: boolean
    marketingKitAccess?: boolean
    marketingKitScope?: boolean
    auditLogAccess?: boolean
    auditLogScope?: boolean
    supportDeskAccess?: boolean
    supportDeskScope?: boolean
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: boolean
    referralTrackingAccess?: boolean
    referralTrackingScope?: boolean
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: boolean
    rulesAccessAccess?: boolean
    rulesAccessScope?: boolean
    settingsAccess?: boolean
    settingsScope?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: boolean
    passwordResetAccess?: boolean
    passwordResetScope?: boolean
    engagementCentreAccess?: boolean
    engagementCentreScope?: boolean
    feeManagementAccess?: boolean
    feeManagementScope?: boolean
  }, ExtArgs["result"]["rolePermissions"]>

  export type RolePermissionsSelectScalar = {
    id?: boolean
    role?: boolean
    analyticsAccess?: boolean
    analyticsScope?: boolean
    userMgmtAccess?: boolean
    userMgmtScope?: boolean
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: boolean
    adminMgmtAccess?: boolean
    adminMgmtScope?: boolean
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: boolean
    reportsAccess?: boolean
    reportsScope?: boolean
    settlementsAccess?: boolean
    settlementsScope?: boolean
    marketingKitAccess?: boolean
    marketingKitScope?: boolean
    auditLogAccess?: boolean
    auditLogScope?: boolean
    supportDeskAccess?: boolean
    supportDeskScope?: boolean
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: boolean
    referralTrackingAccess?: boolean
    referralTrackingScope?: boolean
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: boolean
    rulesAccessAccess?: boolean
    rulesAccessScope?: boolean
    settingsAccess?: boolean
    settingsScope?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: boolean
    passwordResetAccess?: boolean
    passwordResetScope?: boolean
    engagementCentreAccess?: boolean
    engagementCentreScope?: boolean
    feeManagementAccess?: boolean
    feeManagementScope?: boolean
  }


  export type $RolePermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role: string
      analyticsAccess: boolean
      analyticsScope: string
      userMgmtAccess: boolean
      userMgmtScope: string
      userMgmtCreate: boolean
      userMgmtEdit: boolean
      userMgmtDelete: boolean
      studentMgmtAccess: boolean
      studentMgmtScope: string
      adminMgmtAccess: boolean
      adminMgmtScope: string
      adminMgmtCreate: boolean
      adminMgmtEdit: boolean
      adminMgmtDelete: boolean
      campusPerfAccess: boolean
      campusPerfScope: string
      reportsAccess: boolean
      reportsScope: string
      settlementsAccess: boolean
      settlementsScope: string
      marketingKitAccess: boolean
      marketingKitScope: string
      auditLogAccess: boolean
      auditLogScope: string
      supportDeskAccess: boolean
      supportDeskScope: string
      referralSubmissionAccess: boolean
      referralSubmissionScope: string
      referralTrackingAccess: boolean
      referralTrackingScope: string
      savingsCalculatorAccess: boolean
      savingsCalculatorScope: string
      rulesAccessAccess: boolean
      rulesAccessScope: string
      settingsAccess: boolean
      settingsScope: string
      updatedAt: Date
      updatedBy: string | null
      studentMgmtCreate: boolean
      studentMgmtDelete: boolean
      studentMgmtEdit: boolean
      deletionHubAccess: boolean
      deletionHubScope: string
      passwordResetAccess: boolean
      passwordResetScope: string
      engagementCentreAccess: boolean
      engagementCentreScope: string
      feeManagementAccess: boolean
      feeManagementScope: string
    }, ExtArgs["result"]["rolePermissions"]>
    composites: {}
  }

  type RolePermissionsGetPayload<S extends boolean | null | undefined | RolePermissionsDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionsPayload, S>

  type RolePermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolePermissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolePermissionsCountAggregateInputType | true
    }

  export interface RolePermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermissions'], meta: { name: 'RolePermissions' } }
    /**
     * Find zero or one RolePermissions that matches the filter.
     * @param {RolePermissionsFindUniqueArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionsFindUniqueArgs>(args: SelectSubset<T, RolePermissionsFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RolePermissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolePermissionsFindUniqueOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionsFindFirstArgs>(args?: SelectSubset<T, RolePermissionsFindFirstArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RolePermissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindFirstOrThrowArgs} args - Arguments to find a RolePermissions
     * @example
     * // Get one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionsWithIdOnly = await prisma.rolePermissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionsFindManyArgs>(args?: SelectSubset<T, RolePermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RolePermissions.
     * @param {RolePermissionsCreateArgs} args - Arguments to create a RolePermissions.
     * @example
     * // Create one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.create({
     *   data: {
     *     // ... data to create a RolePermissions
     *   }
     * })
     * 
     */
    create<T extends RolePermissionsCreateArgs>(args: SelectSubset<T, RolePermissionsCreateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionsCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionsCreateManyArgs>(args?: SelectSubset<T, RolePermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolePermissions and returns the data saved in the database.
     * @param {RolePermissionsCreateManyAndReturnArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolePermissions and only return the `id`
     * const rolePermissionsWithIdOnly = await prisma.rolePermissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolePermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, RolePermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RolePermissions.
     * @param {RolePermissionsDeleteArgs} args - Arguments to delete one RolePermissions.
     * @example
     * // Delete one RolePermissions
     * const RolePermissions = await prisma.rolePermissions.delete({
     *   where: {
     *     // ... filter to delete one RolePermissions
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionsDeleteArgs>(args: SelectSubset<T, RolePermissionsDeleteArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RolePermissions.
     * @param {RolePermissionsUpdateArgs} args - Arguments to update one RolePermissions.
     * @example
     * // Update one RolePermissions
     * const rolePermissions = await prisma.rolePermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionsUpdateArgs>(args: SelectSubset<T, RolePermissionsUpdateArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionsDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionsDeleteManyArgs>(args?: SelectSubset<T, RolePermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermissions = await prisma.rolePermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionsUpdateManyArgs>(args: SelectSubset<T, RolePermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermissions.
     * @param {RolePermissionsUpsertArgs} args - Arguments to update or create a RolePermissions.
     * @example
     * // Update or create a RolePermissions
     * const rolePermissions = await prisma.rolePermissions.upsert({
     *   create: {
     *     // ... data to create a RolePermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermissions we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionsUpsertArgs>(args: SelectSubset<T, RolePermissionsUpsertArgs<ExtArgs>>): Prisma__RolePermissionsClient<$Result.GetResult<Prisma.$RolePermissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermissions.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionsCountArgs>(
      args?: Subset<T, RolePermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionsAggregateArgs>(args: Subset<T, RolePermissionsAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionsAggregateType<T>>

    /**
     * Group by RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionsGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermissions model
   */
  readonly fields: RolePermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermissions model
   */ 
  interface RolePermissionsFieldRefs {
    readonly id: FieldRef<"RolePermissions", 'Int'>
    readonly role: FieldRef<"RolePermissions", 'String'>
    readonly analyticsAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly analyticsScope: FieldRef<"RolePermissions", 'String'>
    readonly userMgmtAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly userMgmtScope: FieldRef<"RolePermissions", 'String'>
    readonly userMgmtCreate: FieldRef<"RolePermissions", 'Boolean'>
    readonly userMgmtEdit: FieldRef<"RolePermissions", 'Boolean'>
    readonly userMgmtDelete: FieldRef<"RolePermissions", 'Boolean'>
    readonly studentMgmtAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly studentMgmtScope: FieldRef<"RolePermissions", 'String'>
    readonly adminMgmtAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly adminMgmtScope: FieldRef<"RolePermissions", 'String'>
    readonly adminMgmtCreate: FieldRef<"RolePermissions", 'Boolean'>
    readonly adminMgmtEdit: FieldRef<"RolePermissions", 'Boolean'>
    readonly adminMgmtDelete: FieldRef<"RolePermissions", 'Boolean'>
    readonly campusPerfAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly campusPerfScope: FieldRef<"RolePermissions", 'String'>
    readonly reportsAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly reportsScope: FieldRef<"RolePermissions", 'String'>
    readonly settlementsAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly settlementsScope: FieldRef<"RolePermissions", 'String'>
    readonly marketingKitAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly marketingKitScope: FieldRef<"RolePermissions", 'String'>
    readonly auditLogAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly auditLogScope: FieldRef<"RolePermissions", 'String'>
    readonly supportDeskAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly supportDeskScope: FieldRef<"RolePermissions", 'String'>
    readonly referralSubmissionAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly referralSubmissionScope: FieldRef<"RolePermissions", 'String'>
    readonly referralTrackingAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly referralTrackingScope: FieldRef<"RolePermissions", 'String'>
    readonly savingsCalculatorAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly savingsCalculatorScope: FieldRef<"RolePermissions", 'String'>
    readonly rulesAccessAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly rulesAccessScope: FieldRef<"RolePermissions", 'String'>
    readonly settingsAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly settingsScope: FieldRef<"RolePermissions", 'String'>
    readonly updatedAt: FieldRef<"RolePermissions", 'DateTime'>
    readonly updatedBy: FieldRef<"RolePermissions", 'String'>
    readonly studentMgmtCreate: FieldRef<"RolePermissions", 'Boolean'>
    readonly studentMgmtDelete: FieldRef<"RolePermissions", 'Boolean'>
    readonly studentMgmtEdit: FieldRef<"RolePermissions", 'Boolean'>
    readonly deletionHubAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly deletionHubScope: FieldRef<"RolePermissions", 'String'>
    readonly passwordResetAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly passwordResetScope: FieldRef<"RolePermissions", 'String'>
    readonly engagementCentreAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly engagementCentreScope: FieldRef<"RolePermissions", 'String'>
    readonly feeManagementAccess: FieldRef<"RolePermissions", 'Boolean'>
    readonly feeManagementScope: FieldRef<"RolePermissions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RolePermissions findUnique
   */
  export type RolePermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findUniqueOrThrow
   */
  export type RolePermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions findFirst
   */
  export type RolePermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findFirstOrThrow
   */
  export type RolePermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions findMany
   */
  export type RolePermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionsOrderByWithRelationInput | RolePermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionsScalarFieldEnum | RolePermissionsScalarFieldEnum[]
  }

  /**
   * RolePermissions create
   */
  export type RolePermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * The data needed to create a RolePermissions.
     */
    data: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
  }

  /**
   * RolePermissions createMany
   */
  export type RolePermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissions createManyAndReturn
   */
  export type RolePermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionsCreateManyInput | RolePermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermissions update
   */
  export type RolePermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * The data needed to update a RolePermissions.
     */
    data: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
    /**
     * Choose, which RolePermissions to update.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions updateMany
   */
  export type RolePermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionsUpdateManyMutationInput, RolePermissionsUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionsWhereInput
  }

  /**
   * RolePermissions upsert
   */
  export type RolePermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * The filter to search for the RolePermissions to update in case it exists.
     */
    where: RolePermissionsWhereUniqueInput
    /**
     * In case the RolePermissions found by the `where` argument doesn't exist, create a new RolePermissions with this data.
     */
    create: XOR<RolePermissionsCreateInput, RolePermissionsUncheckedCreateInput>
    /**
     * In case the RolePermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionsUpdateInput, RolePermissionsUncheckedUpdateInput>
  }

  /**
   * RolePermissions delete
   */
  export type RolePermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
    /**
     * Filter which RolePermissions to delete.
     */
    where: RolePermissionsWhereUniqueInput
  }

  /**
   * RolePermissions deleteMany
   */
  export type RolePermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionsWhereInput
  }

  /**
   * RolePermissions without action
   */
  export type RolePermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermissions
     */
    select?: RolePermissionsSelect<ExtArgs> | null
  }


  /**
   * Model Settlement
   */

  export type AggregateSettlement = {
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  export type SettlementAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    processedBy: number | null
  }

  export type SettlementSumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    processedBy: number | null
  }

  export type SettlementMinAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    bankReference: string | null
    payoutDate: Date | null
    processedBy: number | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
    status: string | null
    paymentMethod: string | null
    bankReference: string | null
    payoutDate: Date | null
    processedBy: number | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettlementCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    status: number
    paymentMethod: number
    bankReference: number
    payoutDate: number
    processedBy: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettlementAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    processedBy?: true
  }

  export type SettlementSumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    processedBy?: true
  }

  export type SettlementMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    bankReference?: true
    payoutDate?: true
    processedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    bankReference?: true
    payoutDate?: true
    processedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettlementCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    status?: true
    paymentMethod?: true
    bankReference?: true
    payoutDate?: true
    processedBy?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlement to aggregate.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settlements
    **/
    _count?: true | SettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettlementMaxAggregateInputType
  }

  export type GetSettlementAggregateType<T extends SettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettlement[P]>
      : GetScalarType<T[P], AggregateSettlement[P]>
  }




  export type SettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettlementWhereInput
    orderBy?: SettlementOrderByWithAggregationInput | SettlementOrderByWithAggregationInput[]
    by: SettlementScalarFieldEnum[] | SettlementScalarFieldEnum
    having?: SettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettlementCountAggregateInputType | true
    _avg?: SettlementAvgAggregateInputType
    _sum?: SettlementSumAggregateInputType
    _min?: SettlementMinAggregateInputType
    _max?: SettlementMaxAggregateInputType
  }

  export type SettlementGroupByOutputType = {
    id: number
    userId: number
    amount: number
    status: string
    paymentMethod: string | null
    bankReference: string | null
    payoutDate: Date | null
    processedBy: number | null
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettlementCountAggregateOutputType | null
    _avg: SettlementAvgAggregateOutputType | null
    _sum: SettlementSumAggregateOutputType | null
    _min: SettlementMinAggregateOutputType | null
    _max: SettlementMaxAggregateOutputType | null
  }

  type GetSettlementGroupByPayload<T extends SettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SettlementGroupByOutputType[P]>
        }
      >
    >


  export type SettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    bankReference?: boolean
    payoutDate?: boolean
    processedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    bankReference?: boolean
    payoutDate?: boolean
    processedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settlement"]>

  export type SettlementSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    status?: boolean
    paymentMethod?: boolean
    bankReference?: boolean
    payoutDate?: boolean
    processedBy?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settlement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      amount: number
      status: string
      paymentMethod: string | null
      bankReference: string | null
      payoutDate: Date | null
      processedBy: number | null
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settlement"]>
    composites: {}
  }

  type SettlementGetPayload<S extends boolean | null | undefined | SettlementDefaultArgs> = $Result.GetResult<Prisma.$SettlementPayload, S>

  type SettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettlementCountAggregateInputType | true
    }

  export interface SettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settlement'], meta: { name: 'Settlement' } }
    /**
     * Find zero or one Settlement that matches the filter.
     * @param {SettlementFindUniqueArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettlementFindUniqueArgs>(args: SelectSubset<T, SettlementFindUniqueArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Settlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettlementFindUniqueOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettlementFindFirstArgs>(args?: SelectSubset<T, SettlementFindFirstArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Settlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindFirstOrThrowArgs} args - Arguments to find a Settlement
     * @example
     * // Get one Settlement
     * const settlement = await prisma.settlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settlements
     * const settlements = await prisma.settlement.findMany()
     * 
     * // Get first 10 Settlements
     * const settlements = await prisma.settlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settlementWithIdOnly = await prisma.settlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettlementFindManyArgs>(args?: SelectSubset<T, SettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Settlement.
     * @param {SettlementCreateArgs} args - Arguments to create a Settlement.
     * @example
     * // Create one Settlement
     * const Settlement = await prisma.settlement.create({
     *   data: {
     *     // ... data to create a Settlement
     *   }
     * })
     * 
     */
    create<T extends SettlementCreateArgs>(args: SelectSubset<T, SettlementCreateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settlements.
     * @param {SettlementCreateManyArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettlementCreateManyArgs>(args?: SelectSubset<T, SettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settlements and returns the data saved in the database.
     * @param {SettlementCreateManyAndReturnArgs} args - Arguments to create many Settlements.
     * @example
     * // Create many Settlements
     * const settlement = await prisma.settlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settlements and only return the `id`
     * const settlementWithIdOnly = await prisma.settlement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Settlement.
     * @param {SettlementDeleteArgs} args - Arguments to delete one Settlement.
     * @example
     * // Delete one Settlement
     * const Settlement = await prisma.settlement.delete({
     *   where: {
     *     // ... filter to delete one Settlement
     *   }
     * })
     * 
     */
    delete<T extends SettlementDeleteArgs>(args: SelectSubset<T, SettlementDeleteArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Settlement.
     * @param {SettlementUpdateArgs} args - Arguments to update one Settlement.
     * @example
     * // Update one Settlement
     * const settlement = await prisma.settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettlementUpdateArgs>(args: SelectSubset<T, SettlementUpdateArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settlements.
     * @param {SettlementDeleteManyArgs} args - Arguments to filter Settlements to delete.
     * @example
     * // Delete a few Settlements
     * const { count } = await prisma.settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettlementDeleteManyArgs>(args?: SelectSubset<T, SettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settlements
     * const settlement = await prisma.settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettlementUpdateManyArgs>(args: SelectSubset<T, SettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settlement.
     * @param {SettlementUpsertArgs} args - Arguments to update or create a Settlement.
     * @example
     * // Update or create a Settlement
     * const settlement = await prisma.settlement.upsert({
     *   create: {
     *     // ... data to create a Settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settlement we want to update
     *   }
     * })
     */
    upsert<T extends SettlementUpsertArgs>(args: SelectSubset<T, SettlementUpsertArgs<ExtArgs>>): Prisma__SettlementClient<$Result.GetResult<Prisma.$SettlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementCountArgs} args - Arguments to filter Settlements to count.
     * @example
     * // Count the number of Settlements
     * const count = await prisma.settlement.count({
     *   where: {
     *     // ... the filter for the Settlements we want to count
     *   }
     * })
    **/
    count<T extends SettlementCountArgs>(
      args?: Subset<T, SettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettlementAggregateArgs>(args: Subset<T, SettlementAggregateArgs>): Prisma.PrismaPromise<GetSettlementAggregateType<T>>

    /**
     * Group by Settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettlementGroupByArgs['orderBy'] }
        : { orderBy?: SettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settlement model
   */
  readonly fields: SettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settlement model
   */ 
  interface SettlementFieldRefs {
    readonly id: FieldRef<"Settlement", 'Int'>
    readonly userId: FieldRef<"Settlement", 'Int'>
    readonly amount: FieldRef<"Settlement", 'Float'>
    readonly status: FieldRef<"Settlement", 'String'>
    readonly paymentMethod: FieldRef<"Settlement", 'String'>
    readonly bankReference: FieldRef<"Settlement", 'String'>
    readonly payoutDate: FieldRef<"Settlement", 'DateTime'>
    readonly processedBy: FieldRef<"Settlement", 'Int'>
    readonly remarks: FieldRef<"Settlement", 'String'>
    readonly createdAt: FieldRef<"Settlement", 'DateTime'>
    readonly updatedAt: FieldRef<"Settlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settlement findUnique
   */
  export type SettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findUniqueOrThrow
   */
  export type SettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement findFirst
   */
  export type SettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findFirstOrThrow
   */
  export type SettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlement to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settlements.
     */
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement findMany
   */
  export type SettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter, which Settlements to fetch.
     */
    where?: SettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settlements to fetch.
     */
    orderBy?: SettlementOrderByWithRelationInput | SettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settlements.
     */
    cursor?: SettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settlements.
     */
    skip?: number
    distinct?: SettlementScalarFieldEnum | SettlementScalarFieldEnum[]
  }

  /**
   * Settlement create
   */
  export type SettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a Settlement.
     */
    data: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
  }

  /**
   * Settlement createMany
   */
  export type SettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settlement createManyAndReturn
   */
  export type SettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settlements.
     */
    data: SettlementCreateManyInput | SettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settlement update
   */
  export type SettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a Settlement.
     */
    data: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
    /**
     * Choose, which Settlement to update.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement updateMany
   */
  export type SettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settlements.
     */
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyInput>
    /**
     * Filter which Settlements to update
     */
    where?: SettlementWhereInput
  }

  /**
   * Settlement upsert
   */
  export type SettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the Settlement to update in case it exists.
     */
    where: SettlementWhereUniqueInput
    /**
     * In case the Settlement found by the `where` argument doesn't exist, create a new Settlement with this data.
     */
    create: XOR<SettlementCreateInput, SettlementUncheckedCreateInput>
    /**
     * In case the Settlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettlementUpdateInput, SettlementUncheckedUpdateInput>
  }

  /**
   * Settlement delete
   */
  export type SettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
    /**
     * Filter which Settlement to delete.
     */
    where: SettlementWhereUniqueInput
  }

  /**
   * Settlement deleteMany
   */
  export type SettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settlements to delete
     */
    where?: SettlementWhereInput
  }

  /**
   * Settlement without action
   */
  export type SettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settlement
     */
    select?: SettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettlementInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    uploadedBy: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    type: string | null
    category: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    isActive: boolean | null
    uploadedBy: number | null
    createdAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    type: string | null
    category: string | null
    fileUrl: string | null
    thumbnailUrl: string | null
    isActive: boolean | null
    uploadedBy: number | null
    createdAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    category: number
    fileUrl: number
    thumbnailUrl: number
    isActive: number
    uploadedBy: number
    createdAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    uploadedBy?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    uploadedBy?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    fileUrl?: true
    thumbnailUrl?: true
    isActive?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    fileUrl?: true
    thumbnailUrl?: true
    isActive?: true
    uploadedBy?: true
    createdAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    category?: true
    fileUrl?: true
    thumbnailUrl?: true
    isActive?: true
    uploadedBy?: true
    createdAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    title: string
    description: string | null
    type: string
    category: string
    fileUrl: string
    thumbnailUrl: string | null
    isActive: boolean
    uploadedBy: number
    createdAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isActive?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isActive?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    category?: boolean
    fileUrl?: boolean
    thumbnailUrl?: boolean
    isActive?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
  }


  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      type: string
      category: string
      fileUrl: string
      thumbnailUrl: string | null
      isActive: boolean
      uploadedBy: number
      createdAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly category: FieldRef<"Resource", 'String'>
    readonly fileUrl: FieldRef<"Resource", 'String'>
    readonly thumbnailUrl: FieldRef<"Resource", 'String'>
    readonly isActive: FieldRef<"Resource", 'Boolean'>
    readonly uploadedBy: FieldRef<"Resource", 'Int'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    adminId: number | null
    userId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    adminId: number | null
    userId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    adminId: number | null
    userId: number | null
    action: string | null
    module: string | null
    targetId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    adminId: number | null
    userId: number | null
    action: string | null
    module: string | null
    targetId: string | null
    description: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    adminId: number
    userId: number
    action: number
    module: number
    targetId: number
    description: number
    ipAddress: number
    userAgent: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    action?: true
    module?: true
    targetId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    action?: true
    module?: true
    targetId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    adminId?: true
    userId?: true
    action?: true
    module?: true
    targetId?: true
    description?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    adminId: number | null
    userId: number | null
    action: string
    module: string
    targetId: string | null
    description: string
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    metadata: JsonValue | null
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    targetId?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    targetId?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    targetId?: boolean
    description?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    metadata?: boolean
  }


  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminId: number | null
      userId: number | null
      action: string
      module: string
      targetId: string | null
      description: string
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly adminId: FieldRef<"ActivityLog", 'Int'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly module: FieldRef<"ActivityLog", 'String'>
    readonly targetId: FieldRef<"ActivityLog", 'String'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly userAgent: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly metadata: FieldRef<"ActivityLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
  }


  /**
   * Model SupportTicket
   */

  export type AggregateSupportTicket = {
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  export type SupportTicketAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedAdminId: number | null
    escalationLevel: number | null
  }

  export type SupportTicketSumAggregateOutputType = {
    id: number | null
    userId: number | null
    assignedAdminId: number | null
    escalationLevel: number | null
  }

  export type SupportTicketMinAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    category: string | null
    priority: string | null
    status: string | null
    assignedAdminId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    campus: string | null
    message: string | null
    resolvedAt: Date | null
    escalationLevel: number | null
    lastEscalatedAt: Date | null
  }

  export type SupportTicketMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    subject: string | null
    category: string | null
    priority: string | null
    status: string | null
    assignedAdminId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    campus: string | null
    message: string | null
    resolvedAt: Date | null
    escalationLevel: number | null
    lastEscalatedAt: Date | null
  }

  export type SupportTicketCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    category: number
    priority: number
    status: number
    assignedAdminId: number
    createdAt: number
    updatedAt: number
    campus: number
    message: number
    resolvedAt: number
    escalationLevel: number
    lastEscalatedAt: number
    _all: number
  }


  export type SupportTicketAvgAggregateInputType = {
    id?: true
    userId?: true
    assignedAdminId?: true
    escalationLevel?: true
  }

  export type SupportTicketSumAggregateInputType = {
    id?: true
    userId?: true
    assignedAdminId?: true
    escalationLevel?: true
  }

  export type SupportTicketMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
    campus?: true
    message?: true
    resolvedAt?: true
    escalationLevel?: true
    lastEscalatedAt?: true
  }

  export type SupportTicketMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
    campus?: true
    message?: true
    resolvedAt?: true
    escalationLevel?: true
    lastEscalatedAt?: true
  }

  export type SupportTicketCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    category?: true
    priority?: true
    status?: true
    assignedAdminId?: true
    createdAt?: true
    updatedAt?: true
    campus?: true
    message?: true
    resolvedAt?: true
    escalationLevel?: true
    lastEscalatedAt?: true
    _all?: true
  }

  export type SupportTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTicket to aggregate.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportTickets
    **/
    _count?: true | SupportTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportTicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportTicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportTicketMaxAggregateInputType
  }

  export type GetSupportTicketAggregateType<T extends SupportTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportTicket[P]>
      : GetScalarType<T[P], AggregateSupportTicket[P]>
  }




  export type SupportTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportTicketWhereInput
    orderBy?: SupportTicketOrderByWithAggregationInput | SupportTicketOrderByWithAggregationInput[]
    by: SupportTicketScalarFieldEnum[] | SupportTicketScalarFieldEnum
    having?: SupportTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportTicketCountAggregateInputType | true
    _avg?: SupportTicketAvgAggregateInputType
    _sum?: SupportTicketSumAggregateInputType
    _min?: SupportTicketMinAggregateInputType
    _max?: SupportTicketMaxAggregateInputType
  }

  export type SupportTicketGroupByOutputType = {
    id: number
    userId: number
    subject: string
    category: string
    priority: string
    status: string
    assignedAdminId: number | null
    createdAt: Date
    updatedAt: Date
    campus: string | null
    message: string
    resolvedAt: Date | null
    escalationLevel: number
    lastEscalatedAt: Date | null
    _count: SupportTicketCountAggregateOutputType | null
    _avg: SupportTicketAvgAggregateOutputType | null
    _sum: SupportTicketSumAggregateOutputType | null
    _min: SupportTicketMinAggregateOutputType | null
    _max: SupportTicketMaxAggregateOutputType | null
  }

  type GetSupportTicketGroupByPayload<T extends SupportTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
            : GetScalarType<T[P], SupportTicketGroupByOutputType[P]>
        }
      >
    >


  export type SupportTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campus?: boolean
    message?: boolean
    resolvedAt?: boolean
    escalationLevel?: boolean
    lastEscalatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campus?: boolean
    message?: boolean
    resolvedAt?: boolean
    escalationLevel?: boolean
    lastEscalatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportTicket"]>

  export type SupportTicketSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    category?: boolean
    priority?: boolean
    status?: boolean
    assignedAdminId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campus?: boolean
    message?: boolean
    resolvedAt?: boolean
    escalationLevel?: boolean
    lastEscalatedAt?: boolean
  }

  export type SupportTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportTicket$messagesArgs<ExtArgs>
    _count?: boolean | SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportTicket"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$TicketMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      subject: string
      category: string
      priority: string
      status: string
      assignedAdminId: number | null
      createdAt: Date
      updatedAt: Date
      campus: string | null
      message: string
      resolvedAt: Date | null
      escalationLevel: number
      lastEscalatedAt: Date | null
    }, ExtArgs["result"]["supportTicket"]>
    composites: {}
  }

  type SupportTicketGetPayload<S extends boolean | null | undefined | SupportTicketDefaultArgs> = $Result.GetResult<Prisma.$SupportTicketPayload, S>

  type SupportTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupportTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupportTicketCountAggregateInputType | true
    }

  export interface SupportTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportTicket'], meta: { name: 'SupportTicket' } }
    /**
     * Find zero or one SupportTicket that matches the filter.
     * @param {SupportTicketFindUniqueArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportTicketFindUniqueArgs>(args: SelectSubset<T, SupportTicketFindUniqueArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SupportTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupportTicketFindUniqueOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportTicketFindFirstArgs>(args?: SelectSubset<T, SupportTicketFindFirstArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SupportTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindFirstOrThrowArgs} args - Arguments to find a SupportTicket
     * @example
     * // Get one SupportTicket
     * const supportTicket = await prisma.supportTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SupportTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany()
     * 
     * // Get first 10 SupportTickets
     * const supportTickets = await prisma.supportTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportTicketFindManyArgs>(args?: SelectSubset<T, SupportTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SupportTicket.
     * @param {SupportTicketCreateArgs} args - Arguments to create a SupportTicket.
     * @example
     * // Create one SupportTicket
     * const SupportTicket = await prisma.supportTicket.create({
     *   data: {
     *     // ... data to create a SupportTicket
     *   }
     * })
     * 
     */
    create<T extends SupportTicketCreateArgs>(args: SelectSubset<T, SupportTicketCreateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SupportTickets.
     * @param {SupportTicketCreateManyArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportTicketCreateManyArgs>(args?: SelectSubset<T, SupportTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportTickets and returns the data saved in the database.
     * @param {SupportTicketCreateManyAndReturnArgs} args - Arguments to create many SupportTickets.
     * @example
     * // Create many SupportTickets
     * const supportTicket = await prisma.supportTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportTickets and only return the `id`
     * const supportTicketWithIdOnly = await prisma.supportTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SupportTicket.
     * @param {SupportTicketDeleteArgs} args - Arguments to delete one SupportTicket.
     * @example
     * // Delete one SupportTicket
     * const SupportTicket = await prisma.supportTicket.delete({
     *   where: {
     *     // ... filter to delete one SupportTicket
     *   }
     * })
     * 
     */
    delete<T extends SupportTicketDeleteArgs>(args: SelectSubset<T, SupportTicketDeleteArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SupportTicket.
     * @param {SupportTicketUpdateArgs} args - Arguments to update one SupportTicket.
     * @example
     * // Update one SupportTicket
     * const supportTicket = await prisma.supportTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportTicketUpdateArgs>(args: SelectSubset<T, SupportTicketUpdateArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SupportTickets.
     * @param {SupportTicketDeleteManyArgs} args - Arguments to filter SupportTickets to delete.
     * @example
     * // Delete a few SupportTickets
     * const { count } = await prisma.supportTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportTicketDeleteManyArgs>(args?: SelectSubset<T, SupportTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportTickets
     * const supportTicket = await prisma.supportTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportTicketUpdateManyArgs>(args: SelectSubset<T, SupportTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupportTicket.
     * @param {SupportTicketUpsertArgs} args - Arguments to update or create a SupportTicket.
     * @example
     * // Update or create a SupportTicket
     * const supportTicket = await prisma.supportTicket.upsert({
     *   create: {
     *     // ... data to create a SupportTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportTicket we want to update
     *   }
     * })
     */
    upsert<T extends SupportTicketUpsertArgs>(args: SelectSubset<T, SupportTicketUpsertArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SupportTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketCountArgs} args - Arguments to filter SupportTickets to count.
     * @example
     * // Count the number of SupportTickets
     * const count = await prisma.supportTicket.count({
     *   where: {
     *     // ... the filter for the SupportTickets we want to count
     *   }
     * })
    **/
    count<T extends SupportTicketCountArgs>(
      args?: Subset<T, SupportTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportTicketAggregateArgs>(args: Subset<T, SupportTicketAggregateArgs>): Prisma.PrismaPromise<GetSupportTicketAggregateType<T>>

    /**
     * Group by SupportTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportTicketGroupByArgs['orderBy'] }
        : { orderBy?: SupportTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportTicket model
   */
  readonly fields: SupportTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends SupportTicket$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicket$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportTicket model
   */ 
  interface SupportTicketFieldRefs {
    readonly id: FieldRef<"SupportTicket", 'Int'>
    readonly userId: FieldRef<"SupportTicket", 'Int'>
    readonly subject: FieldRef<"SupportTicket", 'String'>
    readonly category: FieldRef<"SupportTicket", 'String'>
    readonly priority: FieldRef<"SupportTicket", 'String'>
    readonly status: FieldRef<"SupportTicket", 'String'>
    readonly assignedAdminId: FieldRef<"SupportTicket", 'Int'>
    readonly createdAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly campus: FieldRef<"SupportTicket", 'String'>
    readonly message: FieldRef<"SupportTicket", 'String'>
    readonly resolvedAt: FieldRef<"SupportTicket", 'DateTime'>
    readonly escalationLevel: FieldRef<"SupportTicket", 'Int'>
    readonly lastEscalatedAt: FieldRef<"SupportTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportTicket findUnique
   */
  export type SupportTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findUniqueOrThrow
   */
  export type SupportTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket findFirst
   */
  export type SupportTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findFirstOrThrow
   */
  export type SupportTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTicket to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportTickets.
     */
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket findMany
   */
  export type SupportTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter, which SupportTickets to fetch.
     */
    where?: SupportTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportTickets to fetch.
     */
    orderBy?: SupportTicketOrderByWithRelationInput | SupportTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportTickets.
     */
    cursor?: SupportTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportTickets.
     */
    skip?: number
    distinct?: SupportTicketScalarFieldEnum | SupportTicketScalarFieldEnum[]
  }

  /**
   * SupportTicket create
   */
  export type SupportTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportTicket.
     */
    data: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
  }

  /**
   * SupportTicket createMany
   */
  export type SupportTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportTicket createManyAndReturn
   */
  export type SupportTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SupportTickets.
     */
    data: SupportTicketCreateManyInput | SupportTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportTicket update
   */
  export type SupportTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportTicket.
     */
    data: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
    /**
     * Choose, which SupportTicket to update.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket updateMany
   */
  export type SupportTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportTickets.
     */
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyInput>
    /**
     * Filter which SupportTickets to update
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket upsert
   */
  export type SupportTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportTicket to update in case it exists.
     */
    where: SupportTicketWhereUniqueInput
    /**
     * In case the SupportTicket found by the `where` argument doesn't exist, create a new SupportTicket with this data.
     */
    create: XOR<SupportTicketCreateInput, SupportTicketUncheckedCreateInput>
    /**
     * In case the SupportTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportTicketUpdateInput, SupportTicketUncheckedUpdateInput>
  }

  /**
   * SupportTicket delete
   */
  export type SupportTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
    /**
     * Filter which SupportTicket to delete.
     */
    where: SupportTicketWhereUniqueInput
  }

  /**
   * SupportTicket deleteMany
   */
  export type SupportTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportTickets to delete
     */
    where?: SupportTicketWhereInput
  }

  /**
   * SupportTicket.messages
   */
  export type SupportTicket$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    cursor?: TicketMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * SupportTicket without action
   */
  export type SupportTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportTicket
     */
    select?: SupportTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportTicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketMessage
   */

  export type AggregateTicketMessage = {
    _count: TicketMessageCountAggregateOutputType | null
    _avg: TicketMessageAvgAggregateOutputType | null
    _sum: TicketMessageSumAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  export type TicketMessageAvgAggregateOutputType = {
    id: number | null
    ticketId: number | null
    senderId: number | null
  }

  export type TicketMessageSumAggregateOutputType = {
    id: number | null
    ticketId: number | null
    senderId: number | null
  }

  export type TicketMessageMinAggregateOutputType = {
    id: number | null
    ticketId: number | null
    senderId: number | null
    senderType: string | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type TicketMessageMaxAggregateOutputType = {
    id: number | null
    ticketId: number | null
    senderId: number | null
    senderType: string | null
    message: string | null
    isInternal: boolean | null
    createdAt: Date | null
  }

  export type TicketMessageCountAggregateOutputType = {
    id: number
    ticketId: number
    senderId: number
    senderType: number
    message: number
    isInternal: number
    createdAt: number
    _all: number
  }


  export type TicketMessageAvgAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
  }

  export type TicketMessageSumAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
  }

  export type TicketMessageMinAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type TicketMessageMaxAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
  }

  export type TicketMessageCountAggregateInputType = {
    id?: true
    ticketId?: true
    senderId?: true
    senderType?: true
    message?: true
    isInternal?: true
    createdAt?: true
    _all?: true
  }

  export type TicketMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessage to aggregate.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketMessages
    **/
    _count?: true | TicketMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMessageMaxAggregateInputType
  }

  export type GetTicketMessageAggregateType<T extends TicketMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketMessage[P]>
      : GetScalarType<T[P], AggregateTicketMessage[P]>
  }




  export type TicketMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMessageWhereInput
    orderBy?: TicketMessageOrderByWithAggregationInput | TicketMessageOrderByWithAggregationInput[]
    by: TicketMessageScalarFieldEnum[] | TicketMessageScalarFieldEnum
    having?: TicketMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketMessageCountAggregateInputType | true
    _avg?: TicketMessageAvgAggregateInputType
    _sum?: TicketMessageSumAggregateInputType
    _min?: TicketMessageMinAggregateInputType
    _max?: TicketMessageMaxAggregateInputType
  }

  export type TicketMessageGroupByOutputType = {
    id: number
    ticketId: number
    senderId: number
    senderType: string
    message: string
    isInternal: boolean
    createdAt: Date
    _count: TicketMessageCountAggregateOutputType | null
    _avg: TicketMessageAvgAggregateOutputType | null
    _sum: TicketMessageSumAggregateOutputType | null
    _min: TicketMessageMinAggregateOutputType | null
    _max: TicketMessageMaxAggregateOutputType | null
  }

  type GetTicketMessageGroupByPayload<T extends TicketMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
            : GetScalarType<T[P], TicketMessageGroupByOutputType[P]>
        }
      >
    >


  export type TicketMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMessage"]>

  export type TicketMessageSelectScalar = {
    id?: boolean
    ticketId?: boolean
    senderId?: boolean
    senderType?: boolean
    message?: boolean
    isInternal?: boolean
    createdAt?: boolean
  }

  export type TicketMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }
  export type TicketMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | SupportTicketDefaultArgs<ExtArgs>
  }

  export type $TicketMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketMessage"
    objects: {
      ticket: Prisma.$SupportTicketPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ticketId: number
      senderId: number
      senderType: string
      message: string
      isInternal: boolean
      createdAt: Date
    }, ExtArgs["result"]["ticketMessage"]>
    composites: {}
  }

  type TicketMessageGetPayload<S extends boolean | null | undefined | TicketMessageDefaultArgs> = $Result.GetResult<Prisma.$TicketMessagePayload, S>

  type TicketMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TicketMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TicketMessageCountAggregateInputType | true
    }

  export interface TicketMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketMessage'], meta: { name: 'TicketMessage' } }
    /**
     * Find zero or one TicketMessage that matches the filter.
     * @param {TicketMessageFindUniqueArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketMessageFindUniqueArgs>(args: SelectSubset<T, TicketMessageFindUniqueArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TicketMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TicketMessageFindUniqueOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketMessageFindFirstArgs>(args?: SelectSubset<T, TicketMessageFindFirstArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TicketMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindFirstOrThrowArgs} args - Arguments to find a TicketMessage
     * @example
     * // Get one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TicketMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany()
     * 
     * // Get first 10 TicketMessages
     * const ticketMessages = await prisma.ticketMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketMessageFindManyArgs>(args?: SelectSubset<T, TicketMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TicketMessage.
     * @param {TicketMessageCreateArgs} args - Arguments to create a TicketMessage.
     * @example
     * // Create one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.create({
     *   data: {
     *     // ... data to create a TicketMessage
     *   }
     * })
     * 
     */
    create<T extends TicketMessageCreateArgs>(args: SelectSubset<T, TicketMessageCreateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TicketMessages.
     * @param {TicketMessageCreateManyArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketMessageCreateManyArgs>(args?: SelectSubset<T, TicketMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketMessages and returns the data saved in the database.
     * @param {TicketMessageCreateManyAndReturnArgs} args - Arguments to create many TicketMessages.
     * @example
     * // Create many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketMessages and only return the `id`
     * const ticketMessageWithIdOnly = await prisma.ticketMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TicketMessage.
     * @param {TicketMessageDeleteArgs} args - Arguments to delete one TicketMessage.
     * @example
     * // Delete one TicketMessage
     * const TicketMessage = await prisma.ticketMessage.delete({
     *   where: {
     *     // ... filter to delete one TicketMessage
     *   }
     * })
     * 
     */
    delete<T extends TicketMessageDeleteArgs>(args: SelectSubset<T, TicketMessageDeleteArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TicketMessage.
     * @param {TicketMessageUpdateArgs} args - Arguments to update one TicketMessage.
     * @example
     * // Update one TicketMessage
     * const ticketMessage = await prisma.ticketMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketMessageUpdateArgs>(args: SelectSubset<T, TicketMessageUpdateArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TicketMessages.
     * @param {TicketMessageDeleteManyArgs} args - Arguments to filter TicketMessages to delete.
     * @example
     * // Delete a few TicketMessages
     * const { count } = await prisma.ticketMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketMessageDeleteManyArgs>(args?: SelectSubset<T, TicketMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketMessages
     * const ticketMessage = await prisma.ticketMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketMessageUpdateManyArgs>(args: SelectSubset<T, TicketMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TicketMessage.
     * @param {TicketMessageUpsertArgs} args - Arguments to update or create a TicketMessage.
     * @example
     * // Update or create a TicketMessage
     * const ticketMessage = await prisma.ticketMessage.upsert({
     *   create: {
     *     // ... data to create a TicketMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketMessage we want to update
     *   }
     * })
     */
    upsert<T extends TicketMessageUpsertArgs>(args: SelectSubset<T, TicketMessageUpsertArgs<ExtArgs>>): Prisma__TicketMessageClient<$Result.GetResult<Prisma.$TicketMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TicketMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageCountArgs} args - Arguments to filter TicketMessages to count.
     * @example
     * // Count the number of TicketMessages
     * const count = await prisma.ticketMessage.count({
     *   where: {
     *     // ... the filter for the TicketMessages we want to count
     *   }
     * })
    **/
    count<T extends TicketMessageCountArgs>(
      args?: Subset<T, TicketMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketMessageAggregateArgs>(args: Subset<T, TicketMessageAggregateArgs>): Prisma.PrismaPromise<GetTicketMessageAggregateType<T>>

    /**
     * Group by TicketMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketMessageGroupByArgs['orderBy'] }
        : { orderBy?: TicketMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketMessage model
   */
  readonly fields: TicketMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends SupportTicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportTicketDefaultArgs<ExtArgs>>): Prisma__SupportTicketClient<$Result.GetResult<Prisma.$SupportTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketMessage model
   */ 
  interface TicketMessageFieldRefs {
    readonly id: FieldRef<"TicketMessage", 'Int'>
    readonly ticketId: FieldRef<"TicketMessage", 'Int'>
    readonly senderId: FieldRef<"TicketMessage", 'Int'>
    readonly senderType: FieldRef<"TicketMessage", 'String'>
    readonly message: FieldRef<"TicketMessage", 'String'>
    readonly isInternal: FieldRef<"TicketMessage", 'Boolean'>
    readonly createdAt: FieldRef<"TicketMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketMessage findUnique
   */
  export type TicketMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findUniqueOrThrow
   */
  export type TicketMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage findFirst
   */
  export type TicketMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findFirstOrThrow
   */
  export type TicketMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessage to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMessages.
     */
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage findMany
   */
  export type TicketMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter, which TicketMessages to fetch.
     */
    where?: TicketMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMessages to fetch.
     */
    orderBy?: TicketMessageOrderByWithRelationInput | TicketMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketMessages.
     */
    cursor?: TicketMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMessages.
     */
    skip?: number
    distinct?: TicketMessageScalarFieldEnum | TicketMessageScalarFieldEnum[]
  }

  /**
   * TicketMessage create
   */
  export type TicketMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketMessage.
     */
    data: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
  }

  /**
   * TicketMessage createMany
   */
  export type TicketMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketMessage createManyAndReturn
   */
  export type TicketMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TicketMessages.
     */
    data: TicketMessageCreateManyInput | TicketMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMessage update
   */
  export type TicketMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketMessage.
     */
    data: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
    /**
     * Choose, which TicketMessage to update.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage updateMany
   */
  export type TicketMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketMessages.
     */
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyInput>
    /**
     * Filter which TicketMessages to update
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage upsert
   */
  export type TicketMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketMessage to update in case it exists.
     */
    where: TicketMessageWhereUniqueInput
    /**
     * In case the TicketMessage found by the `where` argument doesn't exist, create a new TicketMessage with this data.
     */
    create: XOR<TicketMessageCreateInput, TicketMessageUncheckedCreateInput>
    /**
     * In case the TicketMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketMessageUpdateInput, TicketMessageUncheckedUpdateInput>
  }

  /**
   * TicketMessage delete
   */
  export type TicketMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
    /**
     * Filter which TicketMessage to delete.
     */
    where: TicketMessageWhereUniqueInput
  }

  /**
   * TicketMessage deleteMany
   */
  export type TicketMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMessages to delete
     */
    where?: TicketMessageWhereInput
  }

  /**
   * TicketMessage without action
   */
  export type TicketMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMessage
     */
    select?: TicketMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMessageInclude<ExtArgs> | null
  }


  /**
   * Model Campus
   */

  export type AggregateCampus = {
    _count: CampusCountAggregateOutputType | null
    _avg: CampusAvgAggregateOutputType | null
    _sum: CampusSumAggregateOutputType | null
    _min: CampusMinAggregateOutputType | null
    _max: CampusMaxAggregateOutputType | null
  }

  export type CampusAvgAggregateOutputType = {
    id: number | null
    maxCapacity: number | null
    currentEnrollment: number | null
    campusHeadId: number | null
  }

  export type CampusSumAggregateOutputType = {
    id: number | null
    maxCapacity: number | null
    currentEnrollment: number | null
    campusHeadId: number | null
  }

  export type CampusMinAggregateOutputType = {
    id: number | null
    campusName: string | null
    campusCode: string | null
    location: string | null
    grades: string | null
    maxCapacity: number | null
    currentEnrollment: number | null
    isActive: boolean | null
    campusHeadId: number | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampusMaxAggregateOutputType = {
    id: number | null
    campusName: string | null
    campusCode: string | null
    location: string | null
    grades: string | null
    maxCapacity: number | null
    currentEnrollment: number | null
    isActive: boolean | null
    campusHeadId: number | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampusCountAggregateOutputType = {
    id: number
    campusName: number
    campusCode: number
    location: number
    grades: number
    maxCapacity: number
    currentEnrollment: number
    isActive: number
    campusHeadId: number
    contactEmail: number
    contactPhone: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampusAvgAggregateInputType = {
    id?: true
    maxCapacity?: true
    currentEnrollment?: true
    campusHeadId?: true
  }

  export type CampusSumAggregateInputType = {
    id?: true
    maxCapacity?: true
    currentEnrollment?: true
    campusHeadId?: true
  }

  export type CampusMinAggregateInputType = {
    id?: true
    campusName?: true
    campusCode?: true
    location?: true
    grades?: true
    maxCapacity?: true
    currentEnrollment?: true
    isActive?: true
    campusHeadId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampusMaxAggregateInputType = {
    id?: true
    campusName?: true
    campusCode?: true
    location?: true
    grades?: true
    maxCapacity?: true
    currentEnrollment?: true
    isActive?: true
    campusHeadId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampusCountAggregateInputType = {
    id?: true
    campusName?: true
    campusCode?: true
    location?: true
    grades?: true
    maxCapacity?: true
    currentEnrollment?: true
    isActive?: true
    campusHeadId?: true
    contactEmail?: true
    contactPhone?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campus to aggregate.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campuses
    **/
    _count?: true | CampusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampusMaxAggregateInputType
  }

  export type GetCampusAggregateType<T extends CampusAggregateArgs> = {
        [P in keyof T & keyof AggregateCampus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampus[P]>
      : GetScalarType<T[P], AggregateCampus[P]>
  }




  export type CampusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampusWhereInput
    orderBy?: CampusOrderByWithAggregationInput | CampusOrderByWithAggregationInput[]
    by: CampusScalarFieldEnum[] | CampusScalarFieldEnum
    having?: CampusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampusCountAggregateInputType | true
    _avg?: CampusAvgAggregateInputType
    _sum?: CampusSumAggregateInputType
    _min?: CampusMinAggregateInputType
    _max?: CampusMaxAggregateInputType
  }

  export type CampusGroupByOutputType = {
    id: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity: number
    currentEnrollment: number
    isActive: boolean
    campusHeadId: number | null
    contactEmail: string | null
    contactPhone: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: CampusCountAggregateOutputType | null
    _avg: CampusAvgAggregateOutputType | null
    _sum: CampusSumAggregateOutputType | null
    _min: CampusMinAggregateOutputType | null
    _max: CampusMaxAggregateOutputType | null
  }

  type GetCampusGroupByPayload<T extends CampusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampusGroupByOutputType[P]>
            : GetScalarType<T[P], CampusGroupByOutputType[P]>
        }
      >
    >


  export type CampusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campusName?: boolean
    campusCode?: boolean
    location?: boolean
    grades?: boolean
    maxCapacity?: boolean
    currentEnrollment?: boolean
    isActive?: boolean
    campusHeadId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    targets?: boolean | Campus$targetsArgs<ExtArgs>
    gradeFees?: boolean | Campus$gradeFeesArgs<ExtArgs>
    students?: boolean | Campus$studentsArgs<ExtArgs>
    _count?: boolean | CampusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campus"]>

  export type CampusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campusName?: boolean
    campusCode?: boolean
    location?: boolean
    grades?: boolean
    maxCapacity?: boolean
    currentEnrollment?: boolean
    isActive?: boolean
    campusHeadId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["campus"]>

  export type CampusSelectScalar = {
    id?: boolean
    campusName?: boolean
    campusCode?: boolean
    location?: boolean
    grades?: boolean
    maxCapacity?: boolean
    currentEnrollment?: boolean
    isActive?: boolean
    campusHeadId?: boolean
    contactEmail?: boolean
    contactPhone?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    targets?: boolean | Campus$targetsArgs<ExtArgs>
    gradeFees?: boolean | Campus$gradeFeesArgs<ExtArgs>
    students?: boolean | Campus$studentsArgs<ExtArgs>
    _count?: boolean | CampusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campus"
    objects: {
      targets: Prisma.$CampusTargetPayload<ExtArgs>[]
      gradeFees: Prisma.$GradeFeePayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      campusName: string
      campusCode: string
      location: string
      grades: string
      maxCapacity: number
      currentEnrollment: number
      isActive: boolean
      campusHeadId: number | null
      contactEmail: string | null
      contactPhone: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campus"]>
    composites: {}
  }

  type CampusGetPayload<S extends boolean | null | undefined | CampusDefaultArgs> = $Result.GetResult<Prisma.$CampusPayload, S>

  type CampusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampusCountAggregateInputType | true
    }

  export interface CampusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campus'], meta: { name: 'Campus' } }
    /**
     * Find zero or one Campus that matches the filter.
     * @param {CampusFindUniqueArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampusFindUniqueArgs>(args: SelectSubset<T, CampusFindUniqueArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampusFindUniqueOrThrowArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampusFindUniqueOrThrowArgs>(args: SelectSubset<T, CampusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindFirstArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampusFindFirstArgs>(args?: SelectSubset<T, CampusFindFirstArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindFirstOrThrowArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampusFindFirstOrThrowArgs>(args?: SelectSubset<T, CampusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campuses
     * const campuses = await prisma.campus.findMany()
     * 
     * // Get first 10 Campuses
     * const campuses = await prisma.campus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campusWithIdOnly = await prisma.campus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampusFindManyArgs>(args?: SelectSubset<T, CampusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campus.
     * @param {CampusCreateArgs} args - Arguments to create a Campus.
     * @example
     * // Create one Campus
     * const Campus = await prisma.campus.create({
     *   data: {
     *     // ... data to create a Campus
     *   }
     * })
     * 
     */
    create<T extends CampusCreateArgs>(args: SelectSubset<T, CampusCreateArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campuses.
     * @param {CampusCreateManyArgs} args - Arguments to create many Campuses.
     * @example
     * // Create many Campuses
     * const campus = await prisma.campus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampusCreateManyArgs>(args?: SelectSubset<T, CampusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campuses and returns the data saved in the database.
     * @param {CampusCreateManyAndReturnArgs} args - Arguments to create many Campuses.
     * @example
     * // Create many Campuses
     * const campus = await prisma.campus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campuses and only return the `id`
     * const campusWithIdOnly = await prisma.campus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampusCreateManyAndReturnArgs>(args?: SelectSubset<T, CampusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campus.
     * @param {CampusDeleteArgs} args - Arguments to delete one Campus.
     * @example
     * // Delete one Campus
     * const Campus = await prisma.campus.delete({
     *   where: {
     *     // ... filter to delete one Campus
     *   }
     * })
     * 
     */
    delete<T extends CampusDeleteArgs>(args: SelectSubset<T, CampusDeleteArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campus.
     * @param {CampusUpdateArgs} args - Arguments to update one Campus.
     * @example
     * // Update one Campus
     * const campus = await prisma.campus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampusUpdateArgs>(args: SelectSubset<T, CampusUpdateArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campuses.
     * @param {CampusDeleteManyArgs} args - Arguments to filter Campuses to delete.
     * @example
     * // Delete a few Campuses
     * const { count } = await prisma.campus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampusDeleteManyArgs>(args?: SelectSubset<T, CampusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campuses
     * const campus = await prisma.campus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampusUpdateManyArgs>(args: SelectSubset<T, CampusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campus.
     * @param {CampusUpsertArgs} args - Arguments to update or create a Campus.
     * @example
     * // Update or create a Campus
     * const campus = await prisma.campus.upsert({
     *   create: {
     *     // ... data to create a Campus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campus we want to update
     *   }
     * })
     */
    upsert<T extends CampusUpsertArgs>(args: SelectSubset<T, CampusUpsertArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusCountArgs} args - Arguments to filter Campuses to count.
     * @example
     * // Count the number of Campuses
     * const count = await prisma.campus.count({
     *   where: {
     *     // ... the filter for the Campuses we want to count
     *   }
     * })
    **/
    count<T extends CampusCountArgs>(
      args?: Subset<T, CampusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampusAggregateArgs>(args: Subset<T, CampusAggregateArgs>): Prisma.PrismaPromise<GetCampusAggregateType<T>>

    /**
     * Group by Campus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampusGroupByArgs['orderBy'] }
        : { orderBy?: CampusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campus model
   */
  readonly fields: CampusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    targets<T extends Campus$targetsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$targetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findMany"> | Null>
    gradeFees<T extends Campus$gradeFeesArgs<ExtArgs> = {}>(args?: Subset<T, Campus$gradeFeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Campus$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campus model
   */ 
  interface CampusFieldRefs {
    readonly id: FieldRef<"Campus", 'Int'>
    readonly campusName: FieldRef<"Campus", 'String'>
    readonly campusCode: FieldRef<"Campus", 'String'>
    readonly location: FieldRef<"Campus", 'String'>
    readonly grades: FieldRef<"Campus", 'String'>
    readonly maxCapacity: FieldRef<"Campus", 'Int'>
    readonly currentEnrollment: FieldRef<"Campus", 'Int'>
    readonly isActive: FieldRef<"Campus", 'Boolean'>
    readonly campusHeadId: FieldRef<"Campus", 'Int'>
    readonly contactEmail: FieldRef<"Campus", 'String'>
    readonly contactPhone: FieldRef<"Campus", 'String'>
    readonly address: FieldRef<"Campus", 'String'>
    readonly createdAt: FieldRef<"Campus", 'DateTime'>
    readonly updatedAt: FieldRef<"Campus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campus findUnique
   */
  export type CampusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus findUniqueOrThrow
   */
  export type CampusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus findFirst
   */
  export type CampusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campuses.
     */
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus findFirstOrThrow
   */
  export type CampusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campuses.
     */
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus findMany
   */
  export type CampusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campuses to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus create
   */
  export type CampusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The data needed to create a Campus.
     */
    data: XOR<CampusCreateInput, CampusUncheckedCreateInput>
  }

  /**
   * Campus createMany
   */
  export type CampusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campuses.
     */
    data: CampusCreateManyInput | CampusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campus createManyAndReturn
   */
  export type CampusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campuses.
     */
    data: CampusCreateManyInput | CampusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campus update
   */
  export type CampusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The data needed to update a Campus.
     */
    data: XOR<CampusUpdateInput, CampusUncheckedUpdateInput>
    /**
     * Choose, which Campus to update.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus updateMany
   */
  export type CampusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campuses.
     */
    data: XOR<CampusUpdateManyMutationInput, CampusUncheckedUpdateManyInput>
    /**
     * Filter which Campuses to update
     */
    where?: CampusWhereInput
  }

  /**
   * Campus upsert
   */
  export type CampusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The filter to search for the Campus to update in case it exists.
     */
    where: CampusWhereUniqueInput
    /**
     * In case the Campus found by the `where` argument doesn't exist, create a new Campus with this data.
     */
    create: XOR<CampusCreateInput, CampusUncheckedCreateInput>
    /**
     * In case the Campus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampusUpdateInput, CampusUncheckedUpdateInput>
  }

  /**
   * Campus delete
   */
  export type CampusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter which Campus to delete.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus deleteMany
   */
  export type CampusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campuses to delete
     */
    where?: CampusWhereInput
  }

  /**
   * Campus.targets
   */
  export type Campus$targetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    where?: CampusTargetWhereInput
    orderBy?: CampusTargetOrderByWithRelationInput | CampusTargetOrderByWithRelationInput[]
    cursor?: CampusTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampusTargetScalarFieldEnum | CampusTargetScalarFieldEnum[]
  }

  /**
   * Campus.gradeFees
   */
  export type Campus$gradeFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    where?: GradeFeeWhereInput
    orderBy?: GradeFeeOrderByWithRelationInput | GradeFeeOrderByWithRelationInput[]
    cursor?: GradeFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeFeeScalarFieldEnum | GradeFeeScalarFieldEnum[]
  }

  /**
   * Campus.students
   */
  export type Campus$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Campus without action
   */
  export type CampusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
  }


  /**
   * Model CampusTarget
   */

  export type AggregateCampusTarget = {
    _count: CampusTargetCountAggregateOutputType | null
    _avg: CampusTargetAvgAggregateOutputType | null
    _sum: CampusTargetSumAggregateOutputType | null
    _min: CampusTargetMinAggregateOutputType | null
    _max: CampusTargetMaxAggregateOutputType | null
  }

  export type CampusTargetAvgAggregateOutputType = {
    id: number | null
    campusId: number | null
    month: number | null
    year: number | null
    leadTarget: number | null
    admissionTarget: number | null
  }

  export type CampusTargetSumAggregateOutputType = {
    id: number | null
    campusId: number | null
    month: number | null
    year: number | null
    leadTarget: number | null
    admissionTarget: number | null
  }

  export type CampusTargetMinAggregateOutputType = {
    id: number | null
    campusId: number | null
    month: number | null
    year: number | null
    leadTarget: number | null
    admissionTarget: number | null
    updatedAt: Date | null
  }

  export type CampusTargetMaxAggregateOutputType = {
    id: number | null
    campusId: number | null
    month: number | null
    year: number | null
    leadTarget: number | null
    admissionTarget: number | null
    updatedAt: Date | null
  }

  export type CampusTargetCountAggregateOutputType = {
    id: number
    campusId: number
    month: number
    year: number
    leadTarget: number
    admissionTarget: number
    updatedAt: number
    _all: number
  }


  export type CampusTargetAvgAggregateInputType = {
    id?: true
    campusId?: true
    month?: true
    year?: true
    leadTarget?: true
    admissionTarget?: true
  }

  export type CampusTargetSumAggregateInputType = {
    id?: true
    campusId?: true
    month?: true
    year?: true
    leadTarget?: true
    admissionTarget?: true
  }

  export type CampusTargetMinAggregateInputType = {
    id?: true
    campusId?: true
    month?: true
    year?: true
    leadTarget?: true
    admissionTarget?: true
    updatedAt?: true
  }

  export type CampusTargetMaxAggregateInputType = {
    id?: true
    campusId?: true
    month?: true
    year?: true
    leadTarget?: true
    admissionTarget?: true
    updatedAt?: true
  }

  export type CampusTargetCountAggregateInputType = {
    id?: true
    campusId?: true
    month?: true
    year?: true
    leadTarget?: true
    admissionTarget?: true
    updatedAt?: true
    _all?: true
  }

  export type CampusTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampusTarget to aggregate.
     */
    where?: CampusTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampusTargets to fetch.
     */
    orderBy?: CampusTargetOrderByWithRelationInput | CampusTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampusTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampusTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampusTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampusTargets
    **/
    _count?: true | CampusTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampusTargetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampusTargetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampusTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampusTargetMaxAggregateInputType
  }

  export type GetCampusTargetAggregateType<T extends CampusTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateCampusTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampusTarget[P]>
      : GetScalarType<T[P], AggregateCampusTarget[P]>
  }




  export type CampusTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampusTargetWhereInput
    orderBy?: CampusTargetOrderByWithAggregationInput | CampusTargetOrderByWithAggregationInput[]
    by: CampusTargetScalarFieldEnum[] | CampusTargetScalarFieldEnum
    having?: CampusTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampusTargetCountAggregateInputType | true
    _avg?: CampusTargetAvgAggregateInputType
    _sum?: CampusTargetSumAggregateInputType
    _min?: CampusTargetMinAggregateInputType
    _max?: CampusTargetMaxAggregateInputType
  }

  export type CampusTargetGroupByOutputType = {
    id: number
    campusId: number
    month: number
    year: number
    leadTarget: number
    admissionTarget: number
    updatedAt: Date
    _count: CampusTargetCountAggregateOutputType | null
    _avg: CampusTargetAvgAggregateOutputType | null
    _sum: CampusTargetSumAggregateOutputType | null
    _min: CampusTargetMinAggregateOutputType | null
    _max: CampusTargetMaxAggregateOutputType | null
  }

  type GetCampusTargetGroupByPayload<T extends CampusTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampusTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampusTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampusTargetGroupByOutputType[P]>
            : GetScalarType<T[P], CampusTargetGroupByOutputType[P]>
        }
      >
    >


  export type CampusTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campusId?: boolean
    month?: boolean
    year?: boolean
    leadTarget?: boolean
    admissionTarget?: boolean
    updatedAt?: boolean
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campusTarget"]>

  export type CampusTargetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campusId?: boolean
    month?: boolean
    year?: boolean
    leadTarget?: boolean
    admissionTarget?: boolean
    updatedAt?: boolean
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campusTarget"]>

  export type CampusTargetSelectScalar = {
    id?: boolean
    campusId?: boolean
    month?: boolean
    year?: boolean
    leadTarget?: boolean
    admissionTarget?: boolean
    updatedAt?: boolean
  }

  export type CampusTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }
  export type CampusTargetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }

  export type $CampusTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampusTarget"
    objects: {
      campus: Prisma.$CampusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      campusId: number
      month: number
      year: number
      leadTarget: number
      admissionTarget: number
      updatedAt: Date
    }, ExtArgs["result"]["campusTarget"]>
    composites: {}
  }

  type CampusTargetGetPayload<S extends boolean | null | undefined | CampusTargetDefaultArgs> = $Result.GetResult<Prisma.$CampusTargetPayload, S>

  type CampusTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampusTargetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampusTargetCountAggregateInputType | true
    }

  export interface CampusTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampusTarget'], meta: { name: 'CampusTarget' } }
    /**
     * Find zero or one CampusTarget that matches the filter.
     * @param {CampusTargetFindUniqueArgs} args - Arguments to find a CampusTarget
     * @example
     * // Get one CampusTarget
     * const campusTarget = await prisma.campusTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampusTargetFindUniqueArgs>(args: SelectSubset<T, CampusTargetFindUniqueArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampusTarget that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampusTargetFindUniqueOrThrowArgs} args - Arguments to find a CampusTarget
     * @example
     * // Get one CampusTarget
     * const campusTarget = await prisma.campusTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampusTargetFindUniqueOrThrowArgs>(args: SelectSubset<T, CampusTargetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampusTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetFindFirstArgs} args - Arguments to find a CampusTarget
     * @example
     * // Get one CampusTarget
     * const campusTarget = await prisma.campusTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampusTargetFindFirstArgs>(args?: SelectSubset<T, CampusTargetFindFirstArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampusTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetFindFirstOrThrowArgs} args - Arguments to find a CampusTarget
     * @example
     * // Get one CampusTarget
     * const campusTarget = await prisma.campusTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampusTargetFindFirstOrThrowArgs>(args?: SelectSubset<T, CampusTargetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampusTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampusTargets
     * const campusTargets = await prisma.campusTarget.findMany()
     * 
     * // Get first 10 CampusTargets
     * const campusTargets = await prisma.campusTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campusTargetWithIdOnly = await prisma.campusTarget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampusTargetFindManyArgs>(args?: SelectSubset<T, CampusTargetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampusTarget.
     * @param {CampusTargetCreateArgs} args - Arguments to create a CampusTarget.
     * @example
     * // Create one CampusTarget
     * const CampusTarget = await prisma.campusTarget.create({
     *   data: {
     *     // ... data to create a CampusTarget
     *   }
     * })
     * 
     */
    create<T extends CampusTargetCreateArgs>(args: SelectSubset<T, CampusTargetCreateArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampusTargets.
     * @param {CampusTargetCreateManyArgs} args - Arguments to create many CampusTargets.
     * @example
     * // Create many CampusTargets
     * const campusTarget = await prisma.campusTarget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampusTargetCreateManyArgs>(args?: SelectSubset<T, CampusTargetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampusTargets and returns the data saved in the database.
     * @param {CampusTargetCreateManyAndReturnArgs} args - Arguments to create many CampusTargets.
     * @example
     * // Create many CampusTargets
     * const campusTarget = await prisma.campusTarget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampusTargets and only return the `id`
     * const campusTargetWithIdOnly = await prisma.campusTarget.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampusTargetCreateManyAndReturnArgs>(args?: SelectSubset<T, CampusTargetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampusTarget.
     * @param {CampusTargetDeleteArgs} args - Arguments to delete one CampusTarget.
     * @example
     * // Delete one CampusTarget
     * const CampusTarget = await prisma.campusTarget.delete({
     *   where: {
     *     // ... filter to delete one CampusTarget
     *   }
     * })
     * 
     */
    delete<T extends CampusTargetDeleteArgs>(args: SelectSubset<T, CampusTargetDeleteArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampusTarget.
     * @param {CampusTargetUpdateArgs} args - Arguments to update one CampusTarget.
     * @example
     * // Update one CampusTarget
     * const campusTarget = await prisma.campusTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampusTargetUpdateArgs>(args: SelectSubset<T, CampusTargetUpdateArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampusTargets.
     * @param {CampusTargetDeleteManyArgs} args - Arguments to filter CampusTargets to delete.
     * @example
     * // Delete a few CampusTargets
     * const { count } = await prisma.campusTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampusTargetDeleteManyArgs>(args?: SelectSubset<T, CampusTargetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampusTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampusTargets
     * const campusTarget = await prisma.campusTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampusTargetUpdateManyArgs>(args: SelectSubset<T, CampusTargetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampusTarget.
     * @param {CampusTargetUpsertArgs} args - Arguments to update or create a CampusTarget.
     * @example
     * // Update or create a CampusTarget
     * const campusTarget = await prisma.campusTarget.upsert({
     *   create: {
     *     // ... data to create a CampusTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampusTarget we want to update
     *   }
     * })
     */
    upsert<T extends CampusTargetUpsertArgs>(args: SelectSubset<T, CampusTargetUpsertArgs<ExtArgs>>): Prisma__CampusTargetClient<$Result.GetResult<Prisma.$CampusTargetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampusTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetCountArgs} args - Arguments to filter CampusTargets to count.
     * @example
     * // Count the number of CampusTargets
     * const count = await prisma.campusTarget.count({
     *   where: {
     *     // ... the filter for the CampusTargets we want to count
     *   }
     * })
    **/
    count<T extends CampusTargetCountArgs>(
      args?: Subset<T, CampusTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampusTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampusTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampusTargetAggregateArgs>(args: Subset<T, CampusTargetAggregateArgs>): Prisma.PrismaPromise<GetCampusTargetAggregateType<T>>

    /**
     * Group by CampusTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampusTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampusTargetGroupByArgs['orderBy'] }
        : { orderBy?: CampusTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampusTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampusTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampusTarget model
   */
  readonly fields: CampusTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampusTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampusTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampusTarget model
   */ 
  interface CampusTargetFieldRefs {
    readonly id: FieldRef<"CampusTarget", 'Int'>
    readonly campusId: FieldRef<"CampusTarget", 'Int'>
    readonly month: FieldRef<"CampusTarget", 'Int'>
    readonly year: FieldRef<"CampusTarget", 'Int'>
    readonly leadTarget: FieldRef<"CampusTarget", 'Int'>
    readonly admissionTarget: FieldRef<"CampusTarget", 'Int'>
    readonly updatedAt: FieldRef<"CampusTarget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampusTarget findUnique
   */
  export type CampusTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter, which CampusTarget to fetch.
     */
    where: CampusTargetWhereUniqueInput
  }

  /**
   * CampusTarget findUniqueOrThrow
   */
  export type CampusTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter, which CampusTarget to fetch.
     */
    where: CampusTargetWhereUniqueInput
  }

  /**
   * CampusTarget findFirst
   */
  export type CampusTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter, which CampusTarget to fetch.
     */
    where?: CampusTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampusTargets to fetch.
     */
    orderBy?: CampusTargetOrderByWithRelationInput | CampusTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampusTargets.
     */
    cursor?: CampusTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampusTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampusTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampusTargets.
     */
    distinct?: CampusTargetScalarFieldEnum | CampusTargetScalarFieldEnum[]
  }

  /**
   * CampusTarget findFirstOrThrow
   */
  export type CampusTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter, which CampusTarget to fetch.
     */
    where?: CampusTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampusTargets to fetch.
     */
    orderBy?: CampusTargetOrderByWithRelationInput | CampusTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampusTargets.
     */
    cursor?: CampusTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampusTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampusTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampusTargets.
     */
    distinct?: CampusTargetScalarFieldEnum | CampusTargetScalarFieldEnum[]
  }

  /**
   * CampusTarget findMany
   */
  export type CampusTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter, which CampusTargets to fetch.
     */
    where?: CampusTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampusTargets to fetch.
     */
    orderBy?: CampusTargetOrderByWithRelationInput | CampusTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampusTargets.
     */
    cursor?: CampusTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampusTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampusTargets.
     */
    skip?: number
    distinct?: CampusTargetScalarFieldEnum | CampusTargetScalarFieldEnum[]
  }

  /**
   * CampusTarget create
   */
  export type CampusTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a CampusTarget.
     */
    data: XOR<CampusTargetCreateInput, CampusTargetUncheckedCreateInput>
  }

  /**
   * CampusTarget createMany
   */
  export type CampusTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampusTargets.
     */
    data: CampusTargetCreateManyInput | CampusTargetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampusTarget createManyAndReturn
   */
  export type CampusTargetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampusTargets.
     */
    data: CampusTargetCreateManyInput | CampusTargetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampusTarget update
   */
  export type CampusTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a CampusTarget.
     */
    data: XOR<CampusTargetUpdateInput, CampusTargetUncheckedUpdateInput>
    /**
     * Choose, which CampusTarget to update.
     */
    where: CampusTargetWhereUniqueInput
  }

  /**
   * CampusTarget updateMany
   */
  export type CampusTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampusTargets.
     */
    data: XOR<CampusTargetUpdateManyMutationInput, CampusTargetUncheckedUpdateManyInput>
    /**
     * Filter which CampusTargets to update
     */
    where?: CampusTargetWhereInput
  }

  /**
   * CampusTarget upsert
   */
  export type CampusTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the CampusTarget to update in case it exists.
     */
    where: CampusTargetWhereUniqueInput
    /**
     * In case the CampusTarget found by the `where` argument doesn't exist, create a new CampusTarget with this data.
     */
    create: XOR<CampusTargetCreateInput, CampusTargetUncheckedCreateInput>
    /**
     * In case the CampusTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampusTargetUpdateInput, CampusTargetUncheckedUpdateInput>
  }

  /**
   * CampusTarget delete
   */
  export type CampusTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
    /**
     * Filter which CampusTarget to delete.
     */
    where: CampusTargetWhereUniqueInput
  }

  /**
   * CampusTarget deleteMany
   */
  export type CampusTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampusTargets to delete
     */
    where?: CampusTargetWhereInput
  }

  /**
   * CampusTarget without action
   */
  export type CampusTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusTarget
     */
    select?: CampusTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusTargetInclude<ExtArgs> | null
  }


  /**
   * Model GradeFee
   */

  export type AggregateGradeFee = {
    _count: GradeFeeCountAggregateOutputType | null
    _avg: GradeFeeAvgAggregateOutputType | null
    _sum: GradeFeeSumAggregateOutputType | null
    _min: GradeFeeMinAggregateOutputType | null
    _max: GradeFeeMaxAggregateOutputType | null
  }

  export type GradeFeeAvgAggregateOutputType = {
    id: number | null
    annualFee_otp: number | null
    annualFee_wotp: number | null
    campusId: number | null
  }

  export type GradeFeeSumAggregateOutputType = {
    id: number | null
    annualFee_otp: number | null
    annualFee_wotp: number | null
    campusId: number | null
  }

  export type GradeFeeMinAggregateOutputType = {
    id: number | null
    grade: string | null
    annualFee_otp: number | null
    annualFee_wotp: number | null
    campusId: number | null
    academicYear: string | null
  }

  export type GradeFeeMaxAggregateOutputType = {
    id: number | null
    grade: string | null
    annualFee_otp: number | null
    annualFee_wotp: number | null
    campusId: number | null
    academicYear: string | null
  }

  export type GradeFeeCountAggregateOutputType = {
    id: number
    grade: number
    annualFee_otp: number
    annualFee_wotp: number
    campusId: number
    academicYear: number
    _all: number
  }


  export type GradeFeeAvgAggregateInputType = {
    id?: true
    annualFee_otp?: true
    annualFee_wotp?: true
    campusId?: true
  }

  export type GradeFeeSumAggregateInputType = {
    id?: true
    annualFee_otp?: true
    annualFee_wotp?: true
    campusId?: true
  }

  export type GradeFeeMinAggregateInputType = {
    id?: true
    grade?: true
    annualFee_otp?: true
    annualFee_wotp?: true
    campusId?: true
    academicYear?: true
  }

  export type GradeFeeMaxAggregateInputType = {
    id?: true
    grade?: true
    annualFee_otp?: true
    annualFee_wotp?: true
    campusId?: true
    academicYear?: true
  }

  export type GradeFeeCountAggregateInputType = {
    id?: true
    grade?: true
    annualFee_otp?: true
    annualFee_wotp?: true
    campusId?: true
    academicYear?: true
    _all?: true
  }

  export type GradeFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeFee to aggregate.
     */
    where?: GradeFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeFees to fetch.
     */
    orderBy?: GradeFeeOrderByWithRelationInput | GradeFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GradeFees
    **/
    _count?: true | GradeFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeFeeMaxAggregateInputType
  }

  export type GetGradeFeeAggregateType<T extends GradeFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateGradeFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGradeFee[P]>
      : GetScalarType<T[P], AggregateGradeFee[P]>
  }




  export type GradeFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeFeeWhereInput
    orderBy?: GradeFeeOrderByWithAggregationInput | GradeFeeOrderByWithAggregationInput[]
    by: GradeFeeScalarFieldEnum[] | GradeFeeScalarFieldEnum
    having?: GradeFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeFeeCountAggregateInputType | true
    _avg?: GradeFeeAvgAggregateInputType
    _sum?: GradeFeeSumAggregateInputType
    _min?: GradeFeeMinAggregateInputType
    _max?: GradeFeeMaxAggregateInputType
  }

  export type GradeFeeGroupByOutputType = {
    id: number
    grade: string
    annualFee_otp: number | null
    annualFee_wotp: number | null
    campusId: number
    academicYear: string
    _count: GradeFeeCountAggregateOutputType | null
    _avg: GradeFeeAvgAggregateOutputType | null
    _sum: GradeFeeSumAggregateOutputType | null
    _min: GradeFeeMinAggregateOutputType | null
    _max: GradeFeeMaxAggregateOutputType | null
  }

  type GetGradeFeeGroupByPayload<T extends GradeFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeFeeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeFeeGroupByOutputType[P]>
        }
      >
    >


  export type GradeFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    annualFee_otp?: boolean
    annualFee_wotp?: boolean
    campusId?: boolean
    academicYear?: boolean
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeFee"]>

  export type GradeFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grade?: boolean
    annualFee_otp?: boolean
    annualFee_wotp?: boolean
    campusId?: boolean
    academicYear?: boolean
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gradeFee"]>

  export type GradeFeeSelectScalar = {
    id?: boolean
    grade?: boolean
    annualFee_otp?: boolean
    annualFee_wotp?: boolean
    campusId?: boolean
    academicYear?: boolean
  }

  export type GradeFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }
  export type GradeFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }

  export type $GradeFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GradeFee"
    objects: {
      campus: Prisma.$CampusPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      grade: string
      annualFee_otp: number | null
      annualFee_wotp: number | null
      campusId: number
      academicYear: string
    }, ExtArgs["result"]["gradeFee"]>
    composites: {}
  }

  type GradeFeeGetPayload<S extends boolean | null | undefined | GradeFeeDefaultArgs> = $Result.GetResult<Prisma.$GradeFeePayload, S>

  type GradeFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradeFeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradeFeeCountAggregateInputType | true
    }

  export interface GradeFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GradeFee'], meta: { name: 'GradeFee' } }
    /**
     * Find zero or one GradeFee that matches the filter.
     * @param {GradeFeeFindUniqueArgs} args - Arguments to find a GradeFee
     * @example
     * // Get one GradeFee
     * const gradeFee = await prisma.gradeFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFeeFindUniqueArgs>(args: SelectSubset<T, GradeFeeFindUniqueArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GradeFee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradeFeeFindUniqueOrThrowArgs} args - Arguments to find a GradeFee
     * @example
     * // Get one GradeFee
     * const gradeFee = await prisma.gradeFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GradeFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeFindFirstArgs} args - Arguments to find a GradeFee
     * @example
     * // Get one GradeFee
     * const gradeFee = await prisma.gradeFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFeeFindFirstArgs>(args?: SelectSubset<T, GradeFeeFindFirstArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GradeFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeFindFirstOrThrowArgs} args - Arguments to find a GradeFee
     * @example
     * // Get one GradeFee
     * const gradeFee = await prisma.gradeFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GradeFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GradeFees
     * const gradeFees = await prisma.gradeFee.findMany()
     * 
     * // Get first 10 GradeFees
     * const gradeFees = await prisma.gradeFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeFeeWithIdOnly = await prisma.gradeFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFeeFindManyArgs>(args?: SelectSubset<T, GradeFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GradeFee.
     * @param {GradeFeeCreateArgs} args - Arguments to create a GradeFee.
     * @example
     * // Create one GradeFee
     * const GradeFee = await prisma.gradeFee.create({
     *   data: {
     *     // ... data to create a GradeFee
     *   }
     * })
     * 
     */
    create<T extends GradeFeeCreateArgs>(args: SelectSubset<T, GradeFeeCreateArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GradeFees.
     * @param {GradeFeeCreateManyArgs} args - Arguments to create many GradeFees.
     * @example
     * // Create many GradeFees
     * const gradeFee = await prisma.gradeFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeFeeCreateManyArgs>(args?: SelectSubset<T, GradeFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GradeFees and returns the data saved in the database.
     * @param {GradeFeeCreateManyAndReturnArgs} args - Arguments to create many GradeFees.
     * @example
     * // Create many GradeFees
     * const gradeFee = await prisma.gradeFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GradeFees and only return the `id`
     * const gradeFeeWithIdOnly = await prisma.gradeFee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GradeFee.
     * @param {GradeFeeDeleteArgs} args - Arguments to delete one GradeFee.
     * @example
     * // Delete one GradeFee
     * const GradeFee = await prisma.gradeFee.delete({
     *   where: {
     *     // ... filter to delete one GradeFee
     *   }
     * })
     * 
     */
    delete<T extends GradeFeeDeleteArgs>(args: SelectSubset<T, GradeFeeDeleteArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GradeFee.
     * @param {GradeFeeUpdateArgs} args - Arguments to update one GradeFee.
     * @example
     * // Update one GradeFee
     * const gradeFee = await prisma.gradeFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeFeeUpdateArgs>(args: SelectSubset<T, GradeFeeUpdateArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GradeFees.
     * @param {GradeFeeDeleteManyArgs} args - Arguments to filter GradeFees to delete.
     * @example
     * // Delete a few GradeFees
     * const { count } = await prisma.gradeFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeFeeDeleteManyArgs>(args?: SelectSubset<T, GradeFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GradeFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GradeFees
     * const gradeFee = await prisma.gradeFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeFeeUpdateManyArgs>(args: SelectSubset<T, GradeFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GradeFee.
     * @param {GradeFeeUpsertArgs} args - Arguments to update or create a GradeFee.
     * @example
     * // Update or create a GradeFee
     * const gradeFee = await prisma.gradeFee.upsert({
     *   create: {
     *     // ... data to create a GradeFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GradeFee we want to update
     *   }
     * })
     */
    upsert<T extends GradeFeeUpsertArgs>(args: SelectSubset<T, GradeFeeUpsertArgs<ExtArgs>>): Prisma__GradeFeeClient<$Result.GetResult<Prisma.$GradeFeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GradeFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeCountArgs} args - Arguments to filter GradeFees to count.
     * @example
     * // Count the number of GradeFees
     * const count = await prisma.gradeFee.count({
     *   where: {
     *     // ... the filter for the GradeFees we want to count
     *   }
     * })
    **/
    count<T extends GradeFeeCountArgs>(
      args?: Subset<T, GradeFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GradeFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeFeeAggregateArgs>(args: Subset<T, GradeFeeAggregateArgs>): Prisma.PrismaPromise<GetGradeFeeAggregateType<T>>

    /**
     * Group by GradeFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeFeeGroupByArgs['orderBy'] }
        : { orderBy?: GradeFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GradeFee model
   */
  readonly fields: GradeFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GradeFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GradeFee model
   */ 
  interface GradeFeeFieldRefs {
    readonly id: FieldRef<"GradeFee", 'Int'>
    readonly grade: FieldRef<"GradeFee", 'String'>
    readonly annualFee_otp: FieldRef<"GradeFee", 'Int'>
    readonly annualFee_wotp: FieldRef<"GradeFee", 'Int'>
    readonly campusId: FieldRef<"GradeFee", 'Int'>
    readonly academicYear: FieldRef<"GradeFee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GradeFee findUnique
   */
  export type GradeFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter, which GradeFee to fetch.
     */
    where: GradeFeeWhereUniqueInput
  }

  /**
   * GradeFee findUniqueOrThrow
   */
  export type GradeFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter, which GradeFee to fetch.
     */
    where: GradeFeeWhereUniqueInput
  }

  /**
   * GradeFee findFirst
   */
  export type GradeFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter, which GradeFee to fetch.
     */
    where?: GradeFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeFees to fetch.
     */
    orderBy?: GradeFeeOrderByWithRelationInput | GradeFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeFees.
     */
    cursor?: GradeFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeFees.
     */
    distinct?: GradeFeeScalarFieldEnum | GradeFeeScalarFieldEnum[]
  }

  /**
   * GradeFee findFirstOrThrow
   */
  export type GradeFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter, which GradeFee to fetch.
     */
    where?: GradeFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeFees to fetch.
     */
    orderBy?: GradeFeeOrderByWithRelationInput | GradeFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GradeFees.
     */
    cursor?: GradeFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GradeFees.
     */
    distinct?: GradeFeeScalarFieldEnum | GradeFeeScalarFieldEnum[]
  }

  /**
   * GradeFee findMany
   */
  export type GradeFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter, which GradeFees to fetch.
     */
    where?: GradeFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GradeFees to fetch.
     */
    orderBy?: GradeFeeOrderByWithRelationInput | GradeFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GradeFees.
     */
    cursor?: GradeFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GradeFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GradeFees.
     */
    skip?: number
    distinct?: GradeFeeScalarFieldEnum | GradeFeeScalarFieldEnum[]
  }

  /**
   * GradeFee create
   */
  export type GradeFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a GradeFee.
     */
    data: XOR<GradeFeeCreateInput, GradeFeeUncheckedCreateInput>
  }

  /**
   * GradeFee createMany
   */
  export type GradeFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GradeFees.
     */
    data: GradeFeeCreateManyInput | GradeFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GradeFee createManyAndReturn
   */
  export type GradeFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GradeFees.
     */
    data: GradeFeeCreateManyInput | GradeFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GradeFee update
   */
  export type GradeFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a GradeFee.
     */
    data: XOR<GradeFeeUpdateInput, GradeFeeUncheckedUpdateInput>
    /**
     * Choose, which GradeFee to update.
     */
    where: GradeFeeWhereUniqueInput
  }

  /**
   * GradeFee updateMany
   */
  export type GradeFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GradeFees.
     */
    data: XOR<GradeFeeUpdateManyMutationInput, GradeFeeUncheckedUpdateManyInput>
    /**
     * Filter which GradeFees to update
     */
    where?: GradeFeeWhereInput
  }

  /**
   * GradeFee upsert
   */
  export type GradeFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the GradeFee to update in case it exists.
     */
    where: GradeFeeWhereUniqueInput
    /**
     * In case the GradeFee found by the `where` argument doesn't exist, create a new GradeFee with this data.
     */
    create: XOR<GradeFeeCreateInput, GradeFeeUncheckedCreateInput>
    /**
     * In case the GradeFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeFeeUpdateInput, GradeFeeUncheckedUpdateInput>
  }

  /**
   * GradeFee delete
   */
  export type GradeFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
    /**
     * Filter which GradeFee to delete.
     */
    where: GradeFeeWhereUniqueInput
  }

  /**
   * GradeFee deleteMany
   */
  export type GradeFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GradeFees to delete
     */
    where?: GradeFeeWhereInput
  }

  /**
   * GradeFee without action
   */
  export type GradeFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GradeFee
     */
    select?: GradeFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeFeeInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsAvgAggregateOutputType = {
    id: number | null
    reminderFrequencyDays: number | null
  }

  export type NotificationSettingsSumAggregateOutputType = {
    id: number | null
    reminderFrequencyDays: number | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    id: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    whatsappNotifications: boolean | null
    leadFollowupReminders: boolean | null
    reminderFrequencyDays: number | null
    notifySuperAdminOnNewAdmins: boolean | null
    notifyCampusHeadOnNewLeads: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    id: number | null
    emailNotifications: boolean | null
    smsNotifications: boolean | null
    whatsappNotifications: boolean | null
    leadFollowupReminders: boolean | null
    reminderFrequencyDays: number | null
    notifySuperAdminOnNewAdmins: boolean | null
    notifyCampusHeadOnNewLeads: boolean | null
    updatedAt: Date | null
    updatedBy: string | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    id: number
    emailNotifications: number
    smsNotifications: number
    whatsappNotifications: number
    leadFollowupReminders: number
    reminderFrequencyDays: number
    notifySuperAdminOnNewAdmins: number
    notifyCampusHeadOnNewLeads: number
    updatedAt: number
    updatedBy: number
    _all: number
  }


  export type NotificationSettingsAvgAggregateInputType = {
    id?: true
    reminderFrequencyDays?: true
  }

  export type NotificationSettingsSumAggregateInputType = {
    id?: true
    reminderFrequencyDays?: true
  }

  export type NotificationSettingsMinAggregateInputType = {
    id?: true
    emailNotifications?: true
    smsNotifications?: true
    whatsappNotifications?: true
    leadFollowupReminders?: true
    reminderFrequencyDays?: true
    notifySuperAdminOnNewAdmins?: true
    notifyCampusHeadOnNewLeads?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    id?: true
    emailNotifications?: true
    smsNotifications?: true
    whatsappNotifications?: true
    leadFollowupReminders?: true
    reminderFrequencyDays?: true
    notifySuperAdminOnNewAdmins?: true
    notifyCampusHeadOnNewLeads?: true
    updatedAt?: true
    updatedBy?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    id?: true
    emailNotifications?: true
    smsNotifications?: true
    whatsappNotifications?: true
    leadFollowupReminders?: true
    reminderFrequencyDays?: true
    notifySuperAdminOnNewAdmins?: true
    notifyCampusHeadOnNewLeads?: true
    updatedAt?: true
    updatedBy?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _avg?: NotificationSettingsAvgAggregateInputType
    _sum?: NotificationSettingsSumAggregateInputType
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    id: number
    emailNotifications: boolean
    smsNotifications: boolean
    whatsappNotifications: boolean
    leadFollowupReminders: boolean
    reminderFrequencyDays: number
    notifySuperAdminOnNewAdmins: boolean
    notifyCampusHeadOnNewLeads: boolean
    updatedAt: Date
    updatedBy: string | null
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: boolean
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: boolean
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    id?: boolean
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: boolean
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: boolean
    updatedBy?: boolean
  }


  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      emailNotifications: boolean
      smsNotifications: boolean
      whatsappNotifications: boolean
      leadFollowupReminders: boolean
      reminderFrequencyDays: number
      notifySuperAdminOnNewAdmins: boolean
      notifyCampusHeadOnNewLeads: boolean
      updatedAt: Date
      updatedBy: string | null
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `id`
     * const notificationSettingsWithIdOnly = await prisma.notificationSettings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly id: FieldRef<"NotificationSettings", 'Int'>
    readonly emailNotifications: FieldRef<"NotificationSettings", 'Boolean'>
    readonly smsNotifications: FieldRef<"NotificationSettings", 'Boolean'>
    readonly whatsappNotifications: FieldRef<"NotificationSettings", 'Boolean'>
    readonly leadFollowupReminders: FieldRef<"NotificationSettings", 'Boolean'>
    readonly reminderFrequencyDays: FieldRef<"NotificationSettings", 'Int'>
    readonly notifySuperAdminOnNewAdmins: FieldRef<"NotificationSettings", 'Boolean'>
    readonly notifyCampusHeadOnNewLeads: FieldRef<"NotificationSettings", 'Boolean'>
    readonly updatedAt: FieldRef<"NotificationSettings", 'DateTime'>
    readonly updatedBy: FieldRef<"NotificationSettings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
  }


  /**
   * Model MarketingAsset
   */

  export type AggregateMarketingAsset = {
    _count: MarketingAssetCountAggregateOutputType | null
    _avg: MarketingAssetAvgAggregateOutputType | null
    _sum: MarketingAssetSumAggregateOutputType | null
    _min: MarketingAssetMinAggregateOutputType | null
    _max: MarketingAssetMaxAggregateOutputType | null
  }

  export type MarketingAssetAvgAggregateOutputType = {
    id: number | null
    fileSize: number | null
    sortOrder: number | null
    uploadedById: number | null
  }

  export type MarketingAssetSumAggregateOutputType = {
    id: number | null
    fileSize: number | null
    sortOrder: number | null
    uploadedById: number | null
  }

  export type MarketingAssetMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    isActive: boolean | null
    sortOrder: number | null
    uploadedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingAssetMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: number | null
    isActive: boolean | null
    sortOrder: number | null
    uploadedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingAssetCountAggregateOutputType = {
    id: number
    name: number
    category: number
    description: number
    fileUrl: number
    fileType: number
    fileSize: number
    isActive: number
    sortOrder: number
    uploadedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingAssetAvgAggregateInputType = {
    id?: true
    fileSize?: true
    sortOrder?: true
    uploadedById?: true
  }

  export type MarketingAssetSumAggregateInputType = {
    id?: true
    fileSize?: true
    sortOrder?: true
    uploadedById?: true
  }

  export type MarketingAssetMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    isActive?: true
    sortOrder?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingAssetMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    isActive?: true
    sortOrder?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingAssetCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    description?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    isActive?: true
    sortOrder?: true
    uploadedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingAsset to aggregate.
     */
    where?: MarketingAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingAssets to fetch.
     */
    orderBy?: MarketingAssetOrderByWithRelationInput | MarketingAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingAssets
    **/
    _count?: true | MarketingAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingAssetMaxAggregateInputType
  }

  export type GetMarketingAssetAggregateType<T extends MarketingAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingAsset[P]>
      : GetScalarType<T[P], AggregateMarketingAsset[P]>
  }




  export type MarketingAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingAssetWhereInput
    orderBy?: MarketingAssetOrderByWithAggregationInput | MarketingAssetOrderByWithAggregationInput[]
    by: MarketingAssetScalarFieldEnum[] | MarketingAssetScalarFieldEnum
    having?: MarketingAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingAssetCountAggregateInputType | true
    _avg?: MarketingAssetAvgAggregateInputType
    _sum?: MarketingAssetSumAggregateInputType
    _min?: MarketingAssetMinAggregateInputType
    _max?: MarketingAssetMaxAggregateInputType
  }

  export type MarketingAssetGroupByOutputType = {
    id: number
    name: string
    category: string
    description: string | null
    fileUrl: string
    fileType: string | null
    fileSize: number | null
    isActive: boolean
    sortOrder: number
    uploadedById: number | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingAssetCountAggregateOutputType | null
    _avg: MarketingAssetAvgAggregateOutputType | null
    _sum: MarketingAssetSumAggregateOutputType | null
    _min: MarketingAssetMinAggregateOutputType | null
    _max: MarketingAssetMaxAggregateOutputType | null
  }

  type GetMarketingAssetGroupByPayload<T extends MarketingAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingAssetGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingAssetGroupByOutputType[P]>
        }
      >
    >


  export type MarketingAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingAsset"]>

  export type MarketingAssetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingAsset"]>

  export type MarketingAssetSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    isActive?: boolean
    sortOrder?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $MarketingAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingAsset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: string
      description: string | null
      fileUrl: string
      fileType: string | null
      fileSize: number | null
      isActive: boolean
      sortOrder: number
      uploadedById: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingAsset"]>
    composites: {}
  }

  type MarketingAssetGetPayload<S extends boolean | null | undefined | MarketingAssetDefaultArgs> = $Result.GetResult<Prisma.$MarketingAssetPayload, S>

  type MarketingAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketingAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketingAssetCountAggregateInputType | true
    }

  export interface MarketingAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingAsset'], meta: { name: 'MarketingAsset' } }
    /**
     * Find zero or one MarketingAsset that matches the filter.
     * @param {MarketingAssetFindUniqueArgs} args - Arguments to find a MarketingAsset
     * @example
     * // Get one MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingAssetFindUniqueArgs>(args: SelectSubset<T, MarketingAssetFindUniqueArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketingAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketingAssetFindUniqueOrThrowArgs} args - Arguments to find a MarketingAsset
     * @example
     * // Get one MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketingAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetFindFirstArgs} args - Arguments to find a MarketingAsset
     * @example
     * // Get one MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingAssetFindFirstArgs>(args?: SelectSubset<T, MarketingAssetFindFirstArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketingAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetFindFirstOrThrowArgs} args - Arguments to find a MarketingAsset
     * @example
     * // Get one MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketingAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingAssets
     * const marketingAssets = await prisma.marketingAsset.findMany()
     * 
     * // Get first 10 MarketingAssets
     * const marketingAssets = await prisma.marketingAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingAssetWithIdOnly = await prisma.marketingAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingAssetFindManyArgs>(args?: SelectSubset<T, MarketingAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketingAsset.
     * @param {MarketingAssetCreateArgs} args - Arguments to create a MarketingAsset.
     * @example
     * // Create one MarketingAsset
     * const MarketingAsset = await prisma.marketingAsset.create({
     *   data: {
     *     // ... data to create a MarketingAsset
     *   }
     * })
     * 
     */
    create<T extends MarketingAssetCreateArgs>(args: SelectSubset<T, MarketingAssetCreateArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketingAssets.
     * @param {MarketingAssetCreateManyArgs} args - Arguments to create many MarketingAssets.
     * @example
     * // Create many MarketingAssets
     * const marketingAsset = await prisma.marketingAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingAssetCreateManyArgs>(args?: SelectSubset<T, MarketingAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingAssets and returns the data saved in the database.
     * @param {MarketingAssetCreateManyAndReturnArgs} args - Arguments to create many MarketingAssets.
     * @example
     * // Create many MarketingAssets
     * const marketingAsset = await prisma.marketingAsset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingAssets and only return the `id`
     * const marketingAssetWithIdOnly = await prisma.marketingAsset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingAssetCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingAssetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketingAsset.
     * @param {MarketingAssetDeleteArgs} args - Arguments to delete one MarketingAsset.
     * @example
     * // Delete one MarketingAsset
     * const MarketingAsset = await prisma.marketingAsset.delete({
     *   where: {
     *     // ... filter to delete one MarketingAsset
     *   }
     * })
     * 
     */
    delete<T extends MarketingAssetDeleteArgs>(args: SelectSubset<T, MarketingAssetDeleteArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketingAsset.
     * @param {MarketingAssetUpdateArgs} args - Arguments to update one MarketingAsset.
     * @example
     * // Update one MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingAssetUpdateArgs>(args: SelectSubset<T, MarketingAssetUpdateArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketingAssets.
     * @param {MarketingAssetDeleteManyArgs} args - Arguments to filter MarketingAssets to delete.
     * @example
     * // Delete a few MarketingAssets
     * const { count } = await prisma.marketingAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingAssetDeleteManyArgs>(args?: SelectSubset<T, MarketingAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingAssets
     * const marketingAsset = await prisma.marketingAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingAssetUpdateManyArgs>(args: SelectSubset<T, MarketingAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketingAsset.
     * @param {MarketingAssetUpsertArgs} args - Arguments to update or create a MarketingAsset.
     * @example
     * // Update or create a MarketingAsset
     * const marketingAsset = await prisma.marketingAsset.upsert({
     *   create: {
     *     // ... data to create a MarketingAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingAsset we want to update
     *   }
     * })
     */
    upsert<T extends MarketingAssetUpsertArgs>(args: SelectSubset<T, MarketingAssetUpsertArgs<ExtArgs>>): Prisma__MarketingAssetClient<$Result.GetResult<Prisma.$MarketingAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketingAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetCountArgs} args - Arguments to filter MarketingAssets to count.
     * @example
     * // Count the number of MarketingAssets
     * const count = await prisma.marketingAsset.count({
     *   where: {
     *     // ... the filter for the MarketingAssets we want to count
     *   }
     * })
    **/
    count<T extends MarketingAssetCountArgs>(
      args?: Subset<T, MarketingAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingAssetAggregateArgs>(args: Subset<T, MarketingAssetAggregateArgs>): Prisma.PrismaPromise<GetMarketingAssetAggregateType<T>>

    /**
     * Group by MarketingAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingAssetGroupByArgs['orderBy'] }
        : { orderBy?: MarketingAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingAsset model
   */
  readonly fields: MarketingAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingAsset model
   */ 
  interface MarketingAssetFieldRefs {
    readonly id: FieldRef<"MarketingAsset", 'Int'>
    readonly name: FieldRef<"MarketingAsset", 'String'>
    readonly category: FieldRef<"MarketingAsset", 'String'>
    readonly description: FieldRef<"MarketingAsset", 'String'>
    readonly fileUrl: FieldRef<"MarketingAsset", 'String'>
    readonly fileType: FieldRef<"MarketingAsset", 'String'>
    readonly fileSize: FieldRef<"MarketingAsset", 'Int'>
    readonly isActive: FieldRef<"MarketingAsset", 'Boolean'>
    readonly sortOrder: FieldRef<"MarketingAsset", 'Int'>
    readonly uploadedById: FieldRef<"MarketingAsset", 'Int'>
    readonly createdAt: FieldRef<"MarketingAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingAsset findUnique
   */
  export type MarketingAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter, which MarketingAsset to fetch.
     */
    where: MarketingAssetWhereUniqueInput
  }

  /**
   * MarketingAsset findUniqueOrThrow
   */
  export type MarketingAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter, which MarketingAsset to fetch.
     */
    where: MarketingAssetWhereUniqueInput
  }

  /**
   * MarketingAsset findFirst
   */
  export type MarketingAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter, which MarketingAsset to fetch.
     */
    where?: MarketingAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingAssets to fetch.
     */
    orderBy?: MarketingAssetOrderByWithRelationInput | MarketingAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingAssets.
     */
    cursor?: MarketingAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingAssets.
     */
    distinct?: MarketingAssetScalarFieldEnum | MarketingAssetScalarFieldEnum[]
  }

  /**
   * MarketingAsset findFirstOrThrow
   */
  export type MarketingAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter, which MarketingAsset to fetch.
     */
    where?: MarketingAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingAssets to fetch.
     */
    orderBy?: MarketingAssetOrderByWithRelationInput | MarketingAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingAssets.
     */
    cursor?: MarketingAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingAssets.
     */
    distinct?: MarketingAssetScalarFieldEnum | MarketingAssetScalarFieldEnum[]
  }

  /**
   * MarketingAsset findMany
   */
  export type MarketingAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter, which MarketingAssets to fetch.
     */
    where?: MarketingAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingAssets to fetch.
     */
    orderBy?: MarketingAssetOrderByWithRelationInput | MarketingAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingAssets.
     */
    cursor?: MarketingAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingAssets.
     */
    skip?: number
    distinct?: MarketingAssetScalarFieldEnum | MarketingAssetScalarFieldEnum[]
  }

  /**
   * MarketingAsset create
   */
  export type MarketingAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * The data needed to create a MarketingAsset.
     */
    data: XOR<MarketingAssetCreateInput, MarketingAssetUncheckedCreateInput>
  }

  /**
   * MarketingAsset createMany
   */
  export type MarketingAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingAssets.
     */
    data: MarketingAssetCreateManyInput | MarketingAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingAsset createManyAndReturn
   */
  export type MarketingAssetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketingAssets.
     */
    data: MarketingAssetCreateManyInput | MarketingAssetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingAsset update
   */
  export type MarketingAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * The data needed to update a MarketingAsset.
     */
    data: XOR<MarketingAssetUpdateInput, MarketingAssetUncheckedUpdateInput>
    /**
     * Choose, which MarketingAsset to update.
     */
    where: MarketingAssetWhereUniqueInput
  }

  /**
   * MarketingAsset updateMany
   */
  export type MarketingAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingAssets.
     */
    data: XOR<MarketingAssetUpdateManyMutationInput, MarketingAssetUncheckedUpdateManyInput>
    /**
     * Filter which MarketingAssets to update
     */
    where?: MarketingAssetWhereInput
  }

  /**
   * MarketingAsset upsert
   */
  export type MarketingAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * The filter to search for the MarketingAsset to update in case it exists.
     */
    where: MarketingAssetWhereUniqueInput
    /**
     * In case the MarketingAsset found by the `where` argument doesn't exist, create a new MarketingAsset with this data.
     */
    create: XOR<MarketingAssetCreateInput, MarketingAssetUncheckedCreateInput>
    /**
     * In case the MarketingAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingAssetUpdateInput, MarketingAssetUncheckedUpdateInput>
  }

  /**
   * MarketingAsset delete
   */
  export type MarketingAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
    /**
     * Filter which MarketingAsset to delete.
     */
    where: MarketingAssetWhereUniqueInput
  }

  /**
   * MarketingAsset deleteMany
   */
  export type MarketingAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingAssets to delete
     */
    where?: MarketingAssetWhereInput
  }

  /**
   * MarketingAsset without action
   */
  export type MarketingAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingAsset
     */
    select?: MarketingAssetSelect<ExtArgs> | null
  }


  /**
   * Model OtpVerification
   */

  export type AggregateOtpVerification = {
    _count: OtpVerificationCountAggregateOutputType | null
    _avg: OtpVerificationAvgAggregateOutputType | null
    _sum: OtpVerificationSumAggregateOutputType | null
    _min: OtpVerificationMinAggregateOutputType | null
    _max: OtpVerificationMaxAggregateOutputType | null
  }

  export type OtpVerificationAvgAggregateOutputType = {
    id: number | null
  }

  export type OtpVerificationSumAggregateOutputType = {
    id: number | null
  }

  export type OtpVerificationMinAggregateOutputType = {
    id: number | null
    mobile: string | null
    otp: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpVerificationMaxAggregateOutputType = {
    id: number | null
    mobile: string | null
    otp: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OtpVerificationCountAggregateOutputType = {
    id: number
    mobile: number
    otp: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OtpVerificationAvgAggregateInputType = {
    id?: true
  }

  export type OtpVerificationSumAggregateInputType = {
    id?: true
  }

  export type OtpVerificationMinAggregateInputType = {
    id?: true
    mobile?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpVerificationMaxAggregateInputType = {
    id?: true
    mobile?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OtpVerificationCountAggregateInputType = {
    id?: true
    mobile?: true
    otp?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OtpVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpVerification to aggregate.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OtpVerifications
    **/
    _count?: true | OtpVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpVerificationMaxAggregateInputType
  }

  export type GetOtpVerificationAggregateType<T extends OtpVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateOtpVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtpVerification[P]>
      : GetScalarType<T[P], AggregateOtpVerification[P]>
  }




  export type OtpVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpVerificationWhereInput
    orderBy?: OtpVerificationOrderByWithAggregationInput | OtpVerificationOrderByWithAggregationInput[]
    by: OtpVerificationScalarFieldEnum[] | OtpVerificationScalarFieldEnum
    having?: OtpVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpVerificationCountAggregateInputType | true
    _avg?: OtpVerificationAvgAggregateInputType
    _sum?: OtpVerificationSumAggregateInputType
    _min?: OtpVerificationMinAggregateInputType
    _max?: OtpVerificationMaxAggregateInputType
  }

  export type OtpVerificationGroupByOutputType = {
    id: number
    mobile: string
    otp: string
    expiresAt: Date
    createdAt: Date
    _count: OtpVerificationCountAggregateOutputType | null
    _avg: OtpVerificationAvgAggregateOutputType | null
    _sum: OtpVerificationSumAggregateOutputType | null
    _min: OtpVerificationMinAggregateOutputType | null
    _max: OtpVerificationMaxAggregateOutputType | null
  }

  type GetOtpVerificationGroupByPayload<T extends OtpVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], OtpVerificationGroupByOutputType[P]>
        }
      >
    >


  export type OtpVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobile?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otpVerification"]>

  export type OtpVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mobile?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otpVerification"]>

  export type OtpVerificationSelectScalar = {
    id?: boolean
    mobile?: boolean
    otp?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }


  export type $OtpVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OtpVerification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mobile: string
      otp: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["otpVerification"]>
    composites: {}
  }

  type OtpVerificationGetPayload<S extends boolean | null | undefined | OtpVerificationDefaultArgs> = $Result.GetResult<Prisma.$OtpVerificationPayload, S>

  type OtpVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtpVerificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtpVerificationCountAggregateInputType | true
    }

  export interface OtpVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OtpVerification'], meta: { name: 'OtpVerification' } }
    /**
     * Find zero or one OtpVerification that matches the filter.
     * @param {OtpVerificationFindUniqueArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpVerificationFindUniqueArgs>(args: SelectSubset<T, OtpVerificationFindUniqueArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OtpVerification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtpVerificationFindUniqueOrThrowArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OtpVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindFirstArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpVerificationFindFirstArgs>(args?: SelectSubset<T, OtpVerificationFindFirstArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OtpVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindFirstOrThrowArgs} args - Arguments to find a OtpVerification
     * @example
     * // Get one OtpVerification
     * const otpVerification = await prisma.otpVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OtpVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OtpVerifications
     * const otpVerifications = await prisma.otpVerification.findMany()
     * 
     * // Get first 10 OtpVerifications
     * const otpVerifications = await prisma.otpVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpVerificationWithIdOnly = await prisma.otpVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpVerificationFindManyArgs>(args?: SelectSubset<T, OtpVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OtpVerification.
     * @param {OtpVerificationCreateArgs} args - Arguments to create a OtpVerification.
     * @example
     * // Create one OtpVerification
     * const OtpVerification = await prisma.otpVerification.create({
     *   data: {
     *     // ... data to create a OtpVerification
     *   }
     * })
     * 
     */
    create<T extends OtpVerificationCreateArgs>(args: SelectSubset<T, OtpVerificationCreateArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OtpVerifications.
     * @param {OtpVerificationCreateManyArgs} args - Arguments to create many OtpVerifications.
     * @example
     * // Create many OtpVerifications
     * const otpVerification = await prisma.otpVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpVerificationCreateManyArgs>(args?: SelectSubset<T, OtpVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OtpVerifications and returns the data saved in the database.
     * @param {OtpVerificationCreateManyAndReturnArgs} args - Arguments to create many OtpVerifications.
     * @example
     * // Create many OtpVerifications
     * const otpVerification = await prisma.otpVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OtpVerifications and only return the `id`
     * const otpVerificationWithIdOnly = await prisma.otpVerification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OtpVerification.
     * @param {OtpVerificationDeleteArgs} args - Arguments to delete one OtpVerification.
     * @example
     * // Delete one OtpVerification
     * const OtpVerification = await prisma.otpVerification.delete({
     *   where: {
     *     // ... filter to delete one OtpVerification
     *   }
     * })
     * 
     */
    delete<T extends OtpVerificationDeleteArgs>(args: SelectSubset<T, OtpVerificationDeleteArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OtpVerification.
     * @param {OtpVerificationUpdateArgs} args - Arguments to update one OtpVerification.
     * @example
     * // Update one OtpVerification
     * const otpVerification = await prisma.otpVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpVerificationUpdateArgs>(args: SelectSubset<T, OtpVerificationUpdateArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OtpVerifications.
     * @param {OtpVerificationDeleteManyArgs} args - Arguments to filter OtpVerifications to delete.
     * @example
     * // Delete a few OtpVerifications
     * const { count } = await prisma.otpVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpVerificationDeleteManyArgs>(args?: SelectSubset<T, OtpVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OtpVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OtpVerifications
     * const otpVerification = await prisma.otpVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpVerificationUpdateManyArgs>(args: SelectSubset<T, OtpVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OtpVerification.
     * @param {OtpVerificationUpsertArgs} args - Arguments to update or create a OtpVerification.
     * @example
     * // Update or create a OtpVerification
     * const otpVerification = await prisma.otpVerification.upsert({
     *   create: {
     *     // ... data to create a OtpVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OtpVerification we want to update
     *   }
     * })
     */
    upsert<T extends OtpVerificationUpsertArgs>(args: SelectSubset<T, OtpVerificationUpsertArgs<ExtArgs>>): Prisma__OtpVerificationClient<$Result.GetResult<Prisma.$OtpVerificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OtpVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationCountArgs} args - Arguments to filter OtpVerifications to count.
     * @example
     * // Count the number of OtpVerifications
     * const count = await prisma.otpVerification.count({
     *   where: {
     *     // ... the filter for the OtpVerifications we want to count
     *   }
     * })
    **/
    count<T extends OtpVerificationCountArgs>(
      args?: Subset<T, OtpVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OtpVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpVerificationAggregateArgs>(args: Subset<T, OtpVerificationAggregateArgs>): Prisma.PrismaPromise<GetOtpVerificationAggregateType<T>>

    /**
     * Group by OtpVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpVerificationGroupByArgs['orderBy'] }
        : { orderBy?: OtpVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OtpVerification model
   */
  readonly fields: OtpVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OtpVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OtpVerification model
   */ 
  interface OtpVerificationFieldRefs {
    readonly id: FieldRef<"OtpVerification", 'Int'>
    readonly mobile: FieldRef<"OtpVerification", 'String'>
    readonly otp: FieldRef<"OtpVerification", 'String'>
    readonly expiresAt: FieldRef<"OtpVerification", 'DateTime'>
    readonly createdAt: FieldRef<"OtpVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OtpVerification findUnique
   */
  export type OtpVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification findUniqueOrThrow
   */
  export type OtpVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification findFirst
   */
  export type OtpVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpVerifications.
     */
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification findFirstOrThrow
   */
  export type OtpVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter, which OtpVerification to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OtpVerifications.
     */
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification findMany
   */
  export type OtpVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter, which OtpVerifications to fetch.
     */
    where?: OtpVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OtpVerifications to fetch.
     */
    orderBy?: OtpVerificationOrderByWithRelationInput | OtpVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OtpVerifications.
     */
    cursor?: OtpVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OtpVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OtpVerifications.
     */
    skip?: number
    distinct?: OtpVerificationScalarFieldEnum | OtpVerificationScalarFieldEnum[]
  }

  /**
   * OtpVerification create
   */
  export type OtpVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * The data needed to create a OtpVerification.
     */
    data: XOR<OtpVerificationCreateInput, OtpVerificationUncheckedCreateInput>
  }

  /**
   * OtpVerification createMany
   */
  export type OtpVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OtpVerifications.
     */
    data: OtpVerificationCreateManyInput | OtpVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpVerification createManyAndReturn
   */
  export type OtpVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OtpVerifications.
     */
    data: OtpVerificationCreateManyInput | OtpVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OtpVerification update
   */
  export type OtpVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * The data needed to update a OtpVerification.
     */
    data: XOR<OtpVerificationUpdateInput, OtpVerificationUncheckedUpdateInput>
    /**
     * Choose, which OtpVerification to update.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification updateMany
   */
  export type OtpVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OtpVerifications.
     */
    data: XOR<OtpVerificationUpdateManyMutationInput, OtpVerificationUncheckedUpdateManyInput>
    /**
     * Filter which OtpVerifications to update
     */
    where?: OtpVerificationWhereInput
  }

  /**
   * OtpVerification upsert
   */
  export type OtpVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * The filter to search for the OtpVerification to update in case it exists.
     */
    where: OtpVerificationWhereUniqueInput
    /**
     * In case the OtpVerification found by the `where` argument doesn't exist, create a new OtpVerification with this data.
     */
    create: XOR<OtpVerificationCreateInput, OtpVerificationUncheckedCreateInput>
    /**
     * In case the OtpVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpVerificationUpdateInput, OtpVerificationUncheckedUpdateInput>
  }

  /**
   * OtpVerification delete
   */
  export type OtpVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
    /**
     * Filter which OtpVerification to delete.
     */
    where: OtpVerificationWhereUniqueInput
  }

  /**
   * OtpVerification deleteMany
   */
  export type OtpVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OtpVerifications to delete
     */
    where?: OtpVerificationWhereInput
  }

  /**
   * OtpVerification without action
   */
  export type OtpVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OtpVerification
     */
    select?: OtpVerificationSelect<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    title: string | null
    message: string | null
    type: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    adminId: number | null
    title: string | null
    message: string | null
    type: string | null
    link: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    adminId: number
    title: number
    message: number
    type: number
    link: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    adminId?: true
    title?: true
    message?: true
    type?: true
    link?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number | null
    adminId: number | null
    title: string
    message: string
    type: string
    link: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    admin?: boolean | Notification$adminArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adminId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
    admin?: boolean | Notification$adminArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    adminId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Notification$adminArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | Notification$adminArgs<ExtArgs>
    user?: boolean | Notification$userArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      adminId: number | null
      title: string
      message: string
      type: string
      link: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends Notification$adminArgs<ExtArgs> = {}>(args?: Subset<T, Notification$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends Notification$userArgs<ExtArgs> = {}>(args?: Subset<T, Notification$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly adminId: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.admin
   */
  export type Notification$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Notification.user
   */
  export type Notification$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    id: number | null
  }

  export type CampaignSumAggregateOutputType = {
    id: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    templateBody: string | null
    type: string | null
    status: string | null
    schedule: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: number | null
    name: string | null
    subject: string | null
    templateBody: string | null
    type: string | null
    status: string | null
    schedule: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastRunAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    subject: number
    templateBody: number
    type: number
    status: number
    targetAudience: number
    schedule: number
    createdAt: number
    updatedAt: number
    lastRunAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    id?: true
  }

  export type CampaignSumAggregateInputType = {
    id?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    templateBody?: true
    type?: true
    status?: true
    schedule?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    templateBody?: true
    type?: true
    status?: true
    schedule?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    subject?: true
    templateBody?: true
    type?: true
    status?: true
    targetAudience?: true
    schedule?: true
    createdAt?: true
    updatedAt?: true
    lastRunAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: number
    name: string
    subject: string
    templateBody: string
    type: string
    status: string
    targetAudience: JsonValue | null
    schedule: string | null
    createdAt: Date
    updatedAt: Date
    lastRunAt: Date | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    templateBody?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
    logs?: boolean | Campaign$logsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subject?: boolean
    templateBody?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    subject?: boolean
    templateBody?: boolean
    type?: boolean
    status?: boolean
    targetAudience?: boolean
    schedule?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastRunAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | Campaign$logsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      logs: Prisma.$CampaignLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      subject: string
      templateBody: string
      type: string
      status: string
      targetAudience: Prisma.JsonValue | null
      schedule: string | null
      createdAt: Date
      updatedAt: Date
      lastRunAt: Date | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends Campaign$logsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'Int'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly subject: FieldRef<"Campaign", 'String'>
    readonly templateBody: FieldRef<"Campaign", 'String'>
    readonly type: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'String'>
    readonly targetAudience: FieldRef<"Campaign", 'Json'>
    readonly schedule: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly lastRunAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.logs
   */
  export type Campaign$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    cursor?: CampaignLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignLog
   */

  export type AggregateCampaignLog = {
    _count: CampaignLogCountAggregateOutputType | null
    _avg: CampaignLogAvgAggregateOutputType | null
    _sum: CampaignLogSumAggregateOutputType | null
    _min: CampaignLogMinAggregateOutputType | null
    _max: CampaignLogMaxAggregateOutputType | null
  }

  export type CampaignLogAvgAggregateOutputType = {
    id: number | null
    campaignId: number | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignLogSumAggregateOutputType = {
    id: number | null
    campaignId: number | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignLogMinAggregateOutputType = {
    id: number | null
    campaignId: number | null
    runAt: Date | null
    status: string | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignLogMaxAggregateOutputType = {
    id: number | null
    campaignId: number | null
    runAt: Date | null
    status: string | null
    recipientCount: number | null
    sentCount: number | null
    failedCount: number | null
  }

  export type CampaignLogCountAggregateOutputType = {
    id: number
    campaignId: number
    runAt: number
    status: number
    recipientCount: number
    sentCount: number
    failedCount: number
    errorLog: number
    _all: number
  }


  export type CampaignLogAvgAggregateInputType = {
    id?: true
    campaignId?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignLogSumAggregateInputType = {
    id?: true
    campaignId?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignLogMinAggregateInputType = {
    id?: true
    campaignId?: true
    runAt?: true
    status?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignLogMaxAggregateInputType = {
    id?: true
    campaignId?: true
    runAt?: true
    status?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
  }

  export type CampaignLogCountAggregateInputType = {
    id?: true
    campaignId?: true
    runAt?: true
    status?: true
    recipientCount?: true
    sentCount?: true
    failedCount?: true
    errorLog?: true
    _all?: true
  }

  export type CampaignLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLog to aggregate.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignLogs
    **/
    _count?: true | CampaignLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignLogMaxAggregateInputType
  }

  export type GetCampaignLogAggregateType<T extends CampaignLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignLog[P]>
      : GetScalarType<T[P], AggregateCampaignLog[P]>
  }




  export type CampaignLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignLogWhereInput
    orderBy?: CampaignLogOrderByWithAggregationInput | CampaignLogOrderByWithAggregationInput[]
    by: CampaignLogScalarFieldEnum[] | CampaignLogScalarFieldEnum
    having?: CampaignLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignLogCountAggregateInputType | true
    _avg?: CampaignLogAvgAggregateInputType
    _sum?: CampaignLogSumAggregateInputType
    _min?: CampaignLogMinAggregateInputType
    _max?: CampaignLogMaxAggregateInputType
  }

  export type CampaignLogGroupByOutputType = {
    id: number
    campaignId: number
    runAt: Date
    status: string
    recipientCount: number
    sentCount: number
    failedCount: number
    errorLog: JsonValue | null
    _count: CampaignLogCountAggregateOutputType | null
    _avg: CampaignLogAvgAggregateOutputType | null
    _sum: CampaignLogSumAggregateOutputType | null
    _min: CampaignLogMinAggregateOutputType | null
    _max: CampaignLogMaxAggregateOutputType | null
  }

  type GetCampaignLogGroupByPayload<T extends CampaignLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignLogGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignLogGroupByOutputType[P]>
        }
      >
    >


  export type CampaignLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    runAt?: boolean
    status?: boolean
    recipientCount?: boolean
    sentCount?: boolean
    failedCount?: boolean
    errorLog?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLog"]>

  export type CampaignLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    runAt?: boolean
    status?: boolean
    recipientCount?: boolean
    sentCount?: boolean
    failedCount?: boolean
    errorLog?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignLog"]>

  export type CampaignLogSelectScalar = {
    id?: boolean
    campaignId?: boolean
    runAt?: boolean
    status?: boolean
    recipientCount?: boolean
    sentCount?: boolean
    failedCount?: boolean
    errorLog?: boolean
  }

  export type CampaignLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignLog"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      campaignId: number
      runAt: Date
      status: string
      recipientCount: number
      sentCount: number
      failedCount: number
      errorLog: Prisma.JsonValue | null
    }, ExtArgs["result"]["campaignLog"]>
    composites: {}
  }

  type CampaignLogGetPayload<S extends boolean | null | undefined | CampaignLogDefaultArgs> = $Result.GetResult<Prisma.$CampaignLogPayload, S>

  type CampaignLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignLogCountAggregateInputType | true
    }

  export interface CampaignLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignLog'], meta: { name: 'CampaignLog' } }
    /**
     * Find zero or one CampaignLog that matches the filter.
     * @param {CampaignLogFindUniqueArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignLogFindUniqueArgs>(args: SelectSubset<T, CampaignLogFindUniqueArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignLogFindUniqueOrThrowArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindFirstArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignLogFindFirstArgs>(args?: SelectSubset<T, CampaignLogFindFirstArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindFirstOrThrowArgs} args - Arguments to find a CampaignLog
     * @example
     * // Get one CampaignLog
     * const campaignLog = await prisma.campaignLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignLogs
     * const campaignLogs = await prisma.campaignLog.findMany()
     * 
     * // Get first 10 CampaignLogs
     * const campaignLogs = await prisma.campaignLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignLogWithIdOnly = await prisma.campaignLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignLogFindManyArgs>(args?: SelectSubset<T, CampaignLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignLog.
     * @param {CampaignLogCreateArgs} args - Arguments to create a CampaignLog.
     * @example
     * // Create one CampaignLog
     * const CampaignLog = await prisma.campaignLog.create({
     *   data: {
     *     // ... data to create a CampaignLog
     *   }
     * })
     * 
     */
    create<T extends CampaignLogCreateArgs>(args: SelectSubset<T, CampaignLogCreateArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignLogs.
     * @param {CampaignLogCreateManyArgs} args - Arguments to create many CampaignLogs.
     * @example
     * // Create many CampaignLogs
     * const campaignLog = await prisma.campaignLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignLogCreateManyArgs>(args?: SelectSubset<T, CampaignLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignLogs and returns the data saved in the database.
     * @param {CampaignLogCreateManyAndReturnArgs} args - Arguments to create many CampaignLogs.
     * @example
     * // Create many CampaignLogs
     * const campaignLog = await prisma.campaignLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignLogs and only return the `id`
     * const campaignLogWithIdOnly = await prisma.campaignLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignLog.
     * @param {CampaignLogDeleteArgs} args - Arguments to delete one CampaignLog.
     * @example
     * // Delete one CampaignLog
     * const CampaignLog = await prisma.campaignLog.delete({
     *   where: {
     *     // ... filter to delete one CampaignLog
     *   }
     * })
     * 
     */
    delete<T extends CampaignLogDeleteArgs>(args: SelectSubset<T, CampaignLogDeleteArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignLog.
     * @param {CampaignLogUpdateArgs} args - Arguments to update one CampaignLog.
     * @example
     * // Update one CampaignLog
     * const campaignLog = await prisma.campaignLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignLogUpdateArgs>(args: SelectSubset<T, CampaignLogUpdateArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignLogs.
     * @param {CampaignLogDeleteManyArgs} args - Arguments to filter CampaignLogs to delete.
     * @example
     * // Delete a few CampaignLogs
     * const { count } = await prisma.campaignLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignLogDeleteManyArgs>(args?: SelectSubset<T, CampaignLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignLogs
     * const campaignLog = await prisma.campaignLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignLogUpdateManyArgs>(args: SelectSubset<T, CampaignLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignLog.
     * @param {CampaignLogUpsertArgs} args - Arguments to update or create a CampaignLog.
     * @example
     * // Update or create a CampaignLog
     * const campaignLog = await prisma.campaignLog.upsert({
     *   create: {
     *     // ... data to create a CampaignLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignLog we want to update
     *   }
     * })
     */
    upsert<T extends CampaignLogUpsertArgs>(args: SelectSubset<T, CampaignLogUpsertArgs<ExtArgs>>): Prisma__CampaignLogClient<$Result.GetResult<Prisma.$CampaignLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogCountArgs} args - Arguments to filter CampaignLogs to count.
     * @example
     * // Count the number of CampaignLogs
     * const count = await prisma.campaignLog.count({
     *   where: {
     *     // ... the filter for the CampaignLogs we want to count
     *   }
     * })
    **/
    count<T extends CampaignLogCountArgs>(
      args?: Subset<T, CampaignLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignLogAggregateArgs>(args: Subset<T, CampaignLogAggregateArgs>): Prisma.PrismaPromise<GetCampaignLogAggregateType<T>>

    /**
     * Group by CampaignLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignLogGroupByArgs['orderBy'] }
        : { orderBy?: CampaignLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignLog model
   */
  readonly fields: CampaignLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignLog model
   */ 
  interface CampaignLogFieldRefs {
    readonly id: FieldRef<"CampaignLog", 'Int'>
    readonly campaignId: FieldRef<"CampaignLog", 'Int'>
    readonly runAt: FieldRef<"CampaignLog", 'DateTime'>
    readonly status: FieldRef<"CampaignLog", 'String'>
    readonly recipientCount: FieldRef<"CampaignLog", 'Int'>
    readonly sentCount: FieldRef<"CampaignLog", 'Int'>
    readonly failedCount: FieldRef<"CampaignLog", 'Int'>
    readonly errorLog: FieldRef<"CampaignLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * CampaignLog findUnique
   */
  export type CampaignLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog findUniqueOrThrow
   */
  export type CampaignLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog findFirst
   */
  export type CampaignLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLogs.
     */
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog findFirstOrThrow
   */
  export type CampaignLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLog to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignLogs.
     */
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog findMany
   */
  export type CampaignLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter, which CampaignLogs to fetch.
     */
    where?: CampaignLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignLogs to fetch.
     */
    orderBy?: CampaignLogOrderByWithRelationInput | CampaignLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignLogs.
     */
    cursor?: CampaignLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignLogs.
     */
    skip?: number
    distinct?: CampaignLogScalarFieldEnum | CampaignLogScalarFieldEnum[]
  }

  /**
   * CampaignLog create
   */
  export type CampaignLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignLog.
     */
    data: XOR<CampaignLogCreateInput, CampaignLogUncheckedCreateInput>
  }

  /**
   * CampaignLog createMany
   */
  export type CampaignLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignLogs.
     */
    data: CampaignLogCreateManyInput | CampaignLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignLog createManyAndReturn
   */
  export type CampaignLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignLogs.
     */
    data: CampaignLogCreateManyInput | CampaignLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignLog update
   */
  export type CampaignLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignLog.
     */
    data: XOR<CampaignLogUpdateInput, CampaignLogUncheckedUpdateInput>
    /**
     * Choose, which CampaignLog to update.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog updateMany
   */
  export type CampaignLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignLogs.
     */
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyInput>
    /**
     * Filter which CampaignLogs to update
     */
    where?: CampaignLogWhereInput
  }

  /**
   * CampaignLog upsert
   */
  export type CampaignLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignLog to update in case it exists.
     */
    where: CampaignLogWhereUniqueInput
    /**
     * In case the CampaignLog found by the `where` argument doesn't exist, create a new CampaignLog with this data.
     */
    create: XOR<CampaignLogCreateInput, CampaignLogUncheckedCreateInput>
    /**
     * In case the CampaignLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignLogUpdateInput, CampaignLogUncheckedUpdateInput>
  }

  /**
   * CampaignLog delete
   */
  export type CampaignLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
    /**
     * Filter which CampaignLog to delete.
     */
    where: CampaignLogWhereUniqueInput
  }

  /**
   * CampaignLog deleteMany
   */
  export type CampaignLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignLogs to delete
     */
    where?: CampaignLogWhereInput
  }

  /**
   * CampaignLog without action
   */
  export type CampaignLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignLog
     */
    select?: CampaignLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignLogInclude<ExtArgs> | null
  }


  /**
   * Model RateLimit
   */

  export type AggregateRateLimit = {
    _count: RateLimitCountAggregateOutputType | null
    _avg: RateLimitAvgAggregateOutputType | null
    _sum: RateLimitSumAggregateOutputType | null
    _min: RateLimitMinAggregateOutputType | null
    _max: RateLimitMaxAggregateOutputType | null
  }

  export type RateLimitAvgAggregateOutputType = {
    count: number | null
  }

  export type RateLimitSumAggregateOutputType = {
    count: number | null
  }

  export type RateLimitMinAggregateOutputType = {
    key: string | null
    count: number | null
    resetAt: Date | null
  }

  export type RateLimitMaxAggregateOutputType = {
    key: string | null
    count: number | null
    resetAt: Date | null
  }

  export type RateLimitCountAggregateOutputType = {
    key: number
    count: number
    resetAt: number
    _all: number
  }


  export type RateLimitAvgAggregateInputType = {
    count?: true
  }

  export type RateLimitSumAggregateInputType = {
    count?: true
  }

  export type RateLimitMinAggregateInputType = {
    key?: true
    count?: true
    resetAt?: true
  }

  export type RateLimitMaxAggregateInputType = {
    key?: true
    count?: true
    resetAt?: true
  }

  export type RateLimitCountAggregateInputType = {
    key?: true
    count?: true
    resetAt?: true
    _all?: true
  }

  export type RateLimitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimit to aggregate.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RateLimits
    **/
    _count?: true | RateLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RateLimitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RateLimitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RateLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RateLimitMaxAggregateInputType
  }

  export type GetRateLimitAggregateType<T extends RateLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateRateLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRateLimit[P]>
      : GetScalarType<T[P], AggregateRateLimit[P]>
  }




  export type RateLimitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RateLimitWhereInput
    orderBy?: RateLimitOrderByWithAggregationInput | RateLimitOrderByWithAggregationInput[]
    by: RateLimitScalarFieldEnum[] | RateLimitScalarFieldEnum
    having?: RateLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RateLimitCountAggregateInputType | true
    _avg?: RateLimitAvgAggregateInputType
    _sum?: RateLimitSumAggregateInputType
    _min?: RateLimitMinAggregateInputType
    _max?: RateLimitMaxAggregateInputType
  }

  export type RateLimitGroupByOutputType = {
    key: string
    count: number
    resetAt: Date
    _count: RateLimitCountAggregateOutputType | null
    _avg: RateLimitAvgAggregateOutputType | null
    _sum: RateLimitSumAggregateOutputType | null
    _min: RateLimitMinAggregateOutputType | null
    _max: RateLimitMaxAggregateOutputType | null
  }

  type GetRateLimitGroupByPayload<T extends RateLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RateLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RateLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RateLimitGroupByOutputType[P]>
            : GetScalarType<T[P], RateLimitGroupByOutputType[P]>
        }
      >
    >


  export type RateLimitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    count?: boolean
    resetAt?: boolean
  }, ExtArgs["result"]["rateLimit"]>

  export type RateLimitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    count?: boolean
    resetAt?: boolean
  }, ExtArgs["result"]["rateLimit"]>

  export type RateLimitSelectScalar = {
    key?: boolean
    count?: boolean
    resetAt?: boolean
  }


  export type $RateLimitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RateLimit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      count: number
      resetAt: Date
    }, ExtArgs["result"]["rateLimit"]>
    composites: {}
  }

  type RateLimitGetPayload<S extends boolean | null | undefined | RateLimitDefaultArgs> = $Result.GetResult<Prisma.$RateLimitPayload, S>

  type RateLimitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RateLimitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RateLimitCountAggregateInputType | true
    }

  export interface RateLimitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RateLimit'], meta: { name: 'RateLimit' } }
    /**
     * Find zero or one RateLimit that matches the filter.
     * @param {RateLimitFindUniqueArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RateLimitFindUniqueArgs>(args: SelectSubset<T, RateLimitFindUniqueArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RateLimit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RateLimitFindUniqueOrThrowArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RateLimitFindUniqueOrThrowArgs>(args: SelectSubset<T, RateLimitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RateLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindFirstArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RateLimitFindFirstArgs>(args?: SelectSubset<T, RateLimitFindFirstArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RateLimit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindFirstOrThrowArgs} args - Arguments to find a RateLimit
     * @example
     * // Get one RateLimit
     * const rateLimit = await prisma.rateLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RateLimitFindFirstOrThrowArgs>(args?: SelectSubset<T, RateLimitFindFirstOrThrowArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RateLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RateLimits
     * const rateLimits = await prisma.rateLimit.findMany()
     * 
     * // Get first 10 RateLimits
     * const rateLimits = await prisma.rateLimit.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const rateLimitWithKeyOnly = await prisma.rateLimit.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends RateLimitFindManyArgs>(args?: SelectSubset<T, RateLimitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RateLimit.
     * @param {RateLimitCreateArgs} args - Arguments to create a RateLimit.
     * @example
     * // Create one RateLimit
     * const RateLimit = await prisma.rateLimit.create({
     *   data: {
     *     // ... data to create a RateLimit
     *   }
     * })
     * 
     */
    create<T extends RateLimitCreateArgs>(args: SelectSubset<T, RateLimitCreateArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RateLimits.
     * @param {RateLimitCreateManyArgs} args - Arguments to create many RateLimits.
     * @example
     * // Create many RateLimits
     * const rateLimit = await prisma.rateLimit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RateLimitCreateManyArgs>(args?: SelectSubset<T, RateLimitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RateLimits and returns the data saved in the database.
     * @param {RateLimitCreateManyAndReturnArgs} args - Arguments to create many RateLimits.
     * @example
     * // Create many RateLimits
     * const rateLimit = await prisma.rateLimit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RateLimits and only return the `key`
     * const rateLimitWithKeyOnly = await prisma.rateLimit.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RateLimitCreateManyAndReturnArgs>(args?: SelectSubset<T, RateLimitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RateLimit.
     * @param {RateLimitDeleteArgs} args - Arguments to delete one RateLimit.
     * @example
     * // Delete one RateLimit
     * const RateLimit = await prisma.rateLimit.delete({
     *   where: {
     *     // ... filter to delete one RateLimit
     *   }
     * })
     * 
     */
    delete<T extends RateLimitDeleteArgs>(args: SelectSubset<T, RateLimitDeleteArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RateLimit.
     * @param {RateLimitUpdateArgs} args - Arguments to update one RateLimit.
     * @example
     * // Update one RateLimit
     * const rateLimit = await prisma.rateLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RateLimitUpdateArgs>(args: SelectSubset<T, RateLimitUpdateArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RateLimits.
     * @param {RateLimitDeleteManyArgs} args - Arguments to filter RateLimits to delete.
     * @example
     * // Delete a few RateLimits
     * const { count } = await prisma.rateLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RateLimitDeleteManyArgs>(args?: SelectSubset<T, RateLimitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RateLimits
     * const rateLimit = await prisma.rateLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RateLimitUpdateManyArgs>(args: SelectSubset<T, RateLimitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RateLimit.
     * @param {RateLimitUpsertArgs} args - Arguments to update or create a RateLimit.
     * @example
     * // Update or create a RateLimit
     * const rateLimit = await prisma.rateLimit.upsert({
     *   create: {
     *     // ... data to create a RateLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RateLimit we want to update
     *   }
     * })
     */
    upsert<T extends RateLimitUpsertArgs>(args: SelectSubset<T, RateLimitUpsertArgs<ExtArgs>>): Prisma__RateLimitClient<$Result.GetResult<Prisma.$RateLimitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RateLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitCountArgs} args - Arguments to filter RateLimits to count.
     * @example
     * // Count the number of RateLimits
     * const count = await prisma.rateLimit.count({
     *   where: {
     *     // ... the filter for the RateLimits we want to count
     *   }
     * })
    **/
    count<T extends RateLimitCountArgs>(
      args?: Subset<T, RateLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RateLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RateLimitAggregateArgs>(args: Subset<T, RateLimitAggregateArgs>): Prisma.PrismaPromise<GetRateLimitAggregateType<T>>

    /**
     * Group by RateLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RateLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RateLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RateLimitGroupByArgs['orderBy'] }
        : { orderBy?: RateLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RateLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRateLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RateLimit model
   */
  readonly fields: RateLimitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RateLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RateLimitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RateLimit model
   */ 
  interface RateLimitFieldRefs {
    readonly key: FieldRef<"RateLimit", 'String'>
    readonly count: FieldRef<"RateLimit", 'Int'>
    readonly resetAt: FieldRef<"RateLimit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RateLimit findUnique
   */
  export type RateLimitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit findUniqueOrThrow
   */
  export type RateLimitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit findFirst
   */
  export type RateLimitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimits.
     */
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit findFirstOrThrow
   */
  export type RateLimitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter, which RateLimit to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RateLimits.
     */
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit findMany
   */
  export type RateLimitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter, which RateLimits to fetch.
     */
    where?: RateLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RateLimits to fetch.
     */
    orderBy?: RateLimitOrderByWithRelationInput | RateLimitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RateLimits.
     */
    cursor?: RateLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RateLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RateLimits.
     */
    skip?: number
    distinct?: RateLimitScalarFieldEnum | RateLimitScalarFieldEnum[]
  }

  /**
   * RateLimit create
   */
  export type RateLimitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * The data needed to create a RateLimit.
     */
    data: XOR<RateLimitCreateInput, RateLimitUncheckedCreateInput>
  }

  /**
   * RateLimit createMany
   */
  export type RateLimitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RateLimits.
     */
    data: RateLimitCreateManyInput | RateLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimit createManyAndReturn
   */
  export type RateLimitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RateLimits.
     */
    data: RateLimitCreateManyInput | RateLimitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RateLimit update
   */
  export type RateLimitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * The data needed to update a RateLimit.
     */
    data: XOR<RateLimitUpdateInput, RateLimitUncheckedUpdateInput>
    /**
     * Choose, which RateLimit to update.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit updateMany
   */
  export type RateLimitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RateLimits.
     */
    data: XOR<RateLimitUpdateManyMutationInput, RateLimitUncheckedUpdateManyInput>
    /**
     * Filter which RateLimits to update
     */
    where?: RateLimitWhereInput
  }

  /**
   * RateLimit upsert
   */
  export type RateLimitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * The filter to search for the RateLimit to update in case it exists.
     */
    where: RateLimitWhereUniqueInput
    /**
     * In case the RateLimit found by the `where` argument doesn't exist, create a new RateLimit with this data.
     */
    create: XOR<RateLimitCreateInput, RateLimitUncheckedCreateInput>
    /**
     * In case the RateLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RateLimitUpdateInput, RateLimitUncheckedUpdateInput>
  }

  /**
   * RateLimit delete
   */
  export type RateLimitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
    /**
     * Filter which RateLimit to delete.
     */
    where: RateLimitWhereUniqueInput
  }

  /**
   * RateLimit deleteMany
   */
  export type RateLimitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RateLimits to delete
     */
    where?: RateLimitWhereInput
  }

  /**
   * RateLimit without action
   */
  export type RateLimitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RateLimit
     */
    select?: RateLimitSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    userId: 'userId',
    fullName: 'fullName',
    mobileNumber: 'mobileNumber',
    childInAchariya: 'childInAchariya',
    childName: 'childName',
    grade: 'grade',
    campusId: 'campusId',
    bankAccountDetails: 'bankAccountDetails',
    referralCode: 'referralCode',
    confirmedReferralCount: 'confirmedReferralCount',
    yearFeeBenefitPercent: 'yearFeeBenefitPercent',
    longTermBenefitPercent: 'longTermBenefitPercent',
    lastActiveYear: 'lastActiveYear',
    isFiveStarMember: 'isFiveStarMember',
    assignedCampus: 'assignedCampus',
    studentFee: 'studentFee',
    academicYear: 'academicYear',
    createdAt: 'createdAt',
    profileImage: 'profileImage',
    email: 'email',
    address: 'address',
    paymentAmount: 'paymentAmount',
    paymentStatus: 'paymentStatus',
    transactionId: 'transactionId',
    aadharNo: 'aadharNo',
    childEprNo: 'childEprNo',
    empId: 'empId',
    password: 'password',
    deletionRequestedAt: 'deletionRequestedAt',
    role: 'role',
    status: 'status',
    benefitStatus: 'benefitStatus'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    studentId: 'studentId',
    fullName: 'fullName',
    parentId: 'parentId',
    campusId: 'campusId',
    grade: 'grade',
    section: 'section',
    rollNumber: 'rollNumber',
    academicYear: 'academicYear',
    status: 'status',
    baseFee: 'baseFee',
    discountPercent: 'discountPercent',
    referralLeadId: 'referralLeadId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ambassadorId: 'ambassadorId',
    admissionNumber: 'admissionNumber',
    selectedFeeType: 'selectedFeeType',
    annualFee: 'annualFee'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ReferralLeadScalarFieldEnum: {
    leadId: 'leadId',
    userId: 'userId',
    parentName: 'parentName',
    parentMobile: 'parentMobile',
    campusId: 'campusId',
    campus: 'campus',
    gradeInterested: 'gradeInterested',
    admittedYear: 'admittedYear',
    confirmedDate: 'confirmedDate',
    createdAt: 'createdAt',
    studentName: 'studentName',
    leadStatus: 'leadStatus',
    admissionNumber: 'admissionNumber',
    section: 'section',
    selectedFeeType: 'selectedFeeType',
    annualFee: 'annualFee'
  };

  export type ReferralLeadScalarFieldEnum = (typeof ReferralLeadScalarFieldEnum)[keyof typeof ReferralLeadScalarFieldEnum]


  export const BenefitSlabScalarFieldEnum: {
    slabId: 'slabId',
    tierName: 'tierName',
    referralCount: 'referralCount',
    yearFeeBenefitPercent: 'yearFeeBenefitPercent',
    longTermExtraPercent: 'longTermExtraPercent',
    baseLongTermPercent: 'baseLongTermPercent',
    description: 'description'
  };

  export type BenefitSlabScalarFieldEnum = (typeof BenefitSlabScalarFieldEnum)[keyof typeof BenefitSlabScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    adminId: 'adminId',
    adminName: 'adminName',
    adminMobile: 'adminMobile',
    assignedCampus: 'assignedCampus',
    createdAt: 'createdAt',
    profileImage: 'profileImage',
    email: 'email',
    address: 'address',
    password: 'password',
    role: 'role',
    status: 'status'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    allowNewRegistrations: 'allowNewRegistrations',
    defaultStudentFee: 'defaultStudentFee',
    maintenanceMode: 'maintenanceMode',
    staffReferralText: 'staffReferralText',
    parentReferralText: 'parentReferralText',
    staffWelcomeMessage: 'staffWelcomeMessage',
    parentWelcomeMessage: 'parentWelcomeMessage',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    alumniReferralText: 'alumniReferralText',
    alumniWelcomeMessage: 'alumniWelcomeMessage'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    year: 'year',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    isCurrent: 'isCurrent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const LeadManagementSettingsScalarFieldEnum: {
    id: 'id',
    autoAssignLeads: 'autoAssignLeads',
    leadStaleDays: 'leadStaleDays',
    followupEscalationDays: 'followupEscalationDays',
    duplicateDetectionEnabled: 'duplicateDetectionEnabled',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type LeadManagementSettingsScalarFieldEnum = (typeof LeadManagementSettingsScalarFieldEnum)[keyof typeof LeadManagementSettingsScalarFieldEnum]


  export const SecuritySettingsScalarFieldEnum: {
    id: 'id',
    sessionTimeoutMinutes: 'sessionTimeoutMinutes',
    maxLoginAttempts: 'maxLoginAttempts',
    passwordResetExpiryHours: 'passwordResetExpiryHours',
    twoFactorAuthEnabled: 'twoFactorAuthEnabled',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    ipWhitelist: 'ipWhitelist'
  };

  export type SecuritySettingsScalarFieldEnum = (typeof SecuritySettingsScalarFieldEnum)[keyof typeof SecuritySettingsScalarFieldEnum]


  export const DataRetentionSettingsScalarFieldEnum: {
    id: 'id',
    keepInactiveDataMonths: 'keepInactiveDataMonths',
    archiveLeadsAfterDays: 'archiveLeadsAfterDays',
    backupFrequencyDays: 'backupFrequencyDays',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type DataRetentionSettingsScalarFieldEnum = (typeof DataRetentionSettingsScalarFieldEnum)[keyof typeof DataRetentionSettingsScalarFieldEnum]


  export const RolePermissionsScalarFieldEnum: {
    id: 'id',
    role: 'role',
    analyticsAccess: 'analyticsAccess',
    analyticsScope: 'analyticsScope',
    userMgmtAccess: 'userMgmtAccess',
    userMgmtScope: 'userMgmtScope',
    userMgmtCreate: 'userMgmtCreate',
    userMgmtEdit: 'userMgmtEdit',
    userMgmtDelete: 'userMgmtDelete',
    studentMgmtAccess: 'studentMgmtAccess',
    studentMgmtScope: 'studentMgmtScope',
    adminMgmtAccess: 'adminMgmtAccess',
    adminMgmtScope: 'adminMgmtScope',
    adminMgmtCreate: 'adminMgmtCreate',
    adminMgmtEdit: 'adminMgmtEdit',
    adminMgmtDelete: 'adminMgmtDelete',
    campusPerfAccess: 'campusPerfAccess',
    campusPerfScope: 'campusPerfScope',
    reportsAccess: 'reportsAccess',
    reportsScope: 'reportsScope',
    settlementsAccess: 'settlementsAccess',
    settlementsScope: 'settlementsScope',
    marketingKitAccess: 'marketingKitAccess',
    marketingKitScope: 'marketingKitScope',
    auditLogAccess: 'auditLogAccess',
    auditLogScope: 'auditLogScope',
    supportDeskAccess: 'supportDeskAccess',
    supportDeskScope: 'supportDeskScope',
    referralSubmissionAccess: 'referralSubmissionAccess',
    referralSubmissionScope: 'referralSubmissionScope',
    referralTrackingAccess: 'referralTrackingAccess',
    referralTrackingScope: 'referralTrackingScope',
    savingsCalculatorAccess: 'savingsCalculatorAccess',
    savingsCalculatorScope: 'savingsCalculatorScope',
    rulesAccessAccess: 'rulesAccessAccess',
    rulesAccessScope: 'rulesAccessScope',
    settingsAccess: 'settingsAccess',
    settingsScope: 'settingsScope',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy',
    studentMgmtCreate: 'studentMgmtCreate',
    studentMgmtDelete: 'studentMgmtDelete',
    studentMgmtEdit: 'studentMgmtEdit',
    deletionHubAccess: 'deletionHubAccess',
    deletionHubScope: 'deletionHubScope',
    passwordResetAccess: 'passwordResetAccess',
    passwordResetScope: 'passwordResetScope',
    engagementCentreAccess: 'engagementCentreAccess',
    engagementCentreScope: 'engagementCentreScope',
    feeManagementAccess: 'feeManagementAccess',
    feeManagementScope: 'feeManagementScope'
  };

  export type RolePermissionsScalarFieldEnum = (typeof RolePermissionsScalarFieldEnum)[keyof typeof RolePermissionsScalarFieldEnum]


  export const SettlementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    status: 'status',
    paymentMethod: 'paymentMethod',
    bankReference: 'bankReference',
    payoutDate: 'payoutDate',
    processedBy: 'processedBy',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettlementScalarFieldEnum = (typeof SettlementScalarFieldEnum)[keyof typeof SettlementScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    category: 'category',
    fileUrl: 'fileUrl',
    thumbnailUrl: 'thumbnailUrl',
    isActive: 'isActive',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    userId: 'userId',
    action: 'action',
    module: 'module',
    targetId: 'targetId',
    description: 'description',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SupportTicketScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    category: 'category',
    priority: 'priority',
    status: 'status',
    assignedAdminId: 'assignedAdminId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    campus: 'campus',
    message: 'message',
    resolvedAt: 'resolvedAt',
    escalationLevel: 'escalationLevel',
    lastEscalatedAt: 'lastEscalatedAt'
  };

  export type SupportTicketScalarFieldEnum = (typeof SupportTicketScalarFieldEnum)[keyof typeof SupportTicketScalarFieldEnum]


  export const TicketMessageScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    senderId: 'senderId',
    senderType: 'senderType',
    message: 'message',
    isInternal: 'isInternal',
    createdAt: 'createdAt'
  };

  export type TicketMessageScalarFieldEnum = (typeof TicketMessageScalarFieldEnum)[keyof typeof TicketMessageScalarFieldEnum]


  export const CampusScalarFieldEnum: {
    id: 'id',
    campusName: 'campusName',
    campusCode: 'campusCode',
    location: 'location',
    grades: 'grades',
    maxCapacity: 'maxCapacity',
    currentEnrollment: 'currentEnrollment',
    isActive: 'isActive',
    campusHeadId: 'campusHeadId',
    contactEmail: 'contactEmail',
    contactPhone: 'contactPhone',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampusScalarFieldEnum = (typeof CampusScalarFieldEnum)[keyof typeof CampusScalarFieldEnum]


  export const CampusTargetScalarFieldEnum: {
    id: 'id',
    campusId: 'campusId',
    month: 'month',
    year: 'year',
    leadTarget: 'leadTarget',
    admissionTarget: 'admissionTarget',
    updatedAt: 'updatedAt'
  };

  export type CampusTargetScalarFieldEnum = (typeof CampusTargetScalarFieldEnum)[keyof typeof CampusTargetScalarFieldEnum]


  export const GradeFeeScalarFieldEnum: {
    id: 'id',
    grade: 'grade',
    annualFee_otp: 'annualFee_otp',
    annualFee_wotp: 'annualFee_wotp',
    campusId: 'campusId',
    academicYear: 'academicYear'
  };

  export type GradeFeeScalarFieldEnum = (typeof GradeFeeScalarFieldEnum)[keyof typeof GradeFeeScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    id: 'id',
    emailNotifications: 'emailNotifications',
    smsNotifications: 'smsNotifications',
    whatsappNotifications: 'whatsappNotifications',
    leadFollowupReminders: 'leadFollowupReminders',
    reminderFrequencyDays: 'reminderFrequencyDays',
    notifySuperAdminOnNewAdmins: 'notifySuperAdminOnNewAdmins',
    notifyCampusHeadOnNewLeads: 'notifyCampusHeadOnNewLeads',
    updatedAt: 'updatedAt',
    updatedBy: 'updatedBy'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const MarketingAssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    description: 'description',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingAssetScalarFieldEnum = (typeof MarketingAssetScalarFieldEnum)[keyof typeof MarketingAssetScalarFieldEnum]


  export const OtpVerificationScalarFieldEnum: {
    id: 'id',
    mobile: 'mobile',
    otp: 'otp',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OtpVerificationScalarFieldEnum = (typeof OtpVerificationScalarFieldEnum)[keyof typeof OtpVerificationScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adminId: 'adminId',
    title: 'title',
    message: 'message',
    type: 'type',
    link: 'link',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subject: 'subject',
    templateBody: 'templateBody',
    type: 'type',
    status: 'status',
    targetAudience: 'targetAudience',
    schedule: 'schedule',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastRunAt: 'lastRunAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignLogScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    runAt: 'runAt',
    status: 'status',
    recipientCount: 'recipientCount',
    sentCount: 'sentCount',
    failedCount: 'failedCount',
    errorLog: 'errorLog'
  };

  export type CampaignLogScalarFieldEnum = (typeof CampaignLogScalarFieldEnum)[keyof typeof CampaignLogScalarFieldEnum]


  export const RateLimitScalarFieldEnum: {
    key: 'key',
    count: 'count',
    resetAt: 'resetAt'
  };

  export type RateLimitScalarFieldEnum = (typeof RateLimitScalarFieldEnum)[keyof typeof RateLimitScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'FeeType'
   */
  export type EnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType'>
    


  /**
   * Reference to a field of type 'FeeType[]'
   */
  export type ListEnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'AdminRole'
   */
  export type EnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole'>
    


  /**
   * Reference to a field of type 'AdminRole[]'
   */
  export type ListEnumAdminRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    userId?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    mobileNumber?: StringFilter<"User"> | string
    childInAchariya?: BoolFilter<"User"> | boolean
    childName?: StringNullableFilter<"User"> | string | null
    grade?: StringNullableFilter<"User"> | string | null
    campusId?: IntNullableFilter<"User"> | number | null
    bankAccountDetails?: StringNullableFilter<"User"> | string | null
    referralCode?: StringNullableFilter<"User"> | string | null
    confirmedReferralCount?: IntFilter<"User"> | number
    yearFeeBenefitPercent?: FloatFilter<"User"> | number
    longTermBenefitPercent?: FloatFilter<"User"> | number
    lastActiveYear?: IntNullableFilter<"User"> | number | null
    isFiveStarMember?: BoolFilter<"User"> | boolean
    assignedCampus?: StringNullableFilter<"User"> | string | null
    studentFee?: IntFilter<"User"> | number
    academicYear?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    profileImage?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    paymentAmount?: IntFilter<"User"> | number
    paymentStatus?: StringFilter<"User"> | string
    transactionId?: StringNullableFilter<"User"> | string | null
    aadharNo?: StringNullableFilter<"User"> | string | null
    childEprNo?: StringNullableFilter<"User"> | string | null
    empId?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    deletionRequestedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    notifications?: NotificationListRelationFilter
    referrals?: ReferralLeadListRelationFilter
    settlements?: SettlementListRelationFilter
    referredStudents?: StudentListRelationFilter
    students?: StudentListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    userId?: SortOrder
    fullName?: SortOrder
    mobileNumber?: SortOrder
    childInAchariya?: SortOrder
    childName?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    campusId?: SortOrderInput | SortOrder
    bankAccountDetails?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrderInput | SortOrder
    isFiveStarMember?: SortOrder
    assignedCampus?: SortOrderInput | SortOrder
    studentFee?: SortOrder
    academicYear?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paymentAmount?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    aadharNo?: SortOrderInput | SortOrder
    childEprNo?: SortOrderInput | SortOrder
    empId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    deletionRequestedAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    benefitStatus?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
    referrals?: ReferralLeadOrderByRelationAggregateInput
    settlements?: SettlementOrderByRelationAggregateInput
    referredStudents?: StudentOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    supportTickets?: SupportTicketOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    mobileNumber?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    childInAchariya?: BoolFilter<"User"> | boolean
    childName?: StringNullableFilter<"User"> | string | null
    grade?: StringNullableFilter<"User"> | string | null
    campusId?: IntNullableFilter<"User"> | number | null
    bankAccountDetails?: StringNullableFilter<"User"> | string | null
    confirmedReferralCount?: IntFilter<"User"> | number
    yearFeeBenefitPercent?: FloatFilter<"User"> | number
    longTermBenefitPercent?: FloatFilter<"User"> | number
    lastActiveYear?: IntNullableFilter<"User"> | number | null
    isFiveStarMember?: BoolFilter<"User"> | boolean
    assignedCampus?: StringNullableFilter<"User"> | string | null
    studentFee?: IntFilter<"User"> | number
    academicYear?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    profileImage?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    paymentAmount?: IntFilter<"User"> | number
    paymentStatus?: StringFilter<"User"> | string
    transactionId?: StringNullableFilter<"User"> | string | null
    aadharNo?: StringNullableFilter<"User"> | string | null
    childEprNo?: StringNullableFilter<"User"> | string | null
    empId?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    deletionRequestedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFilter<"User"> | $Enums.AccountStatus
    notifications?: NotificationListRelationFilter
    referrals?: ReferralLeadListRelationFilter
    settlements?: SettlementListRelationFilter
    referredStudents?: StudentListRelationFilter
    students?: StudentListRelationFilter
    supportTickets?: SupportTicketListRelationFilter
  }, "userId" | "mobileNumber" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    userId?: SortOrder
    fullName?: SortOrder
    mobileNumber?: SortOrder
    childInAchariya?: SortOrder
    childName?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    campusId?: SortOrderInput | SortOrder
    bankAccountDetails?: SortOrderInput | SortOrder
    referralCode?: SortOrderInput | SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrderInput | SortOrder
    isFiveStarMember?: SortOrder
    assignedCampus?: SortOrderInput | SortOrder
    studentFee?: SortOrder
    academicYear?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    paymentAmount?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    aadharNo?: SortOrderInput | SortOrder
    childEprNo?: SortOrderInput | SortOrder
    empId?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    deletionRequestedAt?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    benefitStatus?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"User"> | number
    fullName?: StringWithAggregatesFilter<"User"> | string
    mobileNumber?: StringWithAggregatesFilter<"User"> | string
    childInAchariya?: BoolWithAggregatesFilter<"User"> | boolean
    childName?: StringNullableWithAggregatesFilter<"User"> | string | null
    grade?: StringNullableWithAggregatesFilter<"User"> | string | null
    campusId?: IntNullableWithAggregatesFilter<"User"> | number | null
    bankAccountDetails?: StringNullableWithAggregatesFilter<"User"> | string | null
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    confirmedReferralCount?: IntWithAggregatesFilter<"User"> | number
    yearFeeBenefitPercent?: FloatWithAggregatesFilter<"User"> | number
    longTermBenefitPercent?: FloatWithAggregatesFilter<"User"> | number
    lastActiveYear?: IntNullableWithAggregatesFilter<"User"> | number | null
    isFiveStarMember?: BoolWithAggregatesFilter<"User"> | boolean
    assignedCampus?: StringNullableWithAggregatesFilter<"User"> | string | null
    studentFee?: IntWithAggregatesFilter<"User"> | number
    academicYear?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    paymentAmount?: IntWithAggregatesFilter<"User"> | number
    paymentStatus?: StringWithAggregatesFilter<"User"> | string
    transactionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    aadharNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    childEprNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    empId?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    deletionRequestedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusWithAggregatesFilter<"User"> | $Enums.AccountStatus
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    studentId?: IntFilter<"Student"> | number
    fullName?: StringFilter<"Student"> | string
    parentId?: IntFilter<"Student"> | number
    campusId?: IntFilter<"Student"> | number
    grade?: StringFilter<"Student"> | string
    section?: StringNullableFilter<"Student"> | string | null
    rollNumber?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    baseFee?: IntFilter<"Student"> | number
    discountPercent?: FloatFilter<"Student"> | number
    referralLeadId?: IntNullableFilter<"Student"> | number | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    ambassadorId?: IntNullableFilter<"Student"> | number | null
    admissionNumber?: StringNullableFilter<"Student"> | string | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"Student"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"Student"> | number | null
    ambassador?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    parent?: XOR<UserRelationFilter, UserWhereInput>
    referralLead?: XOR<ReferralLeadNullableRelationFilter, ReferralLeadWhereInput> | null
  }

  export type StudentOrderByWithRelationInput = {
    studentId?: SortOrder
    fullName?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    grade?: SortOrder
    section?: SortOrderInput | SortOrder
    rollNumber?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambassadorId?: SortOrderInput | SortOrder
    admissionNumber?: SortOrderInput | SortOrder
    selectedFeeType?: SortOrderInput | SortOrder
    annualFee?: SortOrderInput | SortOrder
    ambassador?: UserOrderByWithRelationInput
    campus?: CampusOrderByWithRelationInput
    parent?: UserOrderByWithRelationInput
    referralLead?: ReferralLeadOrderByWithRelationInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    studentId?: number
    referralLeadId?: number
    admissionNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    fullName?: StringFilter<"Student"> | string
    parentId?: IntFilter<"Student"> | number
    campusId?: IntFilter<"Student"> | number
    grade?: StringFilter<"Student"> | string
    section?: StringNullableFilter<"Student"> | string | null
    rollNumber?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    baseFee?: IntFilter<"Student"> | number
    discountPercent?: FloatFilter<"Student"> | number
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    ambassadorId?: IntNullableFilter<"Student"> | number | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"Student"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"Student"> | number | null
    ambassador?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    parent?: XOR<UserRelationFilter, UserWhereInput>
    referralLead?: XOR<ReferralLeadNullableRelationFilter, ReferralLeadWhereInput> | null
  }, "studentId" | "referralLeadId" | "admissionNumber">

  export type StudentOrderByWithAggregationInput = {
    studentId?: SortOrder
    fullName?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    grade?: SortOrder
    section?: SortOrderInput | SortOrder
    rollNumber?: SortOrderInput | SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambassadorId?: SortOrderInput | SortOrder
    admissionNumber?: SortOrderInput | SortOrder
    selectedFeeType?: SortOrderInput | SortOrder
    annualFee?: SortOrderInput | SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    studentId?: IntWithAggregatesFilter<"Student"> | number
    fullName?: StringWithAggregatesFilter<"Student"> | string
    parentId?: IntWithAggregatesFilter<"Student"> | number
    campusId?: IntWithAggregatesFilter<"Student"> | number
    grade?: StringWithAggregatesFilter<"Student"> | string
    section?: StringNullableWithAggregatesFilter<"Student"> | string | null
    rollNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    academicYear?: StringWithAggregatesFilter<"Student"> | string
    status?: StringWithAggregatesFilter<"Student"> | string
    baseFee?: IntWithAggregatesFilter<"Student"> | number
    discountPercent?: FloatWithAggregatesFilter<"Student"> | number
    referralLeadId?: IntNullableWithAggregatesFilter<"Student"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    ambassadorId?: IntNullableWithAggregatesFilter<"Student"> | number | null
    admissionNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    selectedFeeType?: EnumFeeTypeNullableWithAggregatesFilter<"Student"> | $Enums.FeeType | null
    annualFee?: IntNullableWithAggregatesFilter<"Student"> | number | null
  }

  export type ReferralLeadWhereInput = {
    AND?: ReferralLeadWhereInput | ReferralLeadWhereInput[]
    OR?: ReferralLeadWhereInput[]
    NOT?: ReferralLeadWhereInput | ReferralLeadWhereInput[]
    leadId?: IntFilter<"ReferralLead"> | number
    userId?: IntFilter<"ReferralLead"> | number
    parentName?: StringFilter<"ReferralLead"> | string
    parentMobile?: StringFilter<"ReferralLead"> | string
    campusId?: IntNullableFilter<"ReferralLead"> | number | null
    campus?: StringNullableFilter<"ReferralLead"> | string | null
    gradeInterested?: StringNullableFilter<"ReferralLead"> | string | null
    admittedYear?: StringNullableFilter<"ReferralLead"> | string | null
    confirmedDate?: DateTimeNullableFilter<"ReferralLead"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralLead"> | Date | string
    studentName?: StringNullableFilter<"ReferralLead"> | string | null
    leadStatus?: EnumLeadStatusFilter<"ReferralLead"> | $Enums.LeadStatus
    admissionNumber?: StringNullableFilter<"ReferralLead"> | string | null
    section?: StringNullableFilter<"ReferralLead"> | string | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"ReferralLead"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"ReferralLead"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }

  export type ReferralLeadOrderByWithRelationInput = {
    leadId?: SortOrder
    userId?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    campusId?: SortOrderInput | SortOrder
    campus?: SortOrderInput | SortOrder
    gradeInterested?: SortOrderInput | SortOrder
    admittedYear?: SortOrderInput | SortOrder
    confirmedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studentName?: SortOrderInput | SortOrder
    leadStatus?: SortOrder
    admissionNumber?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    selectedFeeType?: SortOrderInput | SortOrder
    annualFee?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type ReferralLeadWhereUniqueInput = Prisma.AtLeast<{
    leadId?: number
    AND?: ReferralLeadWhereInput | ReferralLeadWhereInput[]
    OR?: ReferralLeadWhereInput[]
    NOT?: ReferralLeadWhereInput | ReferralLeadWhereInput[]
    userId?: IntFilter<"ReferralLead"> | number
    parentName?: StringFilter<"ReferralLead"> | string
    parentMobile?: StringFilter<"ReferralLead"> | string
    campusId?: IntNullableFilter<"ReferralLead"> | number | null
    campus?: StringNullableFilter<"ReferralLead"> | string | null
    gradeInterested?: StringNullableFilter<"ReferralLead"> | string | null
    admittedYear?: StringNullableFilter<"ReferralLead"> | string | null
    confirmedDate?: DateTimeNullableFilter<"ReferralLead"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralLead"> | Date | string
    studentName?: StringNullableFilter<"ReferralLead"> | string | null
    leadStatus?: EnumLeadStatusFilter<"ReferralLead"> | $Enums.LeadStatus
    admissionNumber?: StringNullableFilter<"ReferralLead"> | string | null
    section?: StringNullableFilter<"ReferralLead"> | string | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"ReferralLead"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"ReferralLead"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
  }, "leadId">

  export type ReferralLeadOrderByWithAggregationInput = {
    leadId?: SortOrder
    userId?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    campusId?: SortOrderInput | SortOrder
    campus?: SortOrderInput | SortOrder
    gradeInterested?: SortOrderInput | SortOrder
    admittedYear?: SortOrderInput | SortOrder
    confirmedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studentName?: SortOrderInput | SortOrder
    leadStatus?: SortOrder
    admissionNumber?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    selectedFeeType?: SortOrderInput | SortOrder
    annualFee?: SortOrderInput | SortOrder
    _count?: ReferralLeadCountOrderByAggregateInput
    _avg?: ReferralLeadAvgOrderByAggregateInput
    _max?: ReferralLeadMaxOrderByAggregateInput
    _min?: ReferralLeadMinOrderByAggregateInput
    _sum?: ReferralLeadSumOrderByAggregateInput
  }

  export type ReferralLeadScalarWhereWithAggregatesInput = {
    AND?: ReferralLeadScalarWhereWithAggregatesInput | ReferralLeadScalarWhereWithAggregatesInput[]
    OR?: ReferralLeadScalarWhereWithAggregatesInput[]
    NOT?: ReferralLeadScalarWhereWithAggregatesInput | ReferralLeadScalarWhereWithAggregatesInput[]
    leadId?: IntWithAggregatesFilter<"ReferralLead"> | number
    userId?: IntWithAggregatesFilter<"ReferralLead"> | number
    parentName?: StringWithAggregatesFilter<"ReferralLead"> | string
    parentMobile?: StringWithAggregatesFilter<"ReferralLead"> | string
    campusId?: IntNullableWithAggregatesFilter<"ReferralLead"> | number | null
    campus?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    gradeInterested?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    admittedYear?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    confirmedDate?: DateTimeNullableWithAggregatesFilter<"ReferralLead"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReferralLead"> | Date | string
    studentName?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    leadStatus?: EnumLeadStatusWithAggregatesFilter<"ReferralLead"> | $Enums.LeadStatus
    admissionNumber?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    section?: StringNullableWithAggregatesFilter<"ReferralLead"> | string | null
    selectedFeeType?: EnumFeeTypeNullableWithAggregatesFilter<"ReferralLead"> | $Enums.FeeType | null
    annualFee?: IntNullableWithAggregatesFilter<"ReferralLead"> | number | null
  }

  export type BenefitSlabWhereInput = {
    AND?: BenefitSlabWhereInput | BenefitSlabWhereInput[]
    OR?: BenefitSlabWhereInput[]
    NOT?: BenefitSlabWhereInput | BenefitSlabWhereInput[]
    slabId?: IntFilter<"BenefitSlab"> | number
    tierName?: StringNullableFilter<"BenefitSlab"> | string | null
    referralCount?: IntFilter<"BenefitSlab"> | number
    yearFeeBenefitPercent?: FloatFilter<"BenefitSlab"> | number
    longTermExtraPercent?: FloatFilter<"BenefitSlab"> | number
    baseLongTermPercent?: FloatFilter<"BenefitSlab"> | number
    description?: StringNullableFilter<"BenefitSlab"> | string | null
  }

  export type BenefitSlabOrderByWithRelationInput = {
    slabId?: SortOrder
    tierName?: SortOrderInput | SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type BenefitSlabWhereUniqueInput = Prisma.AtLeast<{
    slabId?: number
    referralCount?: number
    AND?: BenefitSlabWhereInput | BenefitSlabWhereInput[]
    OR?: BenefitSlabWhereInput[]
    NOT?: BenefitSlabWhereInput | BenefitSlabWhereInput[]
    tierName?: StringNullableFilter<"BenefitSlab"> | string | null
    yearFeeBenefitPercent?: FloatFilter<"BenefitSlab"> | number
    longTermExtraPercent?: FloatFilter<"BenefitSlab"> | number
    baseLongTermPercent?: FloatFilter<"BenefitSlab"> | number
    description?: StringNullableFilter<"BenefitSlab"> | string | null
  }, "slabId" | "referralCount">

  export type BenefitSlabOrderByWithAggregationInput = {
    slabId?: SortOrder
    tierName?: SortOrderInput | SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: BenefitSlabCountOrderByAggregateInput
    _avg?: BenefitSlabAvgOrderByAggregateInput
    _max?: BenefitSlabMaxOrderByAggregateInput
    _min?: BenefitSlabMinOrderByAggregateInput
    _sum?: BenefitSlabSumOrderByAggregateInput
  }

  export type BenefitSlabScalarWhereWithAggregatesInput = {
    AND?: BenefitSlabScalarWhereWithAggregatesInput | BenefitSlabScalarWhereWithAggregatesInput[]
    OR?: BenefitSlabScalarWhereWithAggregatesInput[]
    NOT?: BenefitSlabScalarWhereWithAggregatesInput | BenefitSlabScalarWhereWithAggregatesInput[]
    slabId?: IntWithAggregatesFilter<"BenefitSlab"> | number
    tierName?: StringNullableWithAggregatesFilter<"BenefitSlab"> | string | null
    referralCount?: IntWithAggregatesFilter<"BenefitSlab"> | number
    yearFeeBenefitPercent?: FloatWithAggregatesFilter<"BenefitSlab"> | number
    longTermExtraPercent?: FloatWithAggregatesFilter<"BenefitSlab"> | number
    baseLongTermPercent?: FloatWithAggregatesFilter<"BenefitSlab"> | number
    description?: StringNullableWithAggregatesFilter<"BenefitSlab"> | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    adminId?: IntFilter<"Admin"> | number
    adminName?: StringFilter<"Admin"> | string
    adminMobile?: StringFilter<"Admin"> | string
    assignedCampus?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    profileImage?: StringNullableFilter<"Admin"> | string | null
    email?: StringNullableFilter<"Admin"> | string | null
    address?: StringNullableFilter<"Admin"> | string | null
    password?: StringNullableFilter<"Admin"> | string | null
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    notifications?: NotificationListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    adminId?: SortOrder
    adminName?: SortOrder
    adminMobile?: SortOrder
    assignedCampus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    adminId?: number
    adminMobile?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    adminName?: StringFilter<"Admin"> | string
    assignedCampus?: StringNullableFilter<"Admin"> | string | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    profileImage?: StringNullableFilter<"Admin"> | string | null
    email?: StringNullableFilter<"Admin"> | string | null
    address?: StringNullableFilter<"Admin"> | string | null
    password?: StringNullableFilter<"Admin"> | string | null
    role?: EnumAdminRoleFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAccountStatusFilter<"Admin"> | $Enums.AccountStatus
    notifications?: NotificationListRelationFilter
  }, "adminId" | "adminMobile">

  export type AdminOrderByWithAggregationInput = {
    adminId?: SortOrder
    adminName?: SortOrder
    adminMobile?: SortOrder
    assignedCampus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    adminId?: IntWithAggregatesFilter<"Admin"> | number
    adminName?: StringWithAggregatesFilter<"Admin"> | string
    adminMobile?: StringWithAggregatesFilter<"Admin"> | string
    assignedCampus?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    profileImage?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    email?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    address?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    password?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    role?: EnumAdminRoleWithAggregatesFilter<"Admin"> | $Enums.AdminRole
    status?: EnumAccountStatusWithAggregatesFilter<"Admin"> | $Enums.AccountStatus
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: IntFilter<"SystemSettings"> | number
    allowNewRegistrations?: BoolFilter<"SystemSettings"> | boolean
    defaultStudentFee?: IntFilter<"SystemSettings"> | number
    maintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    staffReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    parentReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    staffWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
    parentWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSettings"> | string | null
    alumniReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    alumniWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    allowNewRegistrations?: SortOrder
    defaultStudentFee?: SortOrder
    maintenanceMode?: SortOrder
    staffReferralText?: SortOrderInput | SortOrder
    parentReferralText?: SortOrderInput | SortOrder
    staffWelcomeMessage?: SortOrderInput | SortOrder
    parentWelcomeMessage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    alumniReferralText?: SortOrderInput | SortOrder
    alumniWelcomeMessage?: SortOrderInput | SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    allowNewRegistrations?: BoolFilter<"SystemSettings"> | boolean
    defaultStudentFee?: IntFilter<"SystemSettings"> | number
    maintenanceMode?: BoolFilter<"SystemSettings"> | boolean
    staffReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    parentReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    staffWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
    parentWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableFilter<"SystemSettings"> | string | null
    alumniReferralText?: StringNullableFilter<"SystemSettings"> | string | null
    alumniWelcomeMessage?: StringNullableFilter<"SystemSettings"> | string | null
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    allowNewRegistrations?: SortOrder
    defaultStudentFee?: SortOrder
    maintenanceMode?: SortOrder
    staffReferralText?: SortOrderInput | SortOrder
    parentReferralText?: SortOrderInput | SortOrder
    staffWelcomeMessage?: SortOrderInput | SortOrder
    parentWelcomeMessage?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    alumniReferralText?: SortOrderInput | SortOrder
    alumniWelcomeMessage?: SortOrderInput | SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _avg?: SystemSettingsAvgOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
    _sum?: SystemSettingsSumOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemSettings"> | number
    allowNewRegistrations?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    defaultStudentFee?: IntWithAggregatesFilter<"SystemSettings"> | number
    maintenanceMode?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    staffReferralText?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    parentReferralText?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    staffWelcomeMessage?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    parentWelcomeMessage?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    alumniReferralText?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
    alumniWelcomeMessage?: StringNullableWithAggregatesFilter<"SystemSettings"> | string | null
  }

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: IntFilter<"AcademicYear"> | number
    year?: StringFilter<"AcademicYear"> | string
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    isActive?: BoolFilter<"AcademicYear"> | boolean
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicYear"> | Date | string
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    year?: string
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    startDate?: DateTimeFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeFilter<"AcademicYear"> | Date | string
    isActive?: BoolFilter<"AcademicYear"> | boolean
    isCurrent?: BoolFilter<"AcademicYear"> | boolean
    createdAt?: DateTimeFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeFilter<"AcademicYear"> | Date | string
  }, "id" | "year">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _avg?: AcademicYearAvgOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
    _sum?: AcademicYearSumOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AcademicYear"> | number
    year?: StringWithAggregatesFilter<"AcademicYear"> | string
    startDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    isActive?: BoolWithAggregatesFilter<"AcademicYear"> | boolean
    isCurrent?: BoolWithAggregatesFilter<"AcademicYear"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AcademicYear"> | Date | string
  }

  export type LeadManagementSettingsWhereInput = {
    AND?: LeadManagementSettingsWhereInput | LeadManagementSettingsWhereInput[]
    OR?: LeadManagementSettingsWhereInput[]
    NOT?: LeadManagementSettingsWhereInput | LeadManagementSettingsWhereInput[]
    id?: IntFilter<"LeadManagementSettings"> | number
    autoAssignLeads?: BoolFilter<"LeadManagementSettings"> | boolean
    leadStaleDays?: IntFilter<"LeadManagementSettings"> | number
    followupEscalationDays?: IntFilter<"LeadManagementSettings"> | number
    duplicateDetectionEnabled?: BoolFilter<"LeadManagementSettings"> | boolean
    updatedAt?: DateTimeFilter<"LeadManagementSettings"> | Date | string
    updatedBy?: StringNullableFilter<"LeadManagementSettings"> | string | null
  }

  export type LeadManagementSettingsOrderByWithRelationInput = {
    id?: SortOrder
    autoAssignLeads?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
    duplicateDetectionEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type LeadManagementSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeadManagementSettingsWhereInput | LeadManagementSettingsWhereInput[]
    OR?: LeadManagementSettingsWhereInput[]
    NOT?: LeadManagementSettingsWhereInput | LeadManagementSettingsWhereInput[]
    autoAssignLeads?: BoolFilter<"LeadManagementSettings"> | boolean
    leadStaleDays?: IntFilter<"LeadManagementSettings"> | number
    followupEscalationDays?: IntFilter<"LeadManagementSettings"> | number
    duplicateDetectionEnabled?: BoolFilter<"LeadManagementSettings"> | boolean
    updatedAt?: DateTimeFilter<"LeadManagementSettings"> | Date | string
    updatedBy?: StringNullableFilter<"LeadManagementSettings"> | string | null
  }, "id">

  export type LeadManagementSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    autoAssignLeads?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
    duplicateDetectionEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: LeadManagementSettingsCountOrderByAggregateInput
    _avg?: LeadManagementSettingsAvgOrderByAggregateInput
    _max?: LeadManagementSettingsMaxOrderByAggregateInput
    _min?: LeadManagementSettingsMinOrderByAggregateInput
    _sum?: LeadManagementSettingsSumOrderByAggregateInput
  }

  export type LeadManagementSettingsScalarWhereWithAggregatesInput = {
    AND?: LeadManagementSettingsScalarWhereWithAggregatesInput | LeadManagementSettingsScalarWhereWithAggregatesInput[]
    OR?: LeadManagementSettingsScalarWhereWithAggregatesInput[]
    NOT?: LeadManagementSettingsScalarWhereWithAggregatesInput | LeadManagementSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LeadManagementSettings"> | number
    autoAssignLeads?: BoolWithAggregatesFilter<"LeadManagementSettings"> | boolean
    leadStaleDays?: IntWithAggregatesFilter<"LeadManagementSettings"> | number
    followupEscalationDays?: IntWithAggregatesFilter<"LeadManagementSettings"> | number
    duplicateDetectionEnabled?: BoolWithAggregatesFilter<"LeadManagementSettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"LeadManagementSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"LeadManagementSettings"> | string | null
  }

  export type SecuritySettingsWhereInput = {
    AND?: SecuritySettingsWhereInput | SecuritySettingsWhereInput[]
    OR?: SecuritySettingsWhereInput[]
    NOT?: SecuritySettingsWhereInput | SecuritySettingsWhereInput[]
    id?: IntFilter<"SecuritySettings"> | number
    sessionTimeoutMinutes?: IntFilter<"SecuritySettings"> | number
    maxLoginAttempts?: IntFilter<"SecuritySettings"> | number
    passwordResetExpiryHours?: IntFilter<"SecuritySettings"> | number
    twoFactorAuthEnabled?: BoolFilter<"SecuritySettings"> | boolean
    updatedAt?: DateTimeFilter<"SecuritySettings"> | Date | string
    updatedBy?: StringNullableFilter<"SecuritySettings"> | string | null
    ipWhitelist?: StringNullableFilter<"SecuritySettings"> | string | null
  }

  export type SecuritySettingsOrderByWithRelationInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
    twoFactorAuthEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    ipWhitelist?: SortOrderInput | SortOrder
  }

  export type SecuritySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SecuritySettingsWhereInput | SecuritySettingsWhereInput[]
    OR?: SecuritySettingsWhereInput[]
    NOT?: SecuritySettingsWhereInput | SecuritySettingsWhereInput[]
    sessionTimeoutMinutes?: IntFilter<"SecuritySettings"> | number
    maxLoginAttempts?: IntFilter<"SecuritySettings"> | number
    passwordResetExpiryHours?: IntFilter<"SecuritySettings"> | number
    twoFactorAuthEnabled?: BoolFilter<"SecuritySettings"> | boolean
    updatedAt?: DateTimeFilter<"SecuritySettings"> | Date | string
    updatedBy?: StringNullableFilter<"SecuritySettings"> | string | null
    ipWhitelist?: StringNullableFilter<"SecuritySettings"> | string | null
  }, "id">

  export type SecuritySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
    twoFactorAuthEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    ipWhitelist?: SortOrderInput | SortOrder
    _count?: SecuritySettingsCountOrderByAggregateInput
    _avg?: SecuritySettingsAvgOrderByAggregateInput
    _max?: SecuritySettingsMaxOrderByAggregateInput
    _min?: SecuritySettingsMinOrderByAggregateInput
    _sum?: SecuritySettingsSumOrderByAggregateInput
  }

  export type SecuritySettingsScalarWhereWithAggregatesInput = {
    AND?: SecuritySettingsScalarWhereWithAggregatesInput | SecuritySettingsScalarWhereWithAggregatesInput[]
    OR?: SecuritySettingsScalarWhereWithAggregatesInput[]
    NOT?: SecuritySettingsScalarWhereWithAggregatesInput | SecuritySettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SecuritySettings"> | number
    sessionTimeoutMinutes?: IntWithAggregatesFilter<"SecuritySettings"> | number
    maxLoginAttempts?: IntWithAggregatesFilter<"SecuritySettings"> | number
    passwordResetExpiryHours?: IntWithAggregatesFilter<"SecuritySettings"> | number
    twoFactorAuthEnabled?: BoolWithAggregatesFilter<"SecuritySettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"SecuritySettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"SecuritySettings"> | string | null
    ipWhitelist?: StringNullableWithAggregatesFilter<"SecuritySettings"> | string | null
  }

  export type DataRetentionSettingsWhereInput = {
    AND?: DataRetentionSettingsWhereInput | DataRetentionSettingsWhereInput[]
    OR?: DataRetentionSettingsWhereInput[]
    NOT?: DataRetentionSettingsWhereInput | DataRetentionSettingsWhereInput[]
    id?: IntFilter<"DataRetentionSettings"> | number
    keepInactiveDataMonths?: IntFilter<"DataRetentionSettings"> | number
    archiveLeadsAfterDays?: IntFilter<"DataRetentionSettings"> | number
    backupFrequencyDays?: IntFilter<"DataRetentionSettings"> | number
    updatedAt?: DateTimeFilter<"DataRetentionSettings"> | Date | string
    updatedBy?: StringNullableFilter<"DataRetentionSettings"> | string | null
  }

  export type DataRetentionSettingsOrderByWithRelationInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type DataRetentionSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DataRetentionSettingsWhereInput | DataRetentionSettingsWhereInput[]
    OR?: DataRetentionSettingsWhereInput[]
    NOT?: DataRetentionSettingsWhereInput | DataRetentionSettingsWhereInput[]
    keepInactiveDataMonths?: IntFilter<"DataRetentionSettings"> | number
    archiveLeadsAfterDays?: IntFilter<"DataRetentionSettings"> | number
    backupFrequencyDays?: IntFilter<"DataRetentionSettings"> | number
    updatedAt?: DateTimeFilter<"DataRetentionSettings"> | Date | string
    updatedBy?: StringNullableFilter<"DataRetentionSettings"> | string | null
  }, "id">

  export type DataRetentionSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: DataRetentionSettingsCountOrderByAggregateInput
    _avg?: DataRetentionSettingsAvgOrderByAggregateInput
    _max?: DataRetentionSettingsMaxOrderByAggregateInput
    _min?: DataRetentionSettingsMinOrderByAggregateInput
    _sum?: DataRetentionSettingsSumOrderByAggregateInput
  }

  export type DataRetentionSettingsScalarWhereWithAggregatesInput = {
    AND?: DataRetentionSettingsScalarWhereWithAggregatesInput | DataRetentionSettingsScalarWhereWithAggregatesInput[]
    OR?: DataRetentionSettingsScalarWhereWithAggregatesInput[]
    NOT?: DataRetentionSettingsScalarWhereWithAggregatesInput | DataRetentionSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DataRetentionSettings"> | number
    keepInactiveDataMonths?: IntWithAggregatesFilter<"DataRetentionSettings"> | number
    archiveLeadsAfterDays?: IntWithAggregatesFilter<"DataRetentionSettings"> | number
    backupFrequencyDays?: IntWithAggregatesFilter<"DataRetentionSettings"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"DataRetentionSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"DataRetentionSettings"> | string | null
  }

  export type RolePermissionsWhereInput = {
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    id?: IntFilter<"RolePermissions"> | number
    role?: StringFilter<"RolePermissions"> | string
    analyticsAccess?: BoolFilter<"RolePermissions"> | boolean
    analyticsScope?: StringFilter<"RolePermissions"> | string
    userMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    userMgmtScope?: StringFilter<"RolePermissions"> | string
    userMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    userMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    userMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtScope?: StringFilter<"RolePermissions"> | string
    adminMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtScope?: StringFilter<"RolePermissions"> | string
    adminMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    campusPerfAccess?: BoolFilter<"RolePermissions"> | boolean
    campusPerfScope?: StringFilter<"RolePermissions"> | string
    reportsAccess?: BoolFilter<"RolePermissions"> | boolean
    reportsScope?: StringFilter<"RolePermissions"> | string
    settlementsAccess?: BoolFilter<"RolePermissions"> | boolean
    settlementsScope?: StringFilter<"RolePermissions"> | string
    marketingKitAccess?: BoolFilter<"RolePermissions"> | boolean
    marketingKitScope?: StringFilter<"RolePermissions"> | string
    auditLogAccess?: BoolFilter<"RolePermissions"> | boolean
    auditLogScope?: StringFilter<"RolePermissions"> | string
    supportDeskAccess?: BoolFilter<"RolePermissions"> | boolean
    supportDeskScope?: StringFilter<"RolePermissions"> | string
    referralSubmissionAccess?: BoolFilter<"RolePermissions"> | boolean
    referralSubmissionScope?: StringFilter<"RolePermissions"> | string
    referralTrackingAccess?: BoolFilter<"RolePermissions"> | boolean
    referralTrackingScope?: StringFilter<"RolePermissions"> | string
    savingsCalculatorAccess?: BoolFilter<"RolePermissions"> | boolean
    savingsCalculatorScope?: StringFilter<"RolePermissions"> | string
    rulesAccessAccess?: BoolFilter<"RolePermissions"> | boolean
    rulesAccessScope?: StringFilter<"RolePermissions"> | string
    settingsAccess?: BoolFilter<"RolePermissions"> | boolean
    settingsScope?: StringFilter<"RolePermissions"> | string
    updatedAt?: DateTimeFilter<"RolePermissions"> | Date | string
    updatedBy?: StringNullableFilter<"RolePermissions"> | string | null
    studentMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    deletionHubAccess?: BoolFilter<"RolePermissions"> | boolean
    deletionHubScope?: StringFilter<"RolePermissions"> | string
    passwordResetAccess?: BoolFilter<"RolePermissions"> | boolean
    passwordResetScope?: StringFilter<"RolePermissions"> | string
    engagementCentreAccess?: BoolFilter<"RolePermissions"> | boolean
    engagementCentreScope?: StringFilter<"RolePermissions"> | string
    feeManagementAccess?: BoolFilter<"RolePermissions"> | boolean
    feeManagementScope?: StringFilter<"RolePermissions"> | string
  }

  export type RolePermissionsOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    analyticsAccess?: SortOrder
    analyticsScope?: SortOrder
    userMgmtAccess?: SortOrder
    userMgmtScope?: SortOrder
    userMgmtCreate?: SortOrder
    userMgmtEdit?: SortOrder
    userMgmtDelete?: SortOrder
    studentMgmtAccess?: SortOrder
    studentMgmtScope?: SortOrder
    adminMgmtAccess?: SortOrder
    adminMgmtScope?: SortOrder
    adminMgmtCreate?: SortOrder
    adminMgmtEdit?: SortOrder
    adminMgmtDelete?: SortOrder
    campusPerfAccess?: SortOrder
    campusPerfScope?: SortOrder
    reportsAccess?: SortOrder
    reportsScope?: SortOrder
    settlementsAccess?: SortOrder
    settlementsScope?: SortOrder
    marketingKitAccess?: SortOrder
    marketingKitScope?: SortOrder
    auditLogAccess?: SortOrder
    auditLogScope?: SortOrder
    supportDeskAccess?: SortOrder
    supportDeskScope?: SortOrder
    referralSubmissionAccess?: SortOrder
    referralSubmissionScope?: SortOrder
    referralTrackingAccess?: SortOrder
    referralTrackingScope?: SortOrder
    savingsCalculatorAccess?: SortOrder
    savingsCalculatorScope?: SortOrder
    rulesAccessAccess?: SortOrder
    rulesAccessScope?: SortOrder
    settingsAccess?: SortOrder
    settingsScope?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    studentMgmtCreate?: SortOrder
    studentMgmtDelete?: SortOrder
    studentMgmtEdit?: SortOrder
    deletionHubAccess?: SortOrder
    deletionHubScope?: SortOrder
    passwordResetAccess?: SortOrder
    passwordResetScope?: SortOrder
    engagementCentreAccess?: SortOrder
    engagementCentreScope?: SortOrder
    feeManagementAccess?: SortOrder
    feeManagementScope?: SortOrder
  }

  export type RolePermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    role?: string
    AND?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    OR?: RolePermissionsWhereInput[]
    NOT?: RolePermissionsWhereInput | RolePermissionsWhereInput[]
    analyticsAccess?: BoolFilter<"RolePermissions"> | boolean
    analyticsScope?: StringFilter<"RolePermissions"> | string
    userMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    userMgmtScope?: StringFilter<"RolePermissions"> | string
    userMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    userMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    userMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtScope?: StringFilter<"RolePermissions"> | string
    adminMgmtAccess?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtScope?: StringFilter<"RolePermissions"> | string
    adminMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    adminMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    campusPerfAccess?: BoolFilter<"RolePermissions"> | boolean
    campusPerfScope?: StringFilter<"RolePermissions"> | string
    reportsAccess?: BoolFilter<"RolePermissions"> | boolean
    reportsScope?: StringFilter<"RolePermissions"> | string
    settlementsAccess?: BoolFilter<"RolePermissions"> | boolean
    settlementsScope?: StringFilter<"RolePermissions"> | string
    marketingKitAccess?: BoolFilter<"RolePermissions"> | boolean
    marketingKitScope?: StringFilter<"RolePermissions"> | string
    auditLogAccess?: BoolFilter<"RolePermissions"> | boolean
    auditLogScope?: StringFilter<"RolePermissions"> | string
    supportDeskAccess?: BoolFilter<"RolePermissions"> | boolean
    supportDeskScope?: StringFilter<"RolePermissions"> | string
    referralSubmissionAccess?: BoolFilter<"RolePermissions"> | boolean
    referralSubmissionScope?: StringFilter<"RolePermissions"> | string
    referralTrackingAccess?: BoolFilter<"RolePermissions"> | boolean
    referralTrackingScope?: StringFilter<"RolePermissions"> | string
    savingsCalculatorAccess?: BoolFilter<"RolePermissions"> | boolean
    savingsCalculatorScope?: StringFilter<"RolePermissions"> | string
    rulesAccessAccess?: BoolFilter<"RolePermissions"> | boolean
    rulesAccessScope?: StringFilter<"RolePermissions"> | string
    settingsAccess?: BoolFilter<"RolePermissions"> | boolean
    settingsScope?: StringFilter<"RolePermissions"> | string
    updatedAt?: DateTimeFilter<"RolePermissions"> | Date | string
    updatedBy?: StringNullableFilter<"RolePermissions"> | string | null
    studentMgmtCreate?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtDelete?: BoolFilter<"RolePermissions"> | boolean
    studentMgmtEdit?: BoolFilter<"RolePermissions"> | boolean
    deletionHubAccess?: BoolFilter<"RolePermissions"> | boolean
    deletionHubScope?: StringFilter<"RolePermissions"> | string
    passwordResetAccess?: BoolFilter<"RolePermissions"> | boolean
    passwordResetScope?: StringFilter<"RolePermissions"> | string
    engagementCentreAccess?: BoolFilter<"RolePermissions"> | boolean
    engagementCentreScope?: StringFilter<"RolePermissions"> | string
    feeManagementAccess?: BoolFilter<"RolePermissions"> | boolean
    feeManagementScope?: StringFilter<"RolePermissions"> | string
  }, "id" | "role">

  export type RolePermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    analyticsAccess?: SortOrder
    analyticsScope?: SortOrder
    userMgmtAccess?: SortOrder
    userMgmtScope?: SortOrder
    userMgmtCreate?: SortOrder
    userMgmtEdit?: SortOrder
    userMgmtDelete?: SortOrder
    studentMgmtAccess?: SortOrder
    studentMgmtScope?: SortOrder
    adminMgmtAccess?: SortOrder
    adminMgmtScope?: SortOrder
    adminMgmtCreate?: SortOrder
    adminMgmtEdit?: SortOrder
    adminMgmtDelete?: SortOrder
    campusPerfAccess?: SortOrder
    campusPerfScope?: SortOrder
    reportsAccess?: SortOrder
    reportsScope?: SortOrder
    settlementsAccess?: SortOrder
    settlementsScope?: SortOrder
    marketingKitAccess?: SortOrder
    marketingKitScope?: SortOrder
    auditLogAccess?: SortOrder
    auditLogScope?: SortOrder
    supportDeskAccess?: SortOrder
    supportDeskScope?: SortOrder
    referralSubmissionAccess?: SortOrder
    referralSubmissionScope?: SortOrder
    referralTrackingAccess?: SortOrder
    referralTrackingScope?: SortOrder
    savingsCalculatorAccess?: SortOrder
    savingsCalculatorScope?: SortOrder
    rulesAccessAccess?: SortOrder
    rulesAccessScope?: SortOrder
    settingsAccess?: SortOrder
    settingsScope?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    studentMgmtCreate?: SortOrder
    studentMgmtDelete?: SortOrder
    studentMgmtEdit?: SortOrder
    deletionHubAccess?: SortOrder
    deletionHubScope?: SortOrder
    passwordResetAccess?: SortOrder
    passwordResetScope?: SortOrder
    engagementCentreAccess?: SortOrder
    engagementCentreScope?: SortOrder
    feeManagementAccess?: SortOrder
    feeManagementScope?: SortOrder
    _count?: RolePermissionsCountOrderByAggregateInput
    _avg?: RolePermissionsAvgOrderByAggregateInput
    _max?: RolePermissionsMaxOrderByAggregateInput
    _min?: RolePermissionsMinOrderByAggregateInput
    _sum?: RolePermissionsSumOrderByAggregateInput
  }

  export type RolePermissionsScalarWhereWithAggregatesInput = {
    AND?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    OR?: RolePermissionsScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionsScalarWhereWithAggregatesInput | RolePermissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolePermissions"> | number
    role?: StringWithAggregatesFilter<"RolePermissions"> | string
    analyticsAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    analyticsScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    userMgmtAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    userMgmtScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    userMgmtCreate?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    userMgmtEdit?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    userMgmtDelete?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    studentMgmtAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    studentMgmtScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    adminMgmtAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    adminMgmtScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    adminMgmtCreate?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    adminMgmtEdit?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    adminMgmtDelete?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    campusPerfAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    campusPerfScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    reportsAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    reportsScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    settlementsAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    settlementsScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    marketingKitAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    marketingKitScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    auditLogAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    auditLogScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    supportDeskAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    supportDeskScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    referralSubmissionAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    referralSubmissionScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    referralTrackingAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    referralTrackingScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    savingsCalculatorAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    savingsCalculatorScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    rulesAccessAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    rulesAccessScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    settingsAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    settingsScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePermissions"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"RolePermissions"> | string | null
    studentMgmtCreate?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    studentMgmtDelete?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    studentMgmtEdit?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    deletionHubAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    deletionHubScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    passwordResetAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    passwordResetScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    engagementCentreAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    engagementCentreScope?: StringWithAggregatesFilter<"RolePermissions"> | string
    feeManagementAccess?: BoolWithAggregatesFilter<"RolePermissions"> | boolean
    feeManagementScope?: StringWithAggregatesFilter<"RolePermissions"> | string
  }

  export type SettlementWhereInput = {
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    id?: IntFilter<"Settlement"> | number
    userId?: IntFilter<"Settlement"> | number
    amount?: FloatFilter<"Settlement"> | number
    status?: StringFilter<"Settlement"> | string
    paymentMethod?: StringNullableFilter<"Settlement"> | string | null
    bankReference?: StringNullableFilter<"Settlement"> | string | null
    payoutDate?: DateTimeNullableFilter<"Settlement"> | Date | string | null
    processedBy?: IntNullableFilter<"Settlement"> | number | null
    remarks?: StringNullableFilter<"Settlement"> | string | null
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SettlementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    bankReference?: SortOrderInput | SortOrder
    payoutDate?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SettlementWhereInput | SettlementWhereInput[]
    OR?: SettlementWhereInput[]
    NOT?: SettlementWhereInput | SettlementWhereInput[]
    userId?: IntFilter<"Settlement"> | number
    amount?: FloatFilter<"Settlement"> | number
    status?: StringFilter<"Settlement"> | string
    paymentMethod?: StringNullableFilter<"Settlement"> | string | null
    bankReference?: StringNullableFilter<"Settlement"> | string | null
    payoutDate?: DateTimeNullableFilter<"Settlement"> | Date | string | null
    processedBy?: IntNullableFilter<"Settlement"> | number | null
    remarks?: StringNullableFilter<"Settlement"> | string | null
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SettlementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    bankReference?: SortOrderInput | SortOrder
    payoutDate?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettlementCountOrderByAggregateInput
    _avg?: SettlementAvgOrderByAggregateInput
    _max?: SettlementMaxOrderByAggregateInput
    _min?: SettlementMinOrderByAggregateInput
    _sum?: SettlementSumOrderByAggregateInput
  }

  export type SettlementScalarWhereWithAggregatesInput = {
    AND?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    OR?: SettlementScalarWhereWithAggregatesInput[]
    NOT?: SettlementScalarWhereWithAggregatesInput | SettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settlement"> | number
    userId?: IntWithAggregatesFilter<"Settlement"> | number
    amount?: FloatWithAggregatesFilter<"Settlement"> | number
    status?: StringWithAggregatesFilter<"Settlement"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Settlement"> | string | null
    bankReference?: StringNullableWithAggregatesFilter<"Settlement"> | string | null
    payoutDate?: DateTimeNullableWithAggregatesFilter<"Settlement"> | Date | string | null
    processedBy?: IntNullableWithAggregatesFilter<"Settlement"> | number | null
    remarks?: StringNullableWithAggregatesFilter<"Settlement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settlement"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    type?: StringFilter<"Resource"> | string
    category?: StringFilter<"Resource"> | string
    fileUrl?: StringFilter<"Resource"> | string
    thumbnailUrl?: StringNullableFilter<"Resource"> | string | null
    isActive?: BoolFilter<"Resource"> | boolean
    uploadedBy?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    title?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    type?: StringFilter<"Resource"> | string
    category?: StringFilter<"Resource"> | string
    fileUrl?: StringFilter<"Resource"> | string
    thumbnailUrl?: StringNullableFilter<"Resource"> | string | null
    isActive?: BoolFilter<"Resource"> | boolean
    uploadedBy?: IntFilter<"Resource"> | number
    createdAt?: DateTimeFilter<"Resource"> | Date | string
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    title?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    type?: StringWithAggregatesFilter<"Resource"> | string
    category?: StringWithAggregatesFilter<"Resource"> | string
    fileUrl?: StringWithAggregatesFilter<"Resource"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    isActive?: BoolWithAggregatesFilter<"Resource"> | boolean
    uploadedBy?: IntWithAggregatesFilter<"Resource"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    adminId?: IntNullableFilter<"ActivityLog"> | number | null
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    module?: StringFilter<"ActivityLog"> | string
    targetId?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringFilter<"ActivityLog"> | string
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    metadata?: JsonNullableFilter<"ActivityLog">
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    module?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    adminId?: IntNullableFilter<"ActivityLog"> | number | null
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    module?: StringFilter<"ActivityLog"> | string
    targetId?: StringNullableFilter<"ActivityLog"> | string | null
    description?: StringFilter<"ActivityLog"> | string
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    metadata?: JsonNullableFilter<"ActivityLog">
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    module?: SortOrder
    targetId?: SortOrderInput | SortOrder
    description?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    adminId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    userId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    module?: StringWithAggregatesFilter<"ActivityLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    description?: StringWithAggregatesFilter<"ActivityLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLog">
  }

  export type SupportTicketWhereInput = {
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    assignedAdminId?: IntNullableFilter<"SupportTicket"> | number | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    campus?: StringNullableFilter<"SupportTicket"> | string | null
    message?: StringFilter<"SupportTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    escalationLevel?: IntFilter<"SupportTicket"> | number
    lastEscalatedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: TicketMessageListRelationFilter
  }

  export type SupportTicketOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campus?: SortOrderInput | SortOrder
    message?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    escalationLevel?: SortOrder
    lastEscalatedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    messages?: TicketMessageOrderByRelationAggregateInput
  }

  export type SupportTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupportTicketWhereInput | SupportTicketWhereInput[]
    OR?: SupportTicketWhereInput[]
    NOT?: SupportTicketWhereInput | SupportTicketWhereInput[]
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    assignedAdminId?: IntNullableFilter<"SupportTicket"> | number | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    campus?: StringNullableFilter<"SupportTicket"> | string | null
    message?: StringFilter<"SupportTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    escalationLevel?: IntFilter<"SupportTicket"> | number
    lastEscalatedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: TicketMessageListRelationFilter
  }, "id">

  export type SupportTicketOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAdminId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campus?: SortOrderInput | SortOrder
    message?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    escalationLevel?: SortOrder
    lastEscalatedAt?: SortOrderInput | SortOrder
    _count?: SupportTicketCountOrderByAggregateInput
    _avg?: SupportTicketAvgOrderByAggregateInput
    _max?: SupportTicketMaxOrderByAggregateInput
    _min?: SupportTicketMinOrderByAggregateInput
    _sum?: SupportTicketSumOrderByAggregateInput
  }

  export type SupportTicketScalarWhereWithAggregatesInput = {
    AND?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    OR?: SupportTicketScalarWhereWithAggregatesInput[]
    NOT?: SupportTicketScalarWhereWithAggregatesInput | SupportTicketScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupportTicket"> | number
    userId?: IntWithAggregatesFilter<"SupportTicket"> | number
    subject?: StringWithAggregatesFilter<"SupportTicket"> | string
    category?: StringWithAggregatesFilter<"SupportTicket"> | string
    priority?: StringWithAggregatesFilter<"SupportTicket"> | string
    status?: StringWithAggregatesFilter<"SupportTicket"> | string
    assignedAdminId?: IntNullableWithAggregatesFilter<"SupportTicket"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupportTicket"> | Date | string
    campus?: StringNullableWithAggregatesFilter<"SupportTicket"> | string | null
    message?: StringWithAggregatesFilter<"SupportTicket"> | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
    escalationLevel?: IntWithAggregatesFilter<"SupportTicket"> | number
    lastEscalatedAt?: DateTimeNullableWithAggregatesFilter<"SupportTicket"> | Date | string | null
  }

  export type TicketMessageWhereInput = {
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    id?: IntFilter<"TicketMessage"> | number
    ticketId?: IntFilter<"TicketMessage"> | number
    senderId?: IntFilter<"TicketMessage"> | number
    senderType?: StringFilter<"TicketMessage"> | string
    message?: StringFilter<"TicketMessage"> | string
    isInternal?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
  }

  export type TicketMessageOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    ticket?: SupportTicketOrderByWithRelationInput
  }

  export type TicketMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TicketMessageWhereInput | TicketMessageWhereInput[]
    OR?: TicketMessageWhereInput[]
    NOT?: TicketMessageWhereInput | TicketMessageWhereInput[]
    ticketId?: IntFilter<"TicketMessage"> | number
    senderId?: IntFilter<"TicketMessage"> | number
    senderType?: StringFilter<"TicketMessage"> | string
    message?: StringFilter<"TicketMessage"> | string
    isInternal?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
    ticket?: XOR<SupportTicketRelationFilter, SupportTicketWhereInput>
  }, "id">

  export type TicketMessageOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    _count?: TicketMessageCountOrderByAggregateInput
    _avg?: TicketMessageAvgOrderByAggregateInput
    _max?: TicketMessageMaxOrderByAggregateInput
    _min?: TicketMessageMinOrderByAggregateInput
    _sum?: TicketMessageSumOrderByAggregateInput
  }

  export type TicketMessageScalarWhereWithAggregatesInput = {
    AND?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    OR?: TicketMessageScalarWhereWithAggregatesInput[]
    NOT?: TicketMessageScalarWhereWithAggregatesInput | TicketMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TicketMessage"> | number
    ticketId?: IntWithAggregatesFilter<"TicketMessage"> | number
    senderId?: IntWithAggregatesFilter<"TicketMessage"> | number
    senderType?: StringWithAggregatesFilter<"TicketMessage"> | string
    message?: StringWithAggregatesFilter<"TicketMessage"> | string
    isInternal?: BoolWithAggregatesFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketMessage"> | Date | string
  }

  export type CampusWhereInput = {
    AND?: CampusWhereInput | CampusWhereInput[]
    OR?: CampusWhereInput[]
    NOT?: CampusWhereInput | CampusWhereInput[]
    id?: IntFilter<"Campus"> | number
    campusName?: StringFilter<"Campus"> | string
    campusCode?: StringFilter<"Campus"> | string
    location?: StringFilter<"Campus"> | string
    grades?: StringFilter<"Campus"> | string
    maxCapacity?: IntFilter<"Campus"> | number
    currentEnrollment?: IntFilter<"Campus"> | number
    isActive?: BoolFilter<"Campus"> | boolean
    campusHeadId?: IntNullableFilter<"Campus"> | number | null
    contactEmail?: StringNullableFilter<"Campus"> | string | null
    contactPhone?: StringNullableFilter<"Campus"> | string | null
    address?: StringNullableFilter<"Campus"> | string | null
    createdAt?: DateTimeFilter<"Campus"> | Date | string
    updatedAt?: DateTimeFilter<"Campus"> | Date | string
    targets?: CampusTargetListRelationFilter
    gradeFees?: GradeFeeListRelationFilter
    students?: StudentListRelationFilter
  }

  export type CampusOrderByWithRelationInput = {
    id?: SortOrder
    campusName?: SortOrder
    campusCode?: SortOrder
    location?: SortOrder
    grades?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    isActive?: SortOrder
    campusHeadId?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    targets?: CampusTargetOrderByRelationAggregateInput
    gradeFees?: GradeFeeOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
  }

  export type CampusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    campusName?: string
    campusCode?: string
    AND?: CampusWhereInput | CampusWhereInput[]
    OR?: CampusWhereInput[]
    NOT?: CampusWhereInput | CampusWhereInput[]
    location?: StringFilter<"Campus"> | string
    grades?: StringFilter<"Campus"> | string
    maxCapacity?: IntFilter<"Campus"> | number
    currentEnrollment?: IntFilter<"Campus"> | number
    isActive?: BoolFilter<"Campus"> | boolean
    campusHeadId?: IntNullableFilter<"Campus"> | number | null
    contactEmail?: StringNullableFilter<"Campus"> | string | null
    contactPhone?: StringNullableFilter<"Campus"> | string | null
    address?: StringNullableFilter<"Campus"> | string | null
    createdAt?: DateTimeFilter<"Campus"> | Date | string
    updatedAt?: DateTimeFilter<"Campus"> | Date | string
    targets?: CampusTargetListRelationFilter
    gradeFees?: GradeFeeListRelationFilter
    students?: StudentListRelationFilter
  }, "id" | "campusName" | "campusCode">

  export type CampusOrderByWithAggregationInput = {
    id?: SortOrder
    campusName?: SortOrder
    campusCode?: SortOrder
    location?: SortOrder
    grades?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    isActive?: SortOrder
    campusHeadId?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampusCountOrderByAggregateInput
    _avg?: CampusAvgOrderByAggregateInput
    _max?: CampusMaxOrderByAggregateInput
    _min?: CampusMinOrderByAggregateInput
    _sum?: CampusSumOrderByAggregateInput
  }

  export type CampusScalarWhereWithAggregatesInput = {
    AND?: CampusScalarWhereWithAggregatesInput | CampusScalarWhereWithAggregatesInput[]
    OR?: CampusScalarWhereWithAggregatesInput[]
    NOT?: CampusScalarWhereWithAggregatesInput | CampusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campus"> | number
    campusName?: StringWithAggregatesFilter<"Campus"> | string
    campusCode?: StringWithAggregatesFilter<"Campus"> | string
    location?: StringWithAggregatesFilter<"Campus"> | string
    grades?: StringWithAggregatesFilter<"Campus"> | string
    maxCapacity?: IntWithAggregatesFilter<"Campus"> | number
    currentEnrollment?: IntWithAggregatesFilter<"Campus"> | number
    isActive?: BoolWithAggregatesFilter<"Campus"> | boolean
    campusHeadId?: IntNullableWithAggregatesFilter<"Campus"> | number | null
    contactEmail?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    address?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campus"> | Date | string
  }

  export type CampusTargetWhereInput = {
    AND?: CampusTargetWhereInput | CampusTargetWhereInput[]
    OR?: CampusTargetWhereInput[]
    NOT?: CampusTargetWhereInput | CampusTargetWhereInput[]
    id?: IntFilter<"CampusTarget"> | number
    campusId?: IntFilter<"CampusTarget"> | number
    month?: IntFilter<"CampusTarget"> | number
    year?: IntFilter<"CampusTarget"> | number
    leadTarget?: IntFilter<"CampusTarget"> | number
    admissionTarget?: IntFilter<"CampusTarget"> | number
    updatedAt?: DateTimeFilter<"CampusTarget"> | Date | string
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
  }

  export type CampusTargetOrderByWithRelationInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
    updatedAt?: SortOrder
    campus?: CampusOrderByWithRelationInput
  }

  export type CampusTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    campusId_month_year?: CampusTargetCampusIdMonthYearCompoundUniqueInput
    AND?: CampusTargetWhereInput | CampusTargetWhereInput[]
    OR?: CampusTargetWhereInput[]
    NOT?: CampusTargetWhereInput | CampusTargetWhereInput[]
    campusId?: IntFilter<"CampusTarget"> | number
    month?: IntFilter<"CampusTarget"> | number
    year?: IntFilter<"CampusTarget"> | number
    leadTarget?: IntFilter<"CampusTarget"> | number
    admissionTarget?: IntFilter<"CampusTarget"> | number
    updatedAt?: DateTimeFilter<"CampusTarget"> | Date | string
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
  }, "id" | "campusId_month_year">

  export type CampusTargetOrderByWithAggregationInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
    updatedAt?: SortOrder
    _count?: CampusTargetCountOrderByAggregateInput
    _avg?: CampusTargetAvgOrderByAggregateInput
    _max?: CampusTargetMaxOrderByAggregateInput
    _min?: CampusTargetMinOrderByAggregateInput
    _sum?: CampusTargetSumOrderByAggregateInput
  }

  export type CampusTargetScalarWhereWithAggregatesInput = {
    AND?: CampusTargetScalarWhereWithAggregatesInput | CampusTargetScalarWhereWithAggregatesInput[]
    OR?: CampusTargetScalarWhereWithAggregatesInput[]
    NOT?: CampusTargetScalarWhereWithAggregatesInput | CampusTargetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CampusTarget"> | number
    campusId?: IntWithAggregatesFilter<"CampusTarget"> | number
    month?: IntWithAggregatesFilter<"CampusTarget"> | number
    year?: IntWithAggregatesFilter<"CampusTarget"> | number
    leadTarget?: IntWithAggregatesFilter<"CampusTarget"> | number
    admissionTarget?: IntWithAggregatesFilter<"CampusTarget"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"CampusTarget"> | Date | string
  }

  export type GradeFeeWhereInput = {
    AND?: GradeFeeWhereInput | GradeFeeWhereInput[]
    OR?: GradeFeeWhereInput[]
    NOT?: GradeFeeWhereInput | GradeFeeWhereInput[]
    id?: IntFilter<"GradeFee"> | number
    grade?: StringFilter<"GradeFee"> | string
    annualFee_otp?: IntNullableFilter<"GradeFee"> | number | null
    annualFee_wotp?: IntNullableFilter<"GradeFee"> | number | null
    campusId?: IntFilter<"GradeFee"> | number
    academicYear?: StringFilter<"GradeFee"> | string
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
  }

  export type GradeFeeOrderByWithRelationInput = {
    id?: SortOrder
    grade?: SortOrder
    annualFee_otp?: SortOrderInput | SortOrder
    annualFee_wotp?: SortOrderInput | SortOrder
    campusId?: SortOrder
    academicYear?: SortOrder
    campus?: CampusOrderByWithRelationInput
  }

  export type GradeFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    campusId_grade_academicYear?: GradeFeeCampusIdGradeAcademicYearCompoundUniqueInput
    AND?: GradeFeeWhereInput | GradeFeeWhereInput[]
    OR?: GradeFeeWhereInput[]
    NOT?: GradeFeeWhereInput | GradeFeeWhereInput[]
    grade?: StringFilter<"GradeFee"> | string
    annualFee_otp?: IntNullableFilter<"GradeFee"> | number | null
    annualFee_wotp?: IntNullableFilter<"GradeFee"> | number | null
    campusId?: IntFilter<"GradeFee"> | number
    academicYear?: StringFilter<"GradeFee"> | string
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
  }, "id" | "campusId_grade_academicYear">

  export type GradeFeeOrderByWithAggregationInput = {
    id?: SortOrder
    grade?: SortOrder
    annualFee_otp?: SortOrderInput | SortOrder
    annualFee_wotp?: SortOrderInput | SortOrder
    campusId?: SortOrder
    academicYear?: SortOrder
    _count?: GradeFeeCountOrderByAggregateInput
    _avg?: GradeFeeAvgOrderByAggregateInput
    _max?: GradeFeeMaxOrderByAggregateInput
    _min?: GradeFeeMinOrderByAggregateInput
    _sum?: GradeFeeSumOrderByAggregateInput
  }

  export type GradeFeeScalarWhereWithAggregatesInput = {
    AND?: GradeFeeScalarWhereWithAggregatesInput | GradeFeeScalarWhereWithAggregatesInput[]
    OR?: GradeFeeScalarWhereWithAggregatesInput[]
    NOT?: GradeFeeScalarWhereWithAggregatesInput | GradeFeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GradeFee"> | number
    grade?: StringWithAggregatesFilter<"GradeFee"> | string
    annualFee_otp?: IntNullableWithAggregatesFilter<"GradeFee"> | number | null
    annualFee_wotp?: IntNullableWithAggregatesFilter<"GradeFee"> | number | null
    campusId?: IntWithAggregatesFilter<"GradeFee"> | number
    academicYear?: StringWithAggregatesFilter<"GradeFee"> | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    id?: IntFilter<"NotificationSettings"> | number
    emailNotifications?: BoolFilter<"NotificationSettings"> | boolean
    smsNotifications?: BoolFilter<"NotificationSettings"> | boolean
    whatsappNotifications?: BoolFilter<"NotificationSettings"> | boolean
    leadFollowupReminders?: BoolFilter<"NotificationSettings"> | boolean
    reminderFrequencyDays?: IntFilter<"NotificationSettings"> | number
    notifySuperAdminOnNewAdmins?: BoolFilter<"NotificationSettings"> | boolean
    notifyCampusHeadOnNewLeads?: BoolFilter<"NotificationSettings"> | boolean
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedBy?: StringNullableFilter<"NotificationSettings"> | string | null
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    whatsappNotifications?: SortOrder
    leadFollowupReminders?: SortOrder
    reminderFrequencyDays?: SortOrder
    notifySuperAdminOnNewAdmins?: SortOrder
    notifyCampusHeadOnNewLeads?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    emailNotifications?: BoolFilter<"NotificationSettings"> | boolean
    smsNotifications?: BoolFilter<"NotificationSettings"> | boolean
    whatsappNotifications?: BoolFilter<"NotificationSettings"> | boolean
    leadFollowupReminders?: BoolFilter<"NotificationSettings"> | boolean
    reminderFrequencyDays?: IntFilter<"NotificationSettings"> | number
    notifySuperAdminOnNewAdmins?: BoolFilter<"NotificationSettings"> | boolean
    notifyCampusHeadOnNewLeads?: BoolFilter<"NotificationSettings"> | boolean
    updatedAt?: DateTimeFilter<"NotificationSettings"> | Date | string
    updatedBy?: StringNullableFilter<"NotificationSettings"> | string | null
  }, "id">

  export type NotificationSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    whatsappNotifications?: SortOrder
    leadFollowupReminders?: SortOrder
    reminderFrequencyDays?: SortOrder
    notifySuperAdminOnNewAdmins?: SortOrder
    notifyCampusHeadOnNewLeads?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrderInput | SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _avg?: NotificationSettingsAvgOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
    _sum?: NotificationSettingsSumOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationSettings"> | number
    emailNotifications?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    smsNotifications?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    whatsappNotifications?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    leadFollowupReminders?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    reminderFrequencyDays?: IntWithAggregatesFilter<"NotificationSettings"> | number
    notifySuperAdminOnNewAdmins?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    notifyCampusHeadOnNewLeads?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSettings"> | Date | string
    updatedBy?: StringNullableWithAggregatesFilter<"NotificationSettings"> | string | null
  }

  export type MarketingAssetWhereInput = {
    AND?: MarketingAssetWhereInput | MarketingAssetWhereInput[]
    OR?: MarketingAssetWhereInput[]
    NOT?: MarketingAssetWhereInput | MarketingAssetWhereInput[]
    id?: IntFilter<"MarketingAsset"> | number
    name?: StringFilter<"MarketingAsset"> | string
    category?: StringFilter<"MarketingAsset"> | string
    description?: StringNullableFilter<"MarketingAsset"> | string | null
    fileUrl?: StringFilter<"MarketingAsset"> | string
    fileType?: StringNullableFilter<"MarketingAsset"> | string | null
    fileSize?: IntNullableFilter<"MarketingAsset"> | number | null
    isActive?: BoolFilter<"MarketingAsset"> | boolean
    sortOrder?: IntFilter<"MarketingAsset"> | number
    uploadedById?: IntNullableFilter<"MarketingAsset"> | number | null
    createdAt?: DateTimeFilter<"MarketingAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingAsset"> | Date | string
  }

  export type MarketingAssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MarketingAssetWhereInput | MarketingAssetWhereInput[]
    OR?: MarketingAssetWhereInput[]
    NOT?: MarketingAssetWhereInput | MarketingAssetWhereInput[]
    name?: StringFilter<"MarketingAsset"> | string
    category?: StringFilter<"MarketingAsset"> | string
    description?: StringNullableFilter<"MarketingAsset"> | string | null
    fileUrl?: StringFilter<"MarketingAsset"> | string
    fileType?: StringNullableFilter<"MarketingAsset"> | string | null
    fileSize?: IntNullableFilter<"MarketingAsset"> | number | null
    isActive?: BoolFilter<"MarketingAsset"> | boolean
    sortOrder?: IntFilter<"MarketingAsset"> | number
    uploadedById?: IntNullableFilter<"MarketingAsset"> | number | null
    createdAt?: DateTimeFilter<"MarketingAsset"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingAsset"> | Date | string
  }, "id">

  export type MarketingAssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingAssetCountOrderByAggregateInput
    _avg?: MarketingAssetAvgOrderByAggregateInput
    _max?: MarketingAssetMaxOrderByAggregateInput
    _min?: MarketingAssetMinOrderByAggregateInput
    _sum?: MarketingAssetSumOrderByAggregateInput
  }

  export type MarketingAssetScalarWhereWithAggregatesInput = {
    AND?: MarketingAssetScalarWhereWithAggregatesInput | MarketingAssetScalarWhereWithAggregatesInput[]
    OR?: MarketingAssetScalarWhereWithAggregatesInput[]
    NOT?: MarketingAssetScalarWhereWithAggregatesInput | MarketingAssetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketingAsset"> | number
    name?: StringWithAggregatesFilter<"MarketingAsset"> | string
    category?: StringWithAggregatesFilter<"MarketingAsset"> | string
    description?: StringNullableWithAggregatesFilter<"MarketingAsset"> | string | null
    fileUrl?: StringWithAggregatesFilter<"MarketingAsset"> | string
    fileType?: StringNullableWithAggregatesFilter<"MarketingAsset"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"MarketingAsset"> | number | null
    isActive?: BoolWithAggregatesFilter<"MarketingAsset"> | boolean
    sortOrder?: IntWithAggregatesFilter<"MarketingAsset"> | number
    uploadedById?: IntNullableWithAggregatesFilter<"MarketingAsset"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingAsset"> | Date | string
  }

  export type OtpVerificationWhereInput = {
    AND?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    OR?: OtpVerificationWhereInput[]
    NOT?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    id?: IntFilter<"OtpVerification"> | number
    mobile?: StringFilter<"OtpVerification"> | string
    otp?: StringFilter<"OtpVerification"> | string
    expiresAt?: DateTimeFilter<"OtpVerification"> | Date | string
    createdAt?: DateTimeFilter<"OtpVerification"> | Date | string
  }

  export type OtpVerificationOrderByWithRelationInput = {
    id?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    mobile?: string
    AND?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    OR?: OtpVerificationWhereInput[]
    NOT?: OtpVerificationWhereInput | OtpVerificationWhereInput[]
    otp?: StringFilter<"OtpVerification"> | string
    expiresAt?: DateTimeFilter<"OtpVerification"> | Date | string
    createdAt?: DateTimeFilter<"OtpVerification"> | Date | string
  }, "id" | "mobile">

  export type OtpVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OtpVerificationCountOrderByAggregateInput
    _avg?: OtpVerificationAvgOrderByAggregateInput
    _max?: OtpVerificationMaxOrderByAggregateInput
    _min?: OtpVerificationMinOrderByAggregateInput
    _sum?: OtpVerificationSumOrderByAggregateInput
  }

  export type OtpVerificationScalarWhereWithAggregatesInput = {
    AND?: OtpVerificationScalarWhereWithAggregatesInput | OtpVerificationScalarWhereWithAggregatesInput[]
    OR?: OtpVerificationScalarWhereWithAggregatesInput[]
    NOT?: OtpVerificationScalarWhereWithAggregatesInput | OtpVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OtpVerification"> | number
    mobile?: StringWithAggregatesFilter<"OtpVerification"> | string
    otp?: StringWithAggregatesFilter<"OtpVerification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"OtpVerification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OtpVerification"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntNullableFilter<"Notification"> | number | null
    adminId?: IntNullableFilter<"Notification"> | number | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntNullableFilter<"Notification"> | number | null
    adminId?: IntNullableFilter<"Notification"> | number | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    adminId?: SortOrderInput | SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    adminId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: IntFilter<"Campaign"> | number
    name?: StringFilter<"Campaign"> | string
    subject?: StringFilter<"Campaign"> | string
    templateBody?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    targetAudience?: JsonNullableFilter<"Campaign">
    schedule?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    logs?: CampaignLogListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    templateBody?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    logs?: CampaignLogOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    subject?: StringFilter<"Campaign"> | string
    templateBody?: StringFilter<"Campaign"> | string
    type?: StringFilter<"Campaign"> | string
    status?: StringFilter<"Campaign"> | string
    targetAudience?: JsonNullableFilter<"Campaign">
    schedule?: StringNullableFilter<"Campaign"> | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    lastRunAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    logs?: CampaignLogListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    templateBody?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    schedule?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Campaign"> | number
    name?: StringWithAggregatesFilter<"Campaign"> | string
    subject?: StringWithAggregatesFilter<"Campaign"> | string
    templateBody?: StringWithAggregatesFilter<"Campaign"> | string
    type?: StringWithAggregatesFilter<"Campaign"> | string
    status?: StringWithAggregatesFilter<"Campaign"> | string
    targetAudience?: JsonNullableWithAggregatesFilter<"Campaign">
    schedule?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    lastRunAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
  }

  export type CampaignLogWhereInput = {
    AND?: CampaignLogWhereInput | CampaignLogWhereInput[]
    OR?: CampaignLogWhereInput[]
    NOT?: CampaignLogWhereInput | CampaignLogWhereInput[]
    id?: IntFilter<"CampaignLog"> | number
    campaignId?: IntFilter<"CampaignLog"> | number
    runAt?: DateTimeFilter<"CampaignLog"> | Date | string
    status?: StringFilter<"CampaignLog"> | string
    recipientCount?: IntFilter<"CampaignLog"> | number
    sentCount?: IntFilter<"CampaignLog"> | number
    failedCount?: IntFilter<"CampaignLog"> | number
    errorLog?: JsonNullableFilter<"CampaignLog">
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type CampaignLogOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CampaignLogWhereInput | CampaignLogWhereInput[]
    OR?: CampaignLogWhereInput[]
    NOT?: CampaignLogWhereInput | CampaignLogWhereInput[]
    campaignId?: IntFilter<"CampaignLog"> | number
    runAt?: DateTimeFilter<"CampaignLog"> | Date | string
    status?: StringFilter<"CampaignLog"> | string
    recipientCount?: IntFilter<"CampaignLog"> | number
    sentCount?: IntFilter<"CampaignLog"> | number
    failedCount?: IntFilter<"CampaignLog"> | number
    errorLog?: JsonNullableFilter<"CampaignLog">
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type CampaignLogOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    errorLog?: SortOrderInput | SortOrder
    _count?: CampaignLogCountOrderByAggregateInput
    _avg?: CampaignLogAvgOrderByAggregateInput
    _max?: CampaignLogMaxOrderByAggregateInput
    _min?: CampaignLogMinOrderByAggregateInput
    _sum?: CampaignLogSumOrderByAggregateInput
  }

  export type CampaignLogScalarWhereWithAggregatesInput = {
    AND?: CampaignLogScalarWhereWithAggregatesInput | CampaignLogScalarWhereWithAggregatesInput[]
    OR?: CampaignLogScalarWhereWithAggregatesInput[]
    NOT?: CampaignLogScalarWhereWithAggregatesInput | CampaignLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CampaignLog"> | number
    campaignId?: IntWithAggregatesFilter<"CampaignLog"> | number
    runAt?: DateTimeWithAggregatesFilter<"CampaignLog"> | Date | string
    status?: StringWithAggregatesFilter<"CampaignLog"> | string
    recipientCount?: IntWithAggregatesFilter<"CampaignLog"> | number
    sentCount?: IntWithAggregatesFilter<"CampaignLog"> | number
    failedCount?: IntWithAggregatesFilter<"CampaignLog"> | number
    errorLog?: JsonNullableWithAggregatesFilter<"CampaignLog">
  }

  export type RateLimitWhereInput = {
    AND?: RateLimitWhereInput | RateLimitWhereInput[]
    OR?: RateLimitWhereInput[]
    NOT?: RateLimitWhereInput | RateLimitWhereInput[]
    key?: StringFilter<"RateLimit"> | string
    count?: IntFilter<"RateLimit"> | number
    resetAt?: DateTimeFilter<"RateLimit"> | Date | string
  }

  export type RateLimitOrderByWithRelationInput = {
    key?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
  }

  export type RateLimitWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: RateLimitWhereInput | RateLimitWhereInput[]
    OR?: RateLimitWhereInput[]
    NOT?: RateLimitWhereInput | RateLimitWhereInput[]
    count?: IntFilter<"RateLimit"> | number
    resetAt?: DateTimeFilter<"RateLimit"> | Date | string
  }, "key">

  export type RateLimitOrderByWithAggregationInput = {
    key?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
    _count?: RateLimitCountOrderByAggregateInput
    _avg?: RateLimitAvgOrderByAggregateInput
    _max?: RateLimitMaxOrderByAggregateInput
    _min?: RateLimitMinOrderByAggregateInput
    _sum?: RateLimitSumOrderByAggregateInput
  }

  export type RateLimitScalarWhereWithAggregatesInput = {
    AND?: RateLimitScalarWhereWithAggregatesInput | RateLimitScalarWhereWithAggregatesInput[]
    OR?: RateLimitScalarWhereWithAggregatesInput[]
    NOT?: RateLimitScalarWhereWithAggregatesInput | RateLimitScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"RateLimit"> | string
    count?: IntWithAggregatesFilter<"RateLimit"> | number
    resetAt?: DateTimeWithAggregatesFilter<"RateLimit"> | Date | string
  }

  export type UserCreateInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    students?: StudentCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
  }

  export type UserUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type UserUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type StudentCreateInput = {
    fullName: string
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    ambassador?: UserCreateNestedOneWithoutReferredStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    parent: UserCreateNestedOneWithoutStudentsInput
    referralLead?: ReferralLeadCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    studentId?: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    ambassador?: UserUpdateOneWithoutReferredStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parent?: UserUpdateOneRequiredWithoutStudentsNestedInput
    referralLead?: ReferralLeadUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentCreateManyInput = {
    studentId?: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUncheckedUpdateManyInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferralLeadCreateInput = {
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    user: UserCreateNestedOneWithoutReferralsInput
    student?: StudentCreateNestedOneWithoutReferralLeadInput
  }

  export type ReferralLeadUncheckedCreateInput = {
    leadId?: number
    userId: number
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    student?: StudentUncheckedCreateNestedOneWithoutReferralLeadInput
  }

  export type ReferralLeadUpdateInput = {
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutReferralsNestedInput
    student?: StudentUpdateOneWithoutReferralLeadNestedInput
  }

  export type ReferralLeadUncheckedUpdateInput = {
    leadId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUncheckedUpdateOneWithoutReferralLeadNestedInput
  }

  export type ReferralLeadCreateManyInput = {
    leadId?: number
    userId: number
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type ReferralLeadUpdateManyMutationInput = {
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReferralLeadUncheckedUpdateManyInput = {
    leadId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BenefitSlabCreateInput = {
    tierName?: string | null
    referralCount: number
    yearFeeBenefitPercent: number
    longTermExtraPercent: number
    baseLongTermPercent?: number
    description?: string | null
  }

  export type BenefitSlabUncheckedCreateInput = {
    slabId?: number
    tierName?: string | null
    referralCount: number
    yearFeeBenefitPercent: number
    longTermExtraPercent: number
    baseLongTermPercent?: number
    description?: string | null
  }

  export type BenefitSlabUpdateInput = {
    tierName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermExtraPercent?: FloatFieldUpdateOperationsInput | number
    baseLongTermPercent?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenefitSlabUncheckedUpdateInput = {
    slabId?: IntFieldUpdateOperationsInput | number
    tierName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermExtraPercent?: FloatFieldUpdateOperationsInput | number
    baseLongTermPercent?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenefitSlabCreateManyInput = {
    slabId?: number
    tierName?: string | null
    referralCount: number
    yearFeeBenefitPercent: number
    longTermExtraPercent: number
    baseLongTermPercent?: number
    description?: string | null
  }

  export type BenefitSlabUpdateManyMutationInput = {
    tierName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermExtraPercent?: FloatFieldUpdateOperationsInput | number
    baseLongTermPercent?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BenefitSlabUncheckedUpdateManyInput = {
    slabId?: IntFieldUpdateOperationsInput | number
    tierName?: NullableStringFieldUpdateOperationsInput | string | null
    referralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermExtraPercent?: FloatFieldUpdateOperationsInput | number
    baseLongTermPercent?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateInput = {
    adminName: string
    adminMobile: string
    assignedCampus?: string | null
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    password?: string | null
    role?: $Enums.AdminRole
    status?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    adminId?: number
    adminName: string
    adminMobile: string
    assignedCampus?: string | null
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    password?: string | null
    role?: $Enums.AdminRole
    status?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    adminId?: number
    adminName: string
    adminMobile: string
    assignedCampus?: string | null
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    password?: string | null
    role?: $Enums.AdminRole
    status?: $Enums.AccountStatus
  }

  export type AdminUpdateManyMutationInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type AdminUncheckedUpdateManyInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type SystemSettingsCreateInput = {
    allowNewRegistrations?: boolean
    defaultStudentFee?: number
    maintenanceMode?: boolean
    staffReferralText?: string | null
    parentReferralText?: string | null
    staffWelcomeMessage?: string | null
    parentWelcomeMessage?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    alumniReferralText?: string | null
    alumniWelcomeMessage?: string | null
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: number
    allowNewRegistrations?: boolean
    defaultStudentFee?: number
    maintenanceMode?: boolean
    staffReferralText?: string | null
    parentReferralText?: string | null
    staffWelcomeMessage?: string | null
    parentWelcomeMessage?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    alumniReferralText?: string | null
    alumniWelcomeMessage?: string | null
  }

  export type SystemSettingsUpdateInput = {
    allowNewRegistrations?: BoolFieldUpdateOperationsInput | boolean
    defaultStudentFee?: IntFieldUpdateOperationsInput | number
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    staffReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    parentReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    staffWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    parentWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    alumniReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    alumniWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    allowNewRegistrations?: BoolFieldUpdateOperationsInput | boolean
    defaultStudentFee?: IntFieldUpdateOperationsInput | number
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    staffReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    parentReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    staffWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    parentWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    alumniReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    alumniWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsCreateManyInput = {
    id?: number
    allowNewRegistrations?: boolean
    defaultStudentFee?: number
    maintenanceMode?: boolean
    staffReferralText?: string | null
    parentReferralText?: string | null
    staffWelcomeMessage?: string | null
    parentWelcomeMessage?: string | null
    updatedAt?: Date | string
    updatedBy?: string | null
    alumniReferralText?: string | null
    alumniWelcomeMessage?: string | null
  }

  export type SystemSettingsUpdateManyMutationInput = {
    allowNewRegistrations?: BoolFieldUpdateOperationsInput | boolean
    defaultStudentFee?: IntFieldUpdateOperationsInput | number
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    staffReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    parentReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    staffWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    parentWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    alumniReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    alumniWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    allowNewRegistrations?: BoolFieldUpdateOperationsInput | boolean
    defaultStudentFee?: IntFieldUpdateOperationsInput | number
    maintenanceMode?: BoolFieldUpdateOperationsInput | boolean
    staffReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    parentReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    staffWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    parentWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    alumniReferralText?: NullableStringFieldUpdateOperationsInput | string | null
    alumniWelcomeMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AcademicYearCreateInput = {
    year: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: number
    year: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearUpdateInput = {
    year?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearCreateManyInput = {
    id?: number
    year: string
    startDate: Date | string
    endDate: Date | string
    isActive?: boolean
    isCurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearUpdateManyMutationInput = {
    year?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    year?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadManagementSettingsCreateInput = {
    autoAssignLeads?: boolean
    leadStaleDays?: number
    followupEscalationDays?: number
    duplicateDetectionEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type LeadManagementSettingsUncheckedCreateInput = {
    id?: number
    autoAssignLeads?: boolean
    leadStaleDays?: number
    followupEscalationDays?: number
    duplicateDetectionEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type LeadManagementSettingsUpdateInput = {
    autoAssignLeads?: BoolFieldUpdateOperationsInput | boolean
    leadStaleDays?: IntFieldUpdateOperationsInput | number
    followupEscalationDays?: IntFieldUpdateOperationsInput | number
    duplicateDetectionEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadManagementSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    autoAssignLeads?: BoolFieldUpdateOperationsInput | boolean
    leadStaleDays?: IntFieldUpdateOperationsInput | number
    followupEscalationDays?: IntFieldUpdateOperationsInput | number
    duplicateDetectionEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadManagementSettingsCreateManyInput = {
    id?: number
    autoAssignLeads?: boolean
    leadStaleDays?: number
    followupEscalationDays?: number
    duplicateDetectionEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type LeadManagementSettingsUpdateManyMutationInput = {
    autoAssignLeads?: BoolFieldUpdateOperationsInput | boolean
    leadStaleDays?: IntFieldUpdateOperationsInput | number
    followupEscalationDays?: IntFieldUpdateOperationsInput | number
    duplicateDetectionEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LeadManagementSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    autoAssignLeads?: BoolFieldUpdateOperationsInput | boolean
    leadStaleDays?: IntFieldUpdateOperationsInput | number
    followupEscalationDays?: IntFieldUpdateOperationsInput | number
    duplicateDetectionEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySettingsCreateInput = {
    sessionTimeoutMinutes?: number
    maxLoginAttempts?: number
    passwordResetExpiryHours?: number
    twoFactorAuthEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
    ipWhitelist?: string | null
  }

  export type SecuritySettingsUncheckedCreateInput = {
    id?: number
    sessionTimeoutMinutes?: number
    maxLoginAttempts?: number
    passwordResetExpiryHours?: number
    twoFactorAuthEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
    ipWhitelist?: string | null
  }

  export type SecuritySettingsUpdateInput = {
    sessionTimeoutMinutes?: IntFieldUpdateOperationsInput | number
    maxLoginAttempts?: IntFieldUpdateOperationsInput | number
    passwordResetExpiryHours?: IntFieldUpdateOperationsInput | number
    twoFactorAuthEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ipWhitelist?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionTimeoutMinutes?: IntFieldUpdateOperationsInput | number
    maxLoginAttempts?: IntFieldUpdateOperationsInput | number
    passwordResetExpiryHours?: IntFieldUpdateOperationsInput | number
    twoFactorAuthEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ipWhitelist?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySettingsCreateManyInput = {
    id?: number
    sessionTimeoutMinutes?: number
    maxLoginAttempts?: number
    passwordResetExpiryHours?: number
    twoFactorAuthEnabled?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
    ipWhitelist?: string | null
  }

  export type SecuritySettingsUpdateManyMutationInput = {
    sessionTimeoutMinutes?: IntFieldUpdateOperationsInput | number
    maxLoginAttempts?: IntFieldUpdateOperationsInput | number
    passwordResetExpiryHours?: IntFieldUpdateOperationsInput | number
    twoFactorAuthEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ipWhitelist?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SecuritySettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionTimeoutMinutes?: IntFieldUpdateOperationsInput | number
    maxLoginAttempts?: IntFieldUpdateOperationsInput | number
    passwordResetExpiryHours?: IntFieldUpdateOperationsInput | number
    twoFactorAuthEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    ipWhitelist?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRetentionSettingsCreateInput = {
    keepInactiveDataMonths?: number
    archiveLeadsAfterDays?: number
    backupFrequencyDays?: number
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type DataRetentionSettingsUncheckedCreateInput = {
    id?: number
    keepInactiveDataMonths?: number
    archiveLeadsAfterDays?: number
    backupFrequencyDays?: number
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type DataRetentionSettingsUpdateInput = {
    keepInactiveDataMonths?: IntFieldUpdateOperationsInput | number
    archiveLeadsAfterDays?: IntFieldUpdateOperationsInput | number
    backupFrequencyDays?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRetentionSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keepInactiveDataMonths?: IntFieldUpdateOperationsInput | number
    archiveLeadsAfterDays?: IntFieldUpdateOperationsInput | number
    backupFrequencyDays?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRetentionSettingsCreateManyInput = {
    id?: number
    keepInactiveDataMonths?: number
    archiveLeadsAfterDays?: number
    backupFrequencyDays?: number
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type DataRetentionSettingsUpdateManyMutationInput = {
    keepInactiveDataMonths?: IntFieldUpdateOperationsInput | number
    archiveLeadsAfterDays?: IntFieldUpdateOperationsInput | number
    backupFrequencyDays?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DataRetentionSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keepInactiveDataMonths?: IntFieldUpdateOperationsInput | number
    archiveLeadsAfterDays?: IntFieldUpdateOperationsInput | number
    backupFrequencyDays?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolePermissionsCreateInput = {
    role: string
    analyticsAccess?: boolean
    analyticsScope?: string
    userMgmtAccess?: boolean
    userMgmtScope?: string
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: string
    adminMgmtAccess?: boolean
    adminMgmtScope?: string
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: string
    reportsAccess?: boolean
    reportsScope?: string
    settlementsAccess?: boolean
    settlementsScope?: string
    marketingKitAccess?: boolean
    marketingKitScope?: string
    auditLogAccess?: boolean
    auditLogScope?: string
    supportDeskAccess?: boolean
    supportDeskScope?: string
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: string
    referralTrackingAccess?: boolean
    referralTrackingScope?: string
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: string
    rulesAccessAccess?: boolean
    rulesAccessScope?: string
    settingsAccess?: boolean
    settingsScope?: string
    updatedAt?: Date | string
    updatedBy?: string | null
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: string
    passwordResetAccess?: boolean
    passwordResetScope?: string
    engagementCentreAccess?: boolean
    engagementCentreScope?: string
    feeManagementAccess?: boolean
    feeManagementScope?: string
  }

  export type RolePermissionsUncheckedCreateInput = {
    id?: number
    role: string
    analyticsAccess?: boolean
    analyticsScope?: string
    userMgmtAccess?: boolean
    userMgmtScope?: string
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: string
    adminMgmtAccess?: boolean
    adminMgmtScope?: string
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: string
    reportsAccess?: boolean
    reportsScope?: string
    settlementsAccess?: boolean
    settlementsScope?: string
    marketingKitAccess?: boolean
    marketingKitScope?: string
    auditLogAccess?: boolean
    auditLogScope?: string
    supportDeskAccess?: boolean
    supportDeskScope?: string
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: string
    referralTrackingAccess?: boolean
    referralTrackingScope?: string
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: string
    rulesAccessAccess?: boolean
    rulesAccessScope?: string
    settingsAccess?: boolean
    settingsScope?: string
    updatedAt?: Date | string
    updatedBy?: string | null
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: string
    passwordResetAccess?: boolean
    passwordResetScope?: string
    engagementCentreAccess?: boolean
    engagementCentreScope?: string
    feeManagementAccess?: boolean
    feeManagementScope?: string
  }

  export type RolePermissionsUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    analyticsAccess?: BoolFieldUpdateOperationsInput | boolean
    analyticsScope?: StringFieldUpdateOperationsInput | string
    userMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    userMgmtScope?: StringFieldUpdateOperationsInput | string
    userMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    userMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    userMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    campusPerfAccess?: BoolFieldUpdateOperationsInput | boolean
    campusPerfScope?: StringFieldUpdateOperationsInput | string
    reportsAccess?: BoolFieldUpdateOperationsInput | boolean
    reportsScope?: StringFieldUpdateOperationsInput | string
    settlementsAccess?: BoolFieldUpdateOperationsInput | boolean
    settlementsScope?: StringFieldUpdateOperationsInput | string
    marketingKitAccess?: BoolFieldUpdateOperationsInput | boolean
    marketingKitScope?: StringFieldUpdateOperationsInput | string
    auditLogAccess?: BoolFieldUpdateOperationsInput | boolean
    auditLogScope?: StringFieldUpdateOperationsInput | string
    supportDeskAccess?: BoolFieldUpdateOperationsInput | boolean
    supportDeskScope?: StringFieldUpdateOperationsInput | string
    referralSubmissionAccess?: BoolFieldUpdateOperationsInput | boolean
    referralSubmissionScope?: StringFieldUpdateOperationsInput | string
    referralTrackingAccess?: BoolFieldUpdateOperationsInput | boolean
    referralTrackingScope?: StringFieldUpdateOperationsInput | string
    savingsCalculatorAccess?: BoolFieldUpdateOperationsInput | boolean
    savingsCalculatorScope?: StringFieldUpdateOperationsInput | string
    rulesAccessAccess?: BoolFieldUpdateOperationsInput | boolean
    rulesAccessScope?: StringFieldUpdateOperationsInput | string
    settingsAccess?: BoolFieldUpdateOperationsInput | boolean
    settingsScope?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    studentMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    deletionHubAccess?: BoolFieldUpdateOperationsInput | boolean
    deletionHubScope?: StringFieldUpdateOperationsInput | string
    passwordResetAccess?: BoolFieldUpdateOperationsInput | boolean
    passwordResetScope?: StringFieldUpdateOperationsInput | string
    engagementCentreAccess?: BoolFieldUpdateOperationsInput | boolean
    engagementCentreScope?: StringFieldUpdateOperationsInput | string
    feeManagementAccess?: BoolFieldUpdateOperationsInput | boolean
    feeManagementScope?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    analyticsAccess?: BoolFieldUpdateOperationsInput | boolean
    analyticsScope?: StringFieldUpdateOperationsInput | string
    userMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    userMgmtScope?: StringFieldUpdateOperationsInput | string
    userMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    userMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    userMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    campusPerfAccess?: BoolFieldUpdateOperationsInput | boolean
    campusPerfScope?: StringFieldUpdateOperationsInput | string
    reportsAccess?: BoolFieldUpdateOperationsInput | boolean
    reportsScope?: StringFieldUpdateOperationsInput | string
    settlementsAccess?: BoolFieldUpdateOperationsInput | boolean
    settlementsScope?: StringFieldUpdateOperationsInput | string
    marketingKitAccess?: BoolFieldUpdateOperationsInput | boolean
    marketingKitScope?: StringFieldUpdateOperationsInput | string
    auditLogAccess?: BoolFieldUpdateOperationsInput | boolean
    auditLogScope?: StringFieldUpdateOperationsInput | string
    supportDeskAccess?: BoolFieldUpdateOperationsInput | boolean
    supportDeskScope?: StringFieldUpdateOperationsInput | string
    referralSubmissionAccess?: BoolFieldUpdateOperationsInput | boolean
    referralSubmissionScope?: StringFieldUpdateOperationsInput | string
    referralTrackingAccess?: BoolFieldUpdateOperationsInput | boolean
    referralTrackingScope?: StringFieldUpdateOperationsInput | string
    savingsCalculatorAccess?: BoolFieldUpdateOperationsInput | boolean
    savingsCalculatorScope?: StringFieldUpdateOperationsInput | string
    rulesAccessAccess?: BoolFieldUpdateOperationsInput | boolean
    rulesAccessScope?: StringFieldUpdateOperationsInput | string
    settingsAccess?: BoolFieldUpdateOperationsInput | boolean
    settingsScope?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    studentMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    deletionHubAccess?: BoolFieldUpdateOperationsInput | boolean
    deletionHubScope?: StringFieldUpdateOperationsInput | string
    passwordResetAccess?: BoolFieldUpdateOperationsInput | boolean
    passwordResetScope?: StringFieldUpdateOperationsInput | string
    engagementCentreAccess?: BoolFieldUpdateOperationsInput | boolean
    engagementCentreScope?: StringFieldUpdateOperationsInput | string
    feeManagementAccess?: BoolFieldUpdateOperationsInput | boolean
    feeManagementScope?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionsCreateManyInput = {
    id?: number
    role: string
    analyticsAccess?: boolean
    analyticsScope?: string
    userMgmtAccess?: boolean
    userMgmtScope?: string
    userMgmtCreate?: boolean
    userMgmtEdit?: boolean
    userMgmtDelete?: boolean
    studentMgmtAccess?: boolean
    studentMgmtScope?: string
    adminMgmtAccess?: boolean
    adminMgmtScope?: string
    adminMgmtCreate?: boolean
    adminMgmtEdit?: boolean
    adminMgmtDelete?: boolean
    campusPerfAccess?: boolean
    campusPerfScope?: string
    reportsAccess?: boolean
    reportsScope?: string
    settlementsAccess?: boolean
    settlementsScope?: string
    marketingKitAccess?: boolean
    marketingKitScope?: string
    auditLogAccess?: boolean
    auditLogScope?: string
    supportDeskAccess?: boolean
    supportDeskScope?: string
    referralSubmissionAccess?: boolean
    referralSubmissionScope?: string
    referralTrackingAccess?: boolean
    referralTrackingScope?: string
    savingsCalculatorAccess?: boolean
    savingsCalculatorScope?: string
    rulesAccessAccess?: boolean
    rulesAccessScope?: string
    settingsAccess?: boolean
    settingsScope?: string
    updatedAt?: Date | string
    updatedBy?: string | null
    studentMgmtCreate?: boolean
    studentMgmtDelete?: boolean
    studentMgmtEdit?: boolean
    deletionHubAccess?: boolean
    deletionHubScope?: string
    passwordResetAccess?: boolean
    passwordResetScope?: string
    engagementCentreAccess?: boolean
    engagementCentreScope?: string
    feeManagementAccess?: boolean
    feeManagementScope?: string
  }

  export type RolePermissionsUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    analyticsAccess?: BoolFieldUpdateOperationsInput | boolean
    analyticsScope?: StringFieldUpdateOperationsInput | string
    userMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    userMgmtScope?: StringFieldUpdateOperationsInput | string
    userMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    userMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    userMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    campusPerfAccess?: BoolFieldUpdateOperationsInput | boolean
    campusPerfScope?: StringFieldUpdateOperationsInput | string
    reportsAccess?: BoolFieldUpdateOperationsInput | boolean
    reportsScope?: StringFieldUpdateOperationsInput | string
    settlementsAccess?: BoolFieldUpdateOperationsInput | boolean
    settlementsScope?: StringFieldUpdateOperationsInput | string
    marketingKitAccess?: BoolFieldUpdateOperationsInput | boolean
    marketingKitScope?: StringFieldUpdateOperationsInput | string
    auditLogAccess?: BoolFieldUpdateOperationsInput | boolean
    auditLogScope?: StringFieldUpdateOperationsInput | string
    supportDeskAccess?: BoolFieldUpdateOperationsInput | boolean
    supportDeskScope?: StringFieldUpdateOperationsInput | string
    referralSubmissionAccess?: BoolFieldUpdateOperationsInput | boolean
    referralSubmissionScope?: StringFieldUpdateOperationsInput | string
    referralTrackingAccess?: BoolFieldUpdateOperationsInput | boolean
    referralTrackingScope?: StringFieldUpdateOperationsInput | string
    savingsCalculatorAccess?: BoolFieldUpdateOperationsInput | boolean
    savingsCalculatorScope?: StringFieldUpdateOperationsInput | string
    rulesAccessAccess?: BoolFieldUpdateOperationsInput | boolean
    rulesAccessScope?: StringFieldUpdateOperationsInput | string
    settingsAccess?: BoolFieldUpdateOperationsInput | boolean
    settingsScope?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    studentMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    deletionHubAccess?: BoolFieldUpdateOperationsInput | boolean
    deletionHubScope?: StringFieldUpdateOperationsInput | string
    passwordResetAccess?: BoolFieldUpdateOperationsInput | boolean
    passwordResetScope?: StringFieldUpdateOperationsInput | string
    engagementCentreAccess?: BoolFieldUpdateOperationsInput | boolean
    engagementCentreScope?: StringFieldUpdateOperationsInput | string
    feeManagementAccess?: BoolFieldUpdateOperationsInput | boolean
    feeManagementScope?: StringFieldUpdateOperationsInput | string
  }

  export type RolePermissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    analyticsAccess?: BoolFieldUpdateOperationsInput | boolean
    analyticsScope?: StringFieldUpdateOperationsInput | string
    userMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    userMgmtScope?: StringFieldUpdateOperationsInput | string
    userMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    userMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    userMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtAccess?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtScope?: StringFieldUpdateOperationsInput | string
    adminMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    adminMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    campusPerfAccess?: BoolFieldUpdateOperationsInput | boolean
    campusPerfScope?: StringFieldUpdateOperationsInput | string
    reportsAccess?: BoolFieldUpdateOperationsInput | boolean
    reportsScope?: StringFieldUpdateOperationsInput | string
    settlementsAccess?: BoolFieldUpdateOperationsInput | boolean
    settlementsScope?: StringFieldUpdateOperationsInput | string
    marketingKitAccess?: BoolFieldUpdateOperationsInput | boolean
    marketingKitScope?: StringFieldUpdateOperationsInput | string
    auditLogAccess?: BoolFieldUpdateOperationsInput | boolean
    auditLogScope?: StringFieldUpdateOperationsInput | string
    supportDeskAccess?: BoolFieldUpdateOperationsInput | boolean
    supportDeskScope?: StringFieldUpdateOperationsInput | string
    referralSubmissionAccess?: BoolFieldUpdateOperationsInput | boolean
    referralSubmissionScope?: StringFieldUpdateOperationsInput | string
    referralTrackingAccess?: BoolFieldUpdateOperationsInput | boolean
    referralTrackingScope?: StringFieldUpdateOperationsInput | string
    savingsCalculatorAccess?: BoolFieldUpdateOperationsInput | boolean
    savingsCalculatorScope?: StringFieldUpdateOperationsInput | string
    rulesAccessAccess?: BoolFieldUpdateOperationsInput | boolean
    rulesAccessScope?: StringFieldUpdateOperationsInput | string
    settingsAccess?: BoolFieldUpdateOperationsInput | boolean
    settingsScope?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    studentMgmtCreate?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtDelete?: BoolFieldUpdateOperationsInput | boolean
    studentMgmtEdit?: BoolFieldUpdateOperationsInput | boolean
    deletionHubAccess?: BoolFieldUpdateOperationsInput | boolean
    deletionHubScope?: StringFieldUpdateOperationsInput | string
    passwordResetAccess?: BoolFieldUpdateOperationsInput | boolean
    passwordResetScope?: StringFieldUpdateOperationsInput | string
    engagementCentreAccess?: BoolFieldUpdateOperationsInput | boolean
    engagementCentreScope?: StringFieldUpdateOperationsInput | string
    feeManagementAccess?: BoolFieldUpdateOperationsInput | boolean
    feeManagementScope?: StringFieldUpdateOperationsInput | string
  }

  export type SettlementCreateInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettlementsInput
  }

  export type SettlementUncheckedCreateInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type SettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementCreateManyInput = {
    id?: number
    userId: number
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    title: string
    description?: string | null
    type: string
    category: string
    fileUrl: string
    thumbnailUrl?: string | null
    isActive?: boolean
    uploadedBy: number
    createdAt?: Date | string
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    type: string
    category: string
    fileUrl: string
    thumbnailUrl?: string | null
    isActive?: boolean
    uploadedBy: number
    createdAt?: Date | string
  }

  export type ResourceUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    type: string
    category: string
    fileUrl: string
    thumbnailUrl?: string | null
    isActive?: boolean
    uploadedBy: number
    createdAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    uploadedBy?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    adminId?: number | null
    userId?: number | null
    action: string
    module: string
    targetId?: string | null
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    adminId?: number | null
    userId?: number | null
    action: string
    module: string
    targetId?: string | null
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogUpdateInput = {
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    adminId?: number | null
    userId?: number | null
    action: string
    module: string
    targetId?: string | null
    description: string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogUpdateManyMutationInput = {
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SupportTicketCreateInput = {
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSupportTicketsInput
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketCreateManyInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
  }

  export type SupportTicketUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SupportTicketUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TicketMessageCreateInput = {
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
    ticket: SupportTicketCreateNestedOneWithoutMessagesInput
  }

  export type TicketMessageUncheckedCreateInput = {
    id?: number
    ticketId: number
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateInput = {
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: SupportTicketUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type TicketMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateManyInput = {
    id?: number
    ticketId: number
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateManyMutationInput = {
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ticketId?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusCreateInput = {
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetCreateNestedManyWithoutCampusInput
    gradeFees?: GradeFeeCreateNestedManyWithoutCampusInput
    students?: StudentCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateInput = {
    id?: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetUncheckedCreateNestedManyWithoutCampusInput
    gradeFees?: GradeFeeUncheckedCreateNestedManyWithoutCampusInput
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusUpdateInput = {
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUpdateManyWithoutCampusNestedInput
    gradeFees?: GradeFeeUpdateManyWithoutCampusNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUncheckedUpdateManyWithoutCampusNestedInput
    gradeFees?: GradeFeeUncheckedUpdateManyWithoutCampusNestedInput
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type CampusCreateManyInput = {
    id?: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampusUpdateManyMutationInput = {
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetCreateInput = {
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
    campus: CampusCreateNestedOneWithoutTargetsInput
  }

  export type CampusTargetUncheckedCreateInput = {
    id?: number
    campusId: number
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
  }

  export type CampusTargetUpdateInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: CampusUpdateOneRequiredWithoutTargetsNestedInput
  }

  export type CampusTargetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetCreateManyInput = {
    id?: number
    campusId: number
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
  }

  export type CampusTargetUpdateManyMutationInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeFeeCreateInput = {
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    academicYear?: string
    campus: CampusCreateNestedOneWithoutGradeFeesInput
  }

  export type GradeFeeUncheckedCreateInput = {
    id?: number
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    campusId: number
    academicYear?: string
  }

  export type GradeFeeUpdateInput = {
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: StringFieldUpdateOperationsInput | string
    campus?: CampusUpdateOneRequiredWithoutGradeFeesNestedInput
  }

  export type GradeFeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    campusId?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type GradeFeeCreateManyInput = {
    id?: number
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    campusId: number
    academicYear?: string
  }

  export type GradeFeeUpdateManyMutationInput = {
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type GradeFeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    campusId?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationSettingsCreateInput = {
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: number
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type NotificationSettingsUncheckedCreateInput = {
    id?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: number
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type NotificationSettingsUpdateInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    whatsappNotifications?: BoolFieldUpdateOperationsInput | boolean
    leadFollowupReminders?: BoolFieldUpdateOperationsInput | boolean
    reminderFrequencyDays?: IntFieldUpdateOperationsInput | number
    notifySuperAdminOnNewAdmins?: BoolFieldUpdateOperationsInput | boolean
    notifyCampusHeadOnNewLeads?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    whatsappNotifications?: BoolFieldUpdateOperationsInput | boolean
    leadFollowupReminders?: BoolFieldUpdateOperationsInput | boolean
    reminderFrequencyDays?: IntFieldUpdateOperationsInput | number
    notifySuperAdminOnNewAdmins?: BoolFieldUpdateOperationsInput | boolean
    notifyCampusHeadOnNewLeads?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationSettingsCreateManyInput = {
    id?: number
    emailNotifications?: boolean
    smsNotifications?: boolean
    whatsappNotifications?: boolean
    leadFollowupReminders?: boolean
    reminderFrequencyDays?: number
    notifySuperAdminOnNewAdmins?: boolean
    notifyCampusHeadOnNewLeads?: boolean
    updatedAt?: Date | string
    updatedBy?: string | null
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    whatsappNotifications?: BoolFieldUpdateOperationsInput | boolean
    leadFollowupReminders?: BoolFieldUpdateOperationsInput | boolean
    reminderFrequencyDays?: IntFieldUpdateOperationsInput | number
    notifySuperAdminOnNewAdmins?: BoolFieldUpdateOperationsInput | boolean
    notifyCampusHeadOnNewLeads?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    emailNotifications?: BoolFieldUpdateOperationsInput | boolean
    smsNotifications?: BoolFieldUpdateOperationsInput | boolean
    whatsappNotifications?: BoolFieldUpdateOperationsInput | boolean
    leadFollowupReminders?: BoolFieldUpdateOperationsInput | boolean
    reminderFrequencyDays?: IntFieldUpdateOperationsInput | number
    notifySuperAdminOnNewAdmins?: BoolFieldUpdateOperationsInput | boolean
    notifyCampusHeadOnNewLeads?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketingAssetCreateInput = {
    name: string
    category: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    isActive?: boolean
    sortOrder?: number
    uploadedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingAssetUncheckedCreateInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    isActive?: boolean
    sortOrder?: number
    uploadedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingAssetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingAssetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingAssetCreateManyInput = {
    id?: number
    name: string
    category: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    fileSize?: number | null
    isActive?: boolean
    sortOrder?: number
    uploadedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingAssetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingAssetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    uploadedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationCreateInput = {
    mobile: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpVerificationUncheckedCreateInput = {
    id?: number
    mobile: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpVerificationUpdateInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobile?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationCreateManyInput = {
    id?: number
    mobile: string
    otp: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OtpVerificationUpdateManyMutationInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mobile?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    admin?: AdminCreateNestedOneWithoutNotificationsInput
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId?: number | null
    adminId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutNotificationsNestedInput
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId?: number | null
    adminId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    name: string
    subject: string
    templateBody: string
    type?: string
    status?: string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    logs?: CampaignLogCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: number
    name: string
    subject: string
    templateBody: string
    type?: string
    status?: string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
    logs?: CampaignLogUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: CampaignLogUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: CampaignLogUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: number
    name: string
    subject: string
    templateBody: string
    type?: string
    status?: string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type CampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignLogCreateInput = {
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    campaign: CampaignCreateNestedOneWithoutLogsInput
  }

  export type CampaignLogUncheckedCreateInput = {
    id?: number
    campaignId: number
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUpdateInput = {
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
    campaign?: CampaignUpdateOneRequiredWithoutLogsNestedInput
  }

  export type CampaignLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogCreateManyInput = {
    id?: number
    campaignId: number
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUpdateManyMutationInput = {
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    campaignId?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RateLimitCreateInput = {
    key: string
    count?: number
    resetAt: Date | string
  }

  export type RateLimitUncheckedCreateInput = {
    key: string
    count?: number
    resetAt: Date | string
  }

  export type RateLimitUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitCreateManyInput = {
    key: string
    count?: number
    resetAt: Date | string
  }

  export type RateLimitUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RateLimitUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    resetAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ReferralLeadListRelationFilter = {
    every?: ReferralLeadWhereInput
    some?: ReferralLeadWhereInput
    none?: ReferralLeadWhereInput
  }

  export type SettlementListRelationFilter = {
    every?: SettlementWhereInput
    some?: SettlementWhereInput
    none?: SettlementWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type SupportTicketListRelationFilter = {
    every?: SupportTicketWhereInput
    some?: SupportTicketWhereInput
    none?: SupportTicketWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    mobileNumber?: SortOrder
    childInAchariya?: SortOrder
    childName?: SortOrder
    grade?: SortOrder
    campusId?: SortOrder
    bankAccountDetails?: SortOrder
    referralCode?: SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrder
    isFiveStarMember?: SortOrder
    assignedCampus?: SortOrder
    studentFee?: SortOrder
    academicYear?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paymentAmount?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    aadharNo?: SortOrder
    childEprNo?: SortOrder
    empId?: SortOrder
    password?: SortOrder
    deletionRequestedAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    benefitStatus?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    userId?: SortOrder
    campusId?: SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrder
    studentFee?: SortOrder
    paymentAmount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    mobileNumber?: SortOrder
    childInAchariya?: SortOrder
    childName?: SortOrder
    grade?: SortOrder
    campusId?: SortOrder
    bankAccountDetails?: SortOrder
    referralCode?: SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrder
    isFiveStarMember?: SortOrder
    assignedCampus?: SortOrder
    studentFee?: SortOrder
    academicYear?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paymentAmount?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    aadharNo?: SortOrder
    childEprNo?: SortOrder
    empId?: SortOrder
    password?: SortOrder
    deletionRequestedAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    benefitStatus?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userId?: SortOrder
    fullName?: SortOrder
    mobileNumber?: SortOrder
    childInAchariya?: SortOrder
    childName?: SortOrder
    grade?: SortOrder
    campusId?: SortOrder
    bankAccountDetails?: SortOrder
    referralCode?: SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrder
    isFiveStarMember?: SortOrder
    assignedCampus?: SortOrder
    studentFee?: SortOrder
    academicYear?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    paymentAmount?: SortOrder
    paymentStatus?: SortOrder
    transactionId?: SortOrder
    aadharNo?: SortOrder
    childEprNo?: SortOrder
    empId?: SortOrder
    password?: SortOrder
    deletionRequestedAt?: SortOrder
    role?: SortOrder
    status?: SortOrder
    benefitStatus?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    userId?: SortOrder
    campusId?: SortOrder
    confirmedReferralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermBenefitPercent?: SortOrder
    lastActiveYear?: SortOrder
    studentFee?: SortOrder
    paymentAmount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type EnumFeeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableFilter<$PrismaModel> | $Enums.FeeType | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CampusRelationFilter = {
    is?: CampusWhereInput
    isNot?: CampusWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReferralLeadNullableRelationFilter = {
    is?: ReferralLeadWhereInput | null
    isNot?: ReferralLeadWhereInput | null
  }

  export type StudentCountOrderByAggregateInput = {
    studentId?: SortOrder
    fullName?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    rollNumber?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambassadorId?: SortOrder
    admissionNumber?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrder
    ambassadorId?: SortOrder
    annualFee?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    studentId?: SortOrder
    fullName?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    rollNumber?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambassadorId?: SortOrder
    admissionNumber?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    studentId?: SortOrder
    fullName?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    grade?: SortOrder
    section?: SortOrder
    rollNumber?: SortOrder
    academicYear?: SortOrder
    status?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ambassadorId?: SortOrder
    admissionNumber?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    campusId?: SortOrder
    baseFee?: SortOrder
    discountPercent?: SortOrder
    referralLeadId?: SortOrder
    ambassadorId?: SortOrder
    annualFee?: SortOrder
  }

  export type EnumFeeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ReferralLeadCountOrderByAggregateInput = {
    leadId?: SortOrder
    userId?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    campusId?: SortOrder
    campus?: SortOrder
    gradeInterested?: SortOrder
    admittedYear?: SortOrder
    confirmedDate?: SortOrder
    createdAt?: SortOrder
    studentName?: SortOrder
    leadStatus?: SortOrder
    admissionNumber?: SortOrder
    section?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type ReferralLeadAvgOrderByAggregateInput = {
    leadId?: SortOrder
    userId?: SortOrder
    campusId?: SortOrder
    annualFee?: SortOrder
  }

  export type ReferralLeadMaxOrderByAggregateInput = {
    leadId?: SortOrder
    userId?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    campusId?: SortOrder
    campus?: SortOrder
    gradeInterested?: SortOrder
    admittedYear?: SortOrder
    confirmedDate?: SortOrder
    createdAt?: SortOrder
    studentName?: SortOrder
    leadStatus?: SortOrder
    admissionNumber?: SortOrder
    section?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type ReferralLeadMinOrderByAggregateInput = {
    leadId?: SortOrder
    userId?: SortOrder
    parentName?: SortOrder
    parentMobile?: SortOrder
    campusId?: SortOrder
    campus?: SortOrder
    gradeInterested?: SortOrder
    admittedYear?: SortOrder
    confirmedDate?: SortOrder
    createdAt?: SortOrder
    studentName?: SortOrder
    leadStatus?: SortOrder
    admissionNumber?: SortOrder
    section?: SortOrder
    selectedFeeType?: SortOrder
    annualFee?: SortOrder
  }

  export type ReferralLeadSumOrderByAggregateInput = {
    leadId?: SortOrder
    userId?: SortOrder
    campusId?: SortOrder
    annualFee?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type BenefitSlabCountOrderByAggregateInput = {
    slabId?: SortOrder
    tierName?: SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
    description?: SortOrder
  }

  export type BenefitSlabAvgOrderByAggregateInput = {
    slabId?: SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
  }

  export type BenefitSlabMaxOrderByAggregateInput = {
    slabId?: SortOrder
    tierName?: SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
    description?: SortOrder
  }

  export type BenefitSlabMinOrderByAggregateInput = {
    slabId?: SortOrder
    tierName?: SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
    description?: SortOrder
  }

  export type BenefitSlabSumOrderByAggregateInput = {
    slabId?: SortOrder
    referralCount?: SortOrder
    yearFeeBenefitPercent?: SortOrder
    longTermExtraPercent?: SortOrder
    baseLongTermPercent?: SortOrder
  }

  export type EnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type AdminCountOrderByAggregateInput = {
    adminId?: SortOrder
    adminName?: SortOrder
    adminMobile?: SortOrder
    assignedCampus?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    adminId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    adminId?: SortOrder
    adminName?: SortOrder
    adminMobile?: SortOrder
    assignedCampus?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    adminId?: SortOrder
    adminName?: SortOrder
    adminMobile?: SortOrder
    assignedCampus?: SortOrder
    createdAt?: SortOrder
    profileImage?: SortOrder
    email?: SortOrder
    address?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    adminId?: SortOrder
  }

  export type EnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    allowNewRegistrations?: SortOrder
    defaultStudentFee?: SortOrder
    maintenanceMode?: SortOrder
    staffReferralText?: SortOrder
    parentReferralText?: SortOrder
    staffWelcomeMessage?: SortOrder
    parentWelcomeMessage?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    alumniReferralText?: SortOrder
    alumniWelcomeMessage?: SortOrder
  }

  export type SystemSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    defaultStudentFee?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    allowNewRegistrations?: SortOrder
    defaultStudentFee?: SortOrder
    maintenanceMode?: SortOrder
    staffReferralText?: SortOrder
    parentReferralText?: SortOrder
    staffWelcomeMessage?: SortOrder
    parentWelcomeMessage?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    alumniReferralText?: SortOrder
    alumniWelcomeMessage?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    allowNewRegistrations?: SortOrder
    defaultStudentFee?: SortOrder
    maintenanceMode?: SortOrder
    staffReferralText?: SortOrder
    parentReferralText?: SortOrder
    staffWelcomeMessage?: SortOrder
    parentWelcomeMessage?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    alumniReferralText?: SortOrder
    alumniWelcomeMessage?: SortOrder
  }

  export type SystemSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    defaultStudentFee?: SortOrder
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isCurrent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AcademicYearSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeadManagementSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    autoAssignLeads?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
    duplicateDetectionEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeadManagementSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
  }

  export type LeadManagementSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    autoAssignLeads?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
    duplicateDetectionEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeadManagementSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    autoAssignLeads?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
    duplicateDetectionEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type LeadManagementSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    leadStaleDays?: SortOrder
    followupEscalationDays?: SortOrder
  }

  export type SecuritySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
    twoFactorAuthEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    ipWhitelist?: SortOrder
  }

  export type SecuritySettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
  }

  export type SecuritySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
    twoFactorAuthEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    ipWhitelist?: SortOrder
  }

  export type SecuritySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
    twoFactorAuthEnabled?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    ipWhitelist?: SortOrder
  }

  export type SecuritySettingsSumOrderByAggregateInput = {
    id?: SortOrder
    sessionTimeoutMinutes?: SortOrder
    maxLoginAttempts?: SortOrder
    passwordResetExpiryHours?: SortOrder
  }

  export type DataRetentionSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DataRetentionSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
  }

  export type DataRetentionSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DataRetentionSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type DataRetentionSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    keepInactiveDataMonths?: SortOrder
    archiveLeadsAfterDays?: SortOrder
    backupFrequencyDays?: SortOrder
  }

  export type RolePermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    analyticsAccess?: SortOrder
    analyticsScope?: SortOrder
    userMgmtAccess?: SortOrder
    userMgmtScope?: SortOrder
    userMgmtCreate?: SortOrder
    userMgmtEdit?: SortOrder
    userMgmtDelete?: SortOrder
    studentMgmtAccess?: SortOrder
    studentMgmtScope?: SortOrder
    adminMgmtAccess?: SortOrder
    adminMgmtScope?: SortOrder
    adminMgmtCreate?: SortOrder
    adminMgmtEdit?: SortOrder
    adminMgmtDelete?: SortOrder
    campusPerfAccess?: SortOrder
    campusPerfScope?: SortOrder
    reportsAccess?: SortOrder
    reportsScope?: SortOrder
    settlementsAccess?: SortOrder
    settlementsScope?: SortOrder
    marketingKitAccess?: SortOrder
    marketingKitScope?: SortOrder
    auditLogAccess?: SortOrder
    auditLogScope?: SortOrder
    supportDeskAccess?: SortOrder
    supportDeskScope?: SortOrder
    referralSubmissionAccess?: SortOrder
    referralSubmissionScope?: SortOrder
    referralTrackingAccess?: SortOrder
    referralTrackingScope?: SortOrder
    savingsCalculatorAccess?: SortOrder
    savingsCalculatorScope?: SortOrder
    rulesAccessAccess?: SortOrder
    rulesAccessScope?: SortOrder
    settingsAccess?: SortOrder
    settingsScope?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    studentMgmtCreate?: SortOrder
    studentMgmtDelete?: SortOrder
    studentMgmtEdit?: SortOrder
    deletionHubAccess?: SortOrder
    deletionHubScope?: SortOrder
    passwordResetAccess?: SortOrder
    passwordResetScope?: SortOrder
    engagementCentreAccess?: SortOrder
    engagementCentreScope?: SortOrder
    feeManagementAccess?: SortOrder
    feeManagementScope?: SortOrder
  }

  export type RolePermissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolePermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    analyticsAccess?: SortOrder
    analyticsScope?: SortOrder
    userMgmtAccess?: SortOrder
    userMgmtScope?: SortOrder
    userMgmtCreate?: SortOrder
    userMgmtEdit?: SortOrder
    userMgmtDelete?: SortOrder
    studentMgmtAccess?: SortOrder
    studentMgmtScope?: SortOrder
    adminMgmtAccess?: SortOrder
    adminMgmtScope?: SortOrder
    adminMgmtCreate?: SortOrder
    adminMgmtEdit?: SortOrder
    adminMgmtDelete?: SortOrder
    campusPerfAccess?: SortOrder
    campusPerfScope?: SortOrder
    reportsAccess?: SortOrder
    reportsScope?: SortOrder
    settlementsAccess?: SortOrder
    settlementsScope?: SortOrder
    marketingKitAccess?: SortOrder
    marketingKitScope?: SortOrder
    auditLogAccess?: SortOrder
    auditLogScope?: SortOrder
    supportDeskAccess?: SortOrder
    supportDeskScope?: SortOrder
    referralSubmissionAccess?: SortOrder
    referralSubmissionScope?: SortOrder
    referralTrackingAccess?: SortOrder
    referralTrackingScope?: SortOrder
    savingsCalculatorAccess?: SortOrder
    savingsCalculatorScope?: SortOrder
    rulesAccessAccess?: SortOrder
    rulesAccessScope?: SortOrder
    settingsAccess?: SortOrder
    settingsScope?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    studentMgmtCreate?: SortOrder
    studentMgmtDelete?: SortOrder
    studentMgmtEdit?: SortOrder
    deletionHubAccess?: SortOrder
    deletionHubScope?: SortOrder
    passwordResetAccess?: SortOrder
    passwordResetScope?: SortOrder
    engagementCentreAccess?: SortOrder
    engagementCentreScope?: SortOrder
    feeManagementAccess?: SortOrder
    feeManagementScope?: SortOrder
  }

  export type RolePermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    analyticsAccess?: SortOrder
    analyticsScope?: SortOrder
    userMgmtAccess?: SortOrder
    userMgmtScope?: SortOrder
    userMgmtCreate?: SortOrder
    userMgmtEdit?: SortOrder
    userMgmtDelete?: SortOrder
    studentMgmtAccess?: SortOrder
    studentMgmtScope?: SortOrder
    adminMgmtAccess?: SortOrder
    adminMgmtScope?: SortOrder
    adminMgmtCreate?: SortOrder
    adminMgmtEdit?: SortOrder
    adminMgmtDelete?: SortOrder
    campusPerfAccess?: SortOrder
    campusPerfScope?: SortOrder
    reportsAccess?: SortOrder
    reportsScope?: SortOrder
    settlementsAccess?: SortOrder
    settlementsScope?: SortOrder
    marketingKitAccess?: SortOrder
    marketingKitScope?: SortOrder
    auditLogAccess?: SortOrder
    auditLogScope?: SortOrder
    supportDeskAccess?: SortOrder
    supportDeskScope?: SortOrder
    referralSubmissionAccess?: SortOrder
    referralSubmissionScope?: SortOrder
    referralTrackingAccess?: SortOrder
    referralTrackingScope?: SortOrder
    savingsCalculatorAccess?: SortOrder
    savingsCalculatorScope?: SortOrder
    rulesAccessAccess?: SortOrder
    rulesAccessScope?: SortOrder
    settingsAccess?: SortOrder
    settingsScope?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
    studentMgmtCreate?: SortOrder
    studentMgmtDelete?: SortOrder
    studentMgmtEdit?: SortOrder
    deletionHubAccess?: SortOrder
    deletionHubScope?: SortOrder
    passwordResetAccess?: SortOrder
    passwordResetScope?: SortOrder
    engagementCentreAccess?: SortOrder
    engagementCentreScope?: SortOrder
    feeManagementAccess?: SortOrder
    feeManagementScope?: SortOrder
  }

  export type RolePermissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettlementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    bankReference?: SortOrder
    payoutDate?: SortOrder
    processedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    processedBy?: SortOrder
  }

  export type SettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    bankReference?: SortOrder
    payoutDate?: SortOrder
    processedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    bankReference?: SortOrder
    payoutDate?: SortOrder
    processedBy?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettlementSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    processedBy?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    isActive?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    uploadedBy?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    targetId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type TicketMessageListRelationFilter = {
    every?: TicketMessageWhereInput
    some?: TicketMessageWhereInput
    none?: TicketMessageWhereInput
  }

  export type TicketMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportTicketCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campus?: SortOrder
    message?: SortOrder
    resolvedAt?: SortOrder
    escalationLevel?: SortOrder
    lastEscalatedAt?: SortOrder
  }

  export type SupportTicketAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedAdminId?: SortOrder
    escalationLevel?: SortOrder
  }

  export type SupportTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campus?: SortOrder
    message?: SortOrder
    resolvedAt?: SortOrder
    escalationLevel?: SortOrder
    lastEscalatedAt?: SortOrder
  }

  export type SupportTicketMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedAdminId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campus?: SortOrder
    message?: SortOrder
    resolvedAt?: SortOrder
    escalationLevel?: SortOrder
    lastEscalatedAt?: SortOrder
  }

  export type SupportTicketSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    assignedAdminId?: SortOrder
    escalationLevel?: SortOrder
  }

  export type SupportTicketRelationFilter = {
    is?: SupportTicketWhereInput
    isNot?: SupportTicketWhereInput
  }

  export type TicketMessageCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
  }

  export type TicketMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    message?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMessageSumOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    senderId?: SortOrder
  }

  export type CampusTargetListRelationFilter = {
    every?: CampusTargetWhereInput
    some?: CampusTargetWhereInput
    none?: CampusTargetWhereInput
  }

  export type GradeFeeListRelationFilter = {
    every?: GradeFeeWhereInput
    some?: GradeFeeWhereInput
    none?: GradeFeeWhereInput
  }

  export type CampusTargetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampusCountOrderByAggregateInput = {
    id?: SortOrder
    campusName?: SortOrder
    campusCode?: SortOrder
    location?: SortOrder
    grades?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    isActive?: SortOrder
    campusHeadId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusAvgOrderByAggregateInput = {
    id?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    campusHeadId?: SortOrder
  }

  export type CampusMaxOrderByAggregateInput = {
    id?: SortOrder
    campusName?: SortOrder
    campusCode?: SortOrder
    location?: SortOrder
    grades?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    isActive?: SortOrder
    campusHeadId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusMinOrderByAggregateInput = {
    id?: SortOrder
    campusName?: SortOrder
    campusCode?: SortOrder
    location?: SortOrder
    grades?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    isActive?: SortOrder
    campusHeadId?: SortOrder
    contactEmail?: SortOrder
    contactPhone?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusSumOrderByAggregateInput = {
    id?: SortOrder
    maxCapacity?: SortOrder
    currentEnrollment?: SortOrder
    campusHeadId?: SortOrder
  }

  export type CampusTargetCampusIdMonthYearCompoundUniqueInput = {
    campusId: number
    month: number
    year: number
  }

  export type CampusTargetCountOrderByAggregateInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusTargetAvgOrderByAggregateInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
  }

  export type CampusTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusTargetMinOrderByAggregateInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusTargetSumOrderByAggregateInput = {
    id?: SortOrder
    campusId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    leadTarget?: SortOrder
    admissionTarget?: SortOrder
  }

  export type GradeFeeCampusIdGradeAcademicYearCompoundUniqueInput = {
    campusId: number
    grade: string
    academicYear: string
  }

  export type GradeFeeCountOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    annualFee_otp?: SortOrder
    annualFee_wotp?: SortOrder
    campusId?: SortOrder
    academicYear?: SortOrder
  }

  export type GradeFeeAvgOrderByAggregateInput = {
    id?: SortOrder
    annualFee_otp?: SortOrder
    annualFee_wotp?: SortOrder
    campusId?: SortOrder
  }

  export type GradeFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    annualFee_otp?: SortOrder
    annualFee_wotp?: SortOrder
    campusId?: SortOrder
    academicYear?: SortOrder
  }

  export type GradeFeeMinOrderByAggregateInput = {
    id?: SortOrder
    grade?: SortOrder
    annualFee_otp?: SortOrder
    annualFee_wotp?: SortOrder
    campusId?: SortOrder
    academicYear?: SortOrder
  }

  export type GradeFeeSumOrderByAggregateInput = {
    id?: SortOrder
    annualFee_otp?: SortOrder
    annualFee_wotp?: SortOrder
    campusId?: SortOrder
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    whatsappNotifications?: SortOrder
    leadFollowupReminders?: SortOrder
    reminderFrequencyDays?: SortOrder
    notifySuperAdminOnNewAdmins?: SortOrder
    notifyCampusHeadOnNewLeads?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type NotificationSettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    reminderFrequencyDays?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    whatsappNotifications?: SortOrder
    leadFollowupReminders?: SortOrder
    reminderFrequencyDays?: SortOrder
    notifySuperAdminOnNewAdmins?: SortOrder
    notifyCampusHeadOnNewLeads?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    emailNotifications?: SortOrder
    smsNotifications?: SortOrder
    whatsappNotifications?: SortOrder
    leadFollowupReminders?: SortOrder
    reminderFrequencyDays?: SortOrder
    notifySuperAdminOnNewAdmins?: SortOrder
    notifyCampusHeadOnNewLeads?: SortOrder
    updatedAt?: SortOrder
    updatedBy?: SortOrder
  }

  export type NotificationSettingsSumOrderByAggregateInput = {
    id?: SortOrder
    reminderFrequencyDays?: SortOrder
  }

  export type MarketingAssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingAssetAvgOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrder
  }

  export type MarketingAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingAssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingAssetSumOrderByAggregateInput = {
    id?: SortOrder
    fileSize?: SortOrder
    sortOrder?: SortOrder
    uploadedById?: SortOrder
  }

  export type OtpVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OtpVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    mobile?: SortOrder
    otp?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpVerificationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adminId?: SortOrder
  }

  export type CampaignLogListRelationFilter = {
    every?: CampaignLogWhereInput
    some?: CampaignLogWhereInput
    none?: CampaignLogWhereInput
  }

  export type CampaignLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    templateBody?: SortOrder
    type?: SortOrder
    status?: SortOrder
    targetAudience?: SortOrder
    schedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    templateBody?: SortOrder
    type?: SortOrder
    status?: SortOrder
    schedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subject?: SortOrder
    templateBody?: SortOrder
    type?: SortOrder
    status?: SortOrder
    schedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastRunAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignLogCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
    errorLog?: SortOrder
  }

  export type CampaignLogAvgOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignLogMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignLogMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type CampaignLogSumOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    recipientCount?: SortOrder
    sentCount?: SortOrder
    failedCount?: SortOrder
  }

  export type RateLimitCountOrderByAggregateInput = {
    key?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
  }

  export type RateLimitAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type RateLimitMaxOrderByAggregateInput = {
    key?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
  }

  export type RateLimitMinOrderByAggregateInput = {
    key?: SortOrder
    count?: SortOrder
    resetAt?: SortOrder
  }

  export type RateLimitSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReferralLeadCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput> | ReferralLeadCreateWithoutUserInput[] | ReferralLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutUserInput | ReferralLeadCreateOrConnectWithoutUserInput[]
    createMany?: ReferralLeadCreateManyUserInputEnvelope
    connect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
  }

  export type SettlementCreateNestedManyWithoutUserInput = {
    create?: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput> | SettlementCreateWithoutUserInput[] | SettlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutUserInput | SettlementCreateOrConnectWithoutUserInput[]
    createMany?: SettlementCreateManyUserInputEnvelope
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutAmbassadorInput = {
    create?: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput> | StudentCreateWithoutAmbassadorInput[] | StudentUncheckedCreateWithoutAmbassadorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAmbassadorInput | StudentCreateOrConnectWithoutAmbassadorInput[]
    createMany?: StudentCreateManyAmbassadorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput> | StudentCreateWithoutParentInput[] | StudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput | StudentCreateOrConnectWithoutParentInput[]
    createMany?: StudentCreateManyParentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SupportTicketCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ReferralLeadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput> | ReferralLeadCreateWithoutUserInput[] | ReferralLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutUserInput | ReferralLeadCreateOrConnectWithoutUserInput[]
    createMany?: ReferralLeadCreateManyUserInputEnvelope
    connect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
  }

  export type SettlementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput> | SettlementCreateWithoutUserInput[] | SettlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutUserInput | SettlementCreateOrConnectWithoutUserInput[]
    createMany?: SettlementCreateManyUserInputEnvelope
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutAmbassadorInput = {
    create?: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput> | StudentCreateWithoutAmbassadorInput[] | StudentUncheckedCreateWithoutAmbassadorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAmbassadorInput | StudentCreateOrConnectWithoutAmbassadorInput[]
    createMany?: StudentCreateManyAmbassadorInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput> | StudentCreateWithoutParentInput[] | StudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput | StudentCreateOrConnectWithoutParentInput[]
    createMany?: StudentCreateManyParentInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type SupportTicketUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReferralLeadUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput> | ReferralLeadCreateWithoutUserInput[] | ReferralLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutUserInput | ReferralLeadCreateOrConnectWithoutUserInput[]
    upsert?: ReferralLeadUpsertWithWhereUniqueWithoutUserInput | ReferralLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralLeadCreateManyUserInputEnvelope
    set?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    disconnect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    delete?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    connect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    update?: ReferralLeadUpdateWithWhereUniqueWithoutUserInput | ReferralLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralLeadUpdateManyWithWhereWithoutUserInput | ReferralLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralLeadScalarWhereInput | ReferralLeadScalarWhereInput[]
  }

  export type SettlementUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput> | SettlementCreateWithoutUserInput[] | SettlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutUserInput | SettlementCreateOrConnectWithoutUserInput[]
    upsert?: SettlementUpsertWithWhereUniqueWithoutUserInput | SettlementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettlementCreateManyUserInputEnvelope
    set?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    disconnect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    delete?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    update?: SettlementUpdateWithWhereUniqueWithoutUserInput | SettlementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettlementUpdateManyWithWhereWithoutUserInput | SettlementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutAmbassadorNestedInput = {
    create?: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput> | StudentCreateWithoutAmbassadorInput[] | StudentUncheckedCreateWithoutAmbassadorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAmbassadorInput | StudentCreateOrConnectWithoutAmbassadorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAmbassadorInput | StudentUpsertWithWhereUniqueWithoutAmbassadorInput[]
    createMany?: StudentCreateManyAmbassadorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAmbassadorInput | StudentUpdateWithWhereUniqueWithoutAmbassadorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAmbassadorInput | StudentUpdateManyWithWhereWithoutAmbassadorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput> | StudentCreateWithoutParentInput[] | StudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput | StudentCreateOrConnectWithoutParentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutParentInput | StudentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentCreateManyParentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutParentInput | StudentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutParentInput | StudentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SupportTicketUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ReferralLeadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput> | ReferralLeadCreateWithoutUserInput[] | ReferralLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutUserInput | ReferralLeadCreateOrConnectWithoutUserInput[]
    upsert?: ReferralLeadUpsertWithWhereUniqueWithoutUserInput | ReferralLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReferralLeadCreateManyUserInputEnvelope
    set?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    disconnect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    delete?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    connect?: ReferralLeadWhereUniqueInput | ReferralLeadWhereUniqueInput[]
    update?: ReferralLeadUpdateWithWhereUniqueWithoutUserInput | ReferralLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReferralLeadUpdateManyWithWhereWithoutUserInput | ReferralLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReferralLeadScalarWhereInput | ReferralLeadScalarWhereInput[]
  }

  export type SettlementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput> | SettlementCreateWithoutUserInput[] | SettlementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SettlementCreateOrConnectWithoutUserInput | SettlementCreateOrConnectWithoutUserInput[]
    upsert?: SettlementUpsertWithWhereUniqueWithoutUserInput | SettlementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SettlementCreateManyUserInputEnvelope
    set?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    disconnect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    delete?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    connect?: SettlementWhereUniqueInput | SettlementWhereUniqueInput[]
    update?: SettlementUpdateWithWhereUniqueWithoutUserInput | SettlementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SettlementUpdateManyWithWhereWithoutUserInput | SettlementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutAmbassadorNestedInput = {
    create?: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput> | StudentCreateWithoutAmbassadorInput[] | StudentUncheckedCreateWithoutAmbassadorInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutAmbassadorInput | StudentCreateOrConnectWithoutAmbassadorInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutAmbassadorInput | StudentUpsertWithWhereUniqueWithoutAmbassadorInput[]
    createMany?: StudentCreateManyAmbassadorInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutAmbassadorInput | StudentUpdateWithWhereUniqueWithoutAmbassadorInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutAmbassadorInput | StudentUpdateManyWithWhereWithoutAmbassadorInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput> | StudentCreateWithoutParentInput[] | StudentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentInput | StudentCreateOrConnectWithoutParentInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutParentInput | StudentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentCreateManyParentInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutParentInput | StudentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutParentInput | StudentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput> | SupportTicketCreateWithoutUserInput[] | SupportTicketUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SupportTicketCreateOrConnectWithoutUserInput | SupportTicketCreateOrConnectWithoutUserInput[]
    upsert?: SupportTicketUpsertWithWhereUniqueWithoutUserInput | SupportTicketUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SupportTicketCreateManyUserInputEnvelope
    set?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    disconnect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    delete?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    connect?: SupportTicketWhereUniqueInput | SupportTicketWhereUniqueInput[]
    update?: SupportTicketUpdateWithWhereUniqueWithoutUserInput | SupportTicketUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SupportTicketUpdateManyWithWhereWithoutUserInput | SupportTicketUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReferredStudentsInput = {
    create?: XOR<UserCreateWithoutReferredStudentsInput, UserUncheckedCreateWithoutReferredStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type CampusCreateNestedOneWithoutStudentsInput = {
    create?: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutStudentsInput
    connect?: CampusWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudentsInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReferralLeadCreateNestedOneWithoutStudentInput = {
    create?: XOR<ReferralLeadCreateWithoutStudentInput, ReferralLeadUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutStudentInput
    connect?: ReferralLeadWhereUniqueInput
  }

  export type NullableEnumFeeTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeeType | null
  }

  export type UserUpdateOneWithoutReferredStudentsNestedInput = {
    create?: XOR<UserCreateWithoutReferredStudentsInput, UserUncheckedCreateWithoutReferredStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredStudentsInput
    upsert?: UserUpsertWithoutReferredStudentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredStudentsInput, UserUpdateWithoutReferredStudentsInput>, UserUncheckedUpdateWithoutReferredStudentsInput>
  }

  export type CampusUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutStudentsInput
    upsert?: CampusUpsertWithoutStudentsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutStudentsInput, CampusUpdateWithoutStudentsInput>, CampusUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentsInput
    upsert?: UserUpsertWithoutStudentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentsInput, UserUpdateWithoutStudentsInput>, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type ReferralLeadUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ReferralLeadCreateWithoutStudentInput, ReferralLeadUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ReferralLeadCreateOrConnectWithoutStudentInput
    upsert?: ReferralLeadUpsertWithoutStudentInput
    disconnect?: ReferralLeadWhereInput | boolean
    delete?: ReferralLeadWhereInput | boolean
    connect?: ReferralLeadWhereUniqueInput
    update?: XOR<XOR<ReferralLeadUpdateToOneWithWhereWithoutStudentInput, ReferralLeadUpdateWithoutStudentInput>, ReferralLeadUncheckedUpdateWithoutStudentInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutReferralLeadInput = {
    create?: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReferralLeadInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUncheckedCreateNestedOneWithoutReferralLeadInput = {
    create?: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReferralLeadInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type StudentUpdateOneWithoutReferralLeadNestedInput = {
    create?: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReferralLeadInput
    upsert?: StudentUpsertWithoutReferralLeadInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReferralLeadInput, StudentUpdateWithoutReferralLeadInput>, StudentUncheckedUpdateWithoutReferralLeadInput>
  }

  export type StudentUncheckedUpdateOneWithoutReferralLeadNestedInput = {
    create?: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReferralLeadInput
    upsert?: StudentUpsertWithoutReferralLeadInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReferralLeadInput, StudentUpdateWithoutReferralLeadInput>, StudentUncheckedUpdateWithoutReferralLeadInput>
  }

  export type NotificationCreateNestedManyWithoutAdminInput = {
    create?: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput> | NotificationCreateWithoutAdminInput[] | NotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAdminInput | NotificationCreateOrConnectWithoutAdminInput[]
    createMany?: NotificationCreateManyAdminInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput> | NotificationCreateWithoutAdminInput[] | NotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAdminInput | NotificationCreateOrConnectWithoutAdminInput[]
    createMany?: NotificationCreateManyAdminInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumAdminRoleFieldUpdateOperationsInput = {
    set?: $Enums.AdminRole
  }

  export type NotificationUpdateManyWithoutAdminNestedInput = {
    create?: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput> | NotificationCreateWithoutAdminInput[] | NotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAdminInput | NotificationCreateOrConnectWithoutAdminInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAdminInput | NotificationUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: NotificationCreateManyAdminInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAdminInput | NotificationUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAdminInput | NotificationUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput> | NotificationCreateWithoutAdminInput[] | NotificationUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutAdminInput | NotificationCreateOrConnectWithoutAdminInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutAdminInput | NotificationUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: NotificationCreateManyAdminInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutAdminInput | NotificationUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutAdminInput | NotificationUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<UserCreateWithoutSettlementsInput, UserUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<UserCreateWithoutSettlementsInput, UserUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettlementsInput
    upsert?: UserUpsertWithoutSettlementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettlementsInput, UserUpdateWithoutSettlementsInput>, UserUncheckedUpdateWithoutSettlementsInput>
  }

  export type UserCreateNestedOneWithoutSupportTicketsInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type TicketMessageCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type TicketMessageUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSupportTicketsNestedInput = {
    create?: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupportTicketsInput
    upsert?: UserUpsertWithoutSupportTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupportTicketsInput, UserUpdateWithoutSupportTicketsInput>, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type TicketMessageUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput> | TicketMessageCreateWithoutTicketInput[] | TicketMessageUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketMessageCreateOrConnectWithoutTicketInput | TicketMessageCreateOrConnectWithoutTicketInput[]
    upsert?: TicketMessageUpsertWithWhereUniqueWithoutTicketInput | TicketMessageUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketMessageCreateManyTicketInputEnvelope
    set?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    disconnect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    delete?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    connect?: TicketMessageWhereUniqueInput | TicketMessageWhereUniqueInput[]
    update?: TicketMessageUpdateWithWhereUniqueWithoutTicketInput | TicketMessageUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketMessageUpdateManyWithWhereWithoutTicketInput | TicketMessageUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
  }

  export type SupportTicketCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
  }

  export type SupportTicketUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportTicketCreateOrConnectWithoutMessagesInput
    upsert?: SupportTicketUpsertWithoutMessagesInput
    connect?: SupportTicketWhereUniqueInput
    update?: XOR<XOR<SupportTicketUpdateToOneWithWhereWithoutMessagesInput, SupportTicketUpdateWithoutMessagesInput>, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type CampusTargetCreateNestedManyWithoutCampusInput = {
    create?: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput> | CampusTargetCreateWithoutCampusInput[] | CampusTargetUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: CampusTargetCreateOrConnectWithoutCampusInput | CampusTargetCreateOrConnectWithoutCampusInput[]
    createMany?: CampusTargetCreateManyCampusInputEnvelope
    connect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
  }

  export type GradeFeeCreateNestedManyWithoutCampusInput = {
    create?: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput> | GradeFeeCreateWithoutCampusInput[] | GradeFeeUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: GradeFeeCreateOrConnectWithoutCampusInput | GradeFeeCreateOrConnectWithoutCampusInput[]
    createMany?: GradeFeeCreateManyCampusInputEnvelope
    connect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutCampusInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CampusTargetUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput> | CampusTargetCreateWithoutCampusInput[] | CampusTargetUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: CampusTargetCreateOrConnectWithoutCampusInput | CampusTargetCreateOrConnectWithoutCampusInput[]
    createMany?: CampusTargetCreateManyCampusInputEnvelope
    connect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
  }

  export type GradeFeeUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput> | GradeFeeCreateWithoutCampusInput[] | GradeFeeUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: GradeFeeCreateOrConnectWithoutCampusInput | GradeFeeCreateOrConnectWithoutCampusInput[]
    createMany?: GradeFeeCreateManyCampusInputEnvelope
    connect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type CampusTargetUpdateManyWithoutCampusNestedInput = {
    create?: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput> | CampusTargetCreateWithoutCampusInput[] | CampusTargetUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: CampusTargetCreateOrConnectWithoutCampusInput | CampusTargetCreateOrConnectWithoutCampusInput[]
    upsert?: CampusTargetUpsertWithWhereUniqueWithoutCampusInput | CampusTargetUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: CampusTargetCreateManyCampusInputEnvelope
    set?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    disconnect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    delete?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    connect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    update?: CampusTargetUpdateWithWhereUniqueWithoutCampusInput | CampusTargetUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: CampusTargetUpdateManyWithWhereWithoutCampusInput | CampusTargetUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: CampusTargetScalarWhereInput | CampusTargetScalarWhereInput[]
  }

  export type GradeFeeUpdateManyWithoutCampusNestedInput = {
    create?: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput> | GradeFeeCreateWithoutCampusInput[] | GradeFeeUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: GradeFeeCreateOrConnectWithoutCampusInput | GradeFeeCreateOrConnectWithoutCampusInput[]
    upsert?: GradeFeeUpsertWithWhereUniqueWithoutCampusInput | GradeFeeUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: GradeFeeCreateManyCampusInputEnvelope
    set?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    disconnect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    delete?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    connect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    update?: GradeFeeUpdateWithWhereUniqueWithoutCampusInput | GradeFeeUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: GradeFeeUpdateManyWithWhereWithoutCampusInput | GradeFeeUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: GradeFeeScalarWhereInput | GradeFeeScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutCampusNestedInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCampusInput | StudentUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCampusInput | StudentUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCampusInput | StudentUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CampusTargetUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput> | CampusTargetCreateWithoutCampusInput[] | CampusTargetUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: CampusTargetCreateOrConnectWithoutCampusInput | CampusTargetCreateOrConnectWithoutCampusInput[]
    upsert?: CampusTargetUpsertWithWhereUniqueWithoutCampusInput | CampusTargetUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: CampusTargetCreateManyCampusInputEnvelope
    set?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    disconnect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    delete?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    connect?: CampusTargetWhereUniqueInput | CampusTargetWhereUniqueInput[]
    update?: CampusTargetUpdateWithWhereUniqueWithoutCampusInput | CampusTargetUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: CampusTargetUpdateManyWithWhereWithoutCampusInput | CampusTargetUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: CampusTargetScalarWhereInput | CampusTargetScalarWhereInput[]
  }

  export type GradeFeeUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput> | GradeFeeCreateWithoutCampusInput[] | GradeFeeUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: GradeFeeCreateOrConnectWithoutCampusInput | GradeFeeCreateOrConnectWithoutCampusInput[]
    upsert?: GradeFeeUpsertWithWhereUniqueWithoutCampusInput | GradeFeeUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: GradeFeeCreateManyCampusInputEnvelope
    set?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    disconnect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    delete?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    connect?: GradeFeeWhereUniqueInput | GradeFeeWhereUniqueInput[]
    update?: GradeFeeUpdateWithWhereUniqueWithoutCampusInput | GradeFeeUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: GradeFeeUpdateManyWithWhereWithoutCampusInput | GradeFeeUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: GradeFeeScalarWhereInput | GradeFeeScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCampusInput | StudentUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCampusInput | StudentUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCampusInput | StudentUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type CampusCreateNestedOneWithoutTargetsInput = {
    create?: XOR<CampusCreateWithoutTargetsInput, CampusUncheckedCreateWithoutTargetsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutTargetsInput
    connect?: CampusWhereUniqueInput
  }

  export type CampusUpdateOneRequiredWithoutTargetsNestedInput = {
    create?: XOR<CampusCreateWithoutTargetsInput, CampusUncheckedCreateWithoutTargetsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutTargetsInput
    upsert?: CampusUpsertWithoutTargetsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutTargetsInput, CampusUpdateWithoutTargetsInput>, CampusUncheckedUpdateWithoutTargetsInput>
  }

  export type CampusCreateNestedOneWithoutGradeFeesInput = {
    create?: XOR<CampusCreateWithoutGradeFeesInput, CampusUncheckedCreateWithoutGradeFeesInput>
    connectOrCreate?: CampusCreateOrConnectWithoutGradeFeesInput
    connect?: CampusWhereUniqueInput
  }

  export type CampusUpdateOneRequiredWithoutGradeFeesNestedInput = {
    create?: XOR<CampusCreateWithoutGradeFeesInput, CampusUncheckedCreateWithoutGradeFeesInput>
    connectOrCreate?: CampusCreateOrConnectWithoutGradeFeesInput
    upsert?: CampusUpsertWithoutGradeFeesInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutGradeFeesInput, CampusUpdateWithoutGradeFeesInput>, CampusUncheckedUpdateWithoutGradeFeesInput>
  }

  export type AdminCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNotificationsInput
    connect?: AdminWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type AdminUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutNotificationsInput
    upsert?: AdminUpsertWithoutNotificationsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutNotificationsInput, AdminUpdateWithoutNotificationsInput>, AdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type CampaignLogCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type CampaignLogUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
  }

  export type CampaignLogUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutCampaignInput | CampaignLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type CampaignLogUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput> | CampaignLogCreateWithoutCampaignInput[] | CampaignLogUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignLogCreateOrConnectWithoutCampaignInput | CampaignLogCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignLogUpsertWithWhereUniqueWithoutCampaignInput | CampaignLogUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignLogCreateManyCampaignInputEnvelope
    set?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    disconnect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    delete?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    connect?: CampaignLogWhereUniqueInput | CampaignLogWhereUniqueInput[]
    update?: CampaignLogUpdateWithWhereUniqueWithoutCampaignInput | CampaignLogUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignLogUpdateManyWithWhereWithoutCampaignInput | CampaignLogUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutLogsInput = {
    create?: XOR<CampaignCreateWithoutLogsInput, CampaignUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLogsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<CampaignCreateWithoutLogsInput, CampaignUncheckedCreateWithoutLogsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutLogsInput
    upsert?: CampaignUpsertWithoutLogsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutLogsInput, CampaignUpdateWithoutLogsInput>, CampaignUncheckedUpdateWithoutLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableFilter<$PrismaModel> | $Enums.FeeType | null
  }

  export type NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumFeeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.FeeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdminRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleFilter<$PrismaModel> | $Enums.AdminRole
  }

  export type NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminRole | EnumAdminRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminRole[] | ListEnumAdminRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminRoleWithAggregatesFilter<$PrismaModel> | $Enums.AdminRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminRoleFilter<$PrismaModel>
    _max?: NestedEnumAdminRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationCreateWithoutUserInput = {
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    admin?: AdminCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    adminId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralLeadCreateWithoutUserInput = {
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    student?: StudentCreateNestedOneWithoutReferralLeadInput
  }

  export type ReferralLeadUncheckedCreateWithoutUserInput = {
    leadId?: number
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    student?: StudentUncheckedCreateNestedOneWithoutReferralLeadInput
  }

  export type ReferralLeadCreateOrConnectWithoutUserInput = {
    where: ReferralLeadWhereUniqueInput
    create: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput>
  }

  export type ReferralLeadCreateManyUserInputEnvelope = {
    data: ReferralLeadCreateManyUserInput | ReferralLeadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SettlementCreateWithoutUserInput = {
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementUncheckedCreateWithoutUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettlementCreateOrConnectWithoutUserInput = {
    where: SettlementWhereUniqueInput
    create: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput>
  }

  export type SettlementCreateManyUserInputEnvelope = {
    data: SettlementCreateManyUserInput | SettlementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutAmbassadorInput = {
    fullName: string
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    campus: CampusCreateNestedOneWithoutStudentsInput
    parent: UserCreateNestedOneWithoutStudentsInput
    referralLead?: ReferralLeadCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAmbassadorInput = {
    studentId?: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentCreateOrConnectWithoutAmbassadorInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput>
  }

  export type StudentCreateManyAmbassadorInputEnvelope = {
    data: StudentCreateManyAmbassadorInput | StudentCreateManyAmbassadorInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutParentInput = {
    fullName: string
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    ambassador?: UserCreateNestedOneWithoutReferredStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    referralLead?: ReferralLeadCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentInput = {
    studentId?: number
    fullName: string
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentCreateOrConnectWithoutParentInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
  }

  export type StudentCreateManyParentInputEnvelope = {
    data: StudentCreateManyParentInput | StudentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type SupportTicketCreateWithoutUserInput = {
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
    messages?: TicketMessageCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketUncheckedCreateWithoutUserInput = {
    id?: number
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
    messages?: TicketMessageUncheckedCreateNestedManyWithoutTicketInput
  }

  export type SupportTicketCreateOrConnectWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketCreateManyUserInputEnvelope = {
    data: SupportTicketCreateManyUserInput | SupportTicketCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntNullableFilter<"Notification"> | number | null
    adminId?: IntNullableFilter<"Notification"> | number | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    link?: StringNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ReferralLeadUpsertWithWhereUniqueWithoutUserInput = {
    where: ReferralLeadWhereUniqueInput
    update: XOR<ReferralLeadUpdateWithoutUserInput, ReferralLeadUncheckedUpdateWithoutUserInput>
    create: XOR<ReferralLeadCreateWithoutUserInput, ReferralLeadUncheckedCreateWithoutUserInput>
  }

  export type ReferralLeadUpdateWithWhereUniqueWithoutUserInput = {
    where: ReferralLeadWhereUniqueInput
    data: XOR<ReferralLeadUpdateWithoutUserInput, ReferralLeadUncheckedUpdateWithoutUserInput>
  }

  export type ReferralLeadUpdateManyWithWhereWithoutUserInput = {
    where: ReferralLeadScalarWhereInput
    data: XOR<ReferralLeadUpdateManyMutationInput, ReferralLeadUncheckedUpdateManyWithoutUserInput>
  }

  export type ReferralLeadScalarWhereInput = {
    AND?: ReferralLeadScalarWhereInput | ReferralLeadScalarWhereInput[]
    OR?: ReferralLeadScalarWhereInput[]
    NOT?: ReferralLeadScalarWhereInput | ReferralLeadScalarWhereInput[]
    leadId?: IntFilter<"ReferralLead"> | number
    userId?: IntFilter<"ReferralLead"> | number
    parentName?: StringFilter<"ReferralLead"> | string
    parentMobile?: StringFilter<"ReferralLead"> | string
    campusId?: IntNullableFilter<"ReferralLead"> | number | null
    campus?: StringNullableFilter<"ReferralLead"> | string | null
    gradeInterested?: StringNullableFilter<"ReferralLead"> | string | null
    admittedYear?: StringNullableFilter<"ReferralLead"> | string | null
    confirmedDate?: DateTimeNullableFilter<"ReferralLead"> | Date | string | null
    createdAt?: DateTimeFilter<"ReferralLead"> | Date | string
    studentName?: StringNullableFilter<"ReferralLead"> | string | null
    leadStatus?: EnumLeadStatusFilter<"ReferralLead"> | $Enums.LeadStatus
    admissionNumber?: StringNullableFilter<"ReferralLead"> | string | null
    section?: StringNullableFilter<"ReferralLead"> | string | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"ReferralLead"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"ReferralLead"> | number | null
  }

  export type SettlementUpsertWithWhereUniqueWithoutUserInput = {
    where: SettlementWhereUniqueInput
    update: XOR<SettlementUpdateWithoutUserInput, SettlementUncheckedUpdateWithoutUserInput>
    create: XOR<SettlementCreateWithoutUserInput, SettlementUncheckedCreateWithoutUserInput>
  }

  export type SettlementUpdateWithWhereUniqueWithoutUserInput = {
    where: SettlementWhereUniqueInput
    data: XOR<SettlementUpdateWithoutUserInput, SettlementUncheckedUpdateWithoutUserInput>
  }

  export type SettlementUpdateManyWithWhereWithoutUserInput = {
    where: SettlementScalarWhereInput
    data: XOR<SettlementUpdateManyMutationInput, SettlementUncheckedUpdateManyWithoutUserInput>
  }

  export type SettlementScalarWhereInput = {
    AND?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
    OR?: SettlementScalarWhereInput[]
    NOT?: SettlementScalarWhereInput | SettlementScalarWhereInput[]
    id?: IntFilter<"Settlement"> | number
    userId?: IntFilter<"Settlement"> | number
    amount?: FloatFilter<"Settlement"> | number
    status?: StringFilter<"Settlement"> | string
    paymentMethod?: StringNullableFilter<"Settlement"> | string | null
    bankReference?: StringNullableFilter<"Settlement"> | string | null
    payoutDate?: DateTimeNullableFilter<"Settlement"> | Date | string | null
    processedBy?: IntNullableFilter<"Settlement"> | number | null
    remarks?: StringNullableFilter<"Settlement"> | string | null
    createdAt?: DateTimeFilter<"Settlement"> | Date | string
    updatedAt?: DateTimeFilter<"Settlement"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutAmbassadorInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutAmbassadorInput, StudentUncheckedUpdateWithoutAmbassadorInput>
    create: XOR<StudentCreateWithoutAmbassadorInput, StudentUncheckedCreateWithoutAmbassadorInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutAmbassadorInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutAmbassadorInput, StudentUncheckedUpdateWithoutAmbassadorInput>
  }

  export type StudentUpdateManyWithWhereWithoutAmbassadorInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutAmbassadorInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    studentId?: IntFilter<"Student"> | number
    fullName?: StringFilter<"Student"> | string
    parentId?: IntFilter<"Student"> | number
    campusId?: IntFilter<"Student"> | number
    grade?: StringFilter<"Student"> | string
    section?: StringNullableFilter<"Student"> | string | null
    rollNumber?: StringNullableFilter<"Student"> | string | null
    academicYear?: StringFilter<"Student"> | string
    status?: StringFilter<"Student"> | string
    baseFee?: IntFilter<"Student"> | number
    discountPercent?: FloatFilter<"Student"> | number
    referralLeadId?: IntNullableFilter<"Student"> | number | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    ambassadorId?: IntNullableFilter<"Student"> | number | null
    admissionNumber?: StringNullableFilter<"Student"> | string | null
    selectedFeeType?: EnumFeeTypeNullableFilter<"Student"> | $Enums.FeeType | null
    annualFee?: IntNullableFilter<"Student"> | number | null
  }

  export type StudentUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutParentInput, StudentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentCreateWithoutParentInput, StudentUncheckedCreateWithoutParentInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutParentInput, StudentUncheckedUpdateWithoutParentInput>
  }

  export type StudentUpdateManyWithWhereWithoutParentInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutParentInput>
  }

  export type SupportTicketUpsertWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    update: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
    create: XOR<SupportTicketCreateWithoutUserInput, SupportTicketUncheckedCreateWithoutUserInput>
  }

  export type SupportTicketUpdateWithWhereUniqueWithoutUserInput = {
    where: SupportTicketWhereUniqueInput
    data: XOR<SupportTicketUpdateWithoutUserInput, SupportTicketUncheckedUpdateWithoutUserInput>
  }

  export type SupportTicketUpdateManyWithWhereWithoutUserInput = {
    where: SupportTicketScalarWhereInput
    data: XOR<SupportTicketUpdateManyMutationInput, SupportTicketUncheckedUpdateManyWithoutUserInput>
  }

  export type SupportTicketScalarWhereInput = {
    AND?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    OR?: SupportTicketScalarWhereInput[]
    NOT?: SupportTicketScalarWhereInput | SupportTicketScalarWhereInput[]
    id?: IntFilter<"SupportTicket"> | number
    userId?: IntFilter<"SupportTicket"> | number
    subject?: StringFilter<"SupportTicket"> | string
    category?: StringFilter<"SupportTicket"> | string
    priority?: StringFilter<"SupportTicket"> | string
    status?: StringFilter<"SupportTicket"> | string
    assignedAdminId?: IntNullableFilter<"SupportTicket"> | number | null
    createdAt?: DateTimeFilter<"SupportTicket"> | Date | string
    updatedAt?: DateTimeFilter<"SupportTicket"> | Date | string
    campus?: StringNullableFilter<"SupportTicket"> | string | null
    message?: StringFilter<"SupportTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
    escalationLevel?: IntFilter<"SupportTicket"> | number
    lastEscalatedAt?: DateTimeNullableFilter<"SupportTicket"> | Date | string | null
  }

  export type UserCreateWithoutReferredStudentsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    students?: StudentCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferredStudentsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferredStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredStudentsInput, UserUncheckedCreateWithoutReferredStudentsInput>
  }

  export type CampusCreateWithoutStudentsInput = {
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetCreateNestedManyWithoutCampusInput
    gradeFees?: GradeFeeCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutStudentsInput = {
    id?: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetUncheckedCreateNestedManyWithoutCampusInput
    gradeFees?: GradeFeeUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutStudentsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
  }

  export type UserCreateWithoutStudentsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
  }

  export type ReferralLeadCreateWithoutStudentInput = {
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    user: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralLeadUncheckedCreateWithoutStudentInput = {
    leadId?: number
    userId: number
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type ReferralLeadCreateOrConnectWithoutStudentInput = {
    where: ReferralLeadWhereUniqueInput
    create: XOR<ReferralLeadCreateWithoutStudentInput, ReferralLeadUncheckedCreateWithoutStudentInput>
  }

  export type UserUpsertWithoutReferredStudentsInput = {
    update: XOR<UserUpdateWithoutReferredStudentsInput, UserUncheckedUpdateWithoutReferredStudentsInput>
    create: XOR<UserCreateWithoutReferredStudentsInput, UserUncheckedCreateWithoutReferredStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredStudentsInput, UserUncheckedUpdateWithoutReferredStudentsInput>
  }

  export type UserUpdateWithoutReferredStudentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredStudentsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampusUpsertWithoutStudentsInput = {
    update: XOR<CampusUpdateWithoutStudentsInput, CampusUncheckedUpdateWithoutStudentsInput>
    create: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutStudentsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutStudentsInput, CampusUncheckedUpdateWithoutStudentsInput>
  }

  export type CampusUpdateWithoutStudentsInput = {
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUpdateManyWithoutCampusNestedInput
    gradeFees?: GradeFeeUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUncheckedUpdateManyWithoutCampusNestedInput
    gradeFees?: GradeFeeUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type UserUpsertWithoutStudentsInput = {
    update: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
    create: XOR<UserCreateWithoutStudentsInput, UserUncheckedCreateWithoutStudentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentsInput, UserUncheckedUpdateWithoutStudentsInput>
  }

  export type UserUpdateWithoutStudentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReferralLeadUpsertWithoutStudentInput = {
    update: XOR<ReferralLeadUpdateWithoutStudentInput, ReferralLeadUncheckedUpdateWithoutStudentInput>
    create: XOR<ReferralLeadCreateWithoutStudentInput, ReferralLeadUncheckedCreateWithoutStudentInput>
    where?: ReferralLeadWhereInput
  }

  export type ReferralLeadUpdateToOneWithWhereWithoutStudentInput = {
    where?: ReferralLeadWhereInput
    data: XOR<ReferralLeadUpdateWithoutStudentInput, ReferralLeadUncheckedUpdateWithoutStudentInput>
  }

  export type ReferralLeadUpdateWithoutStudentInput = {
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralLeadUncheckedUpdateWithoutStudentInput = {
    leadId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutReferralsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    students?: StudentCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type StudentCreateWithoutReferralLeadInput = {
    fullName: string
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    ambassador?: UserCreateNestedOneWithoutReferredStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    parent: UserCreateNestedOneWithoutStudentsInput
  }

  export type StudentUncheckedCreateWithoutReferralLeadInput = {
    studentId?: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentCreateOrConnectWithoutReferralLeadInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentUpsertWithoutReferralLeadInput = {
    update: XOR<StudentUpdateWithoutReferralLeadInput, StudentUncheckedUpdateWithoutReferralLeadInput>
    create: XOR<StudentCreateWithoutReferralLeadInput, StudentUncheckedCreateWithoutReferralLeadInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReferralLeadInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReferralLeadInput, StudentUncheckedUpdateWithoutReferralLeadInput>
  }

  export type StudentUpdateWithoutReferralLeadInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    ambassador?: UserUpdateOneWithoutReferredStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parent?: UserUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentUncheckedUpdateWithoutReferralLeadInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateWithoutAdminInput = {
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutAdminInput = {
    id?: number
    userId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutAdminInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput>
  }

  export type NotificationCreateManyAdminInputEnvelope = {
    data: NotificationCreateManyAdminInput | NotificationCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type NotificationUpsertWithWhereUniqueWithoutAdminInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutAdminInput, NotificationUncheckedUpdateWithoutAdminInput>
    create: XOR<NotificationCreateWithoutAdminInput, NotificationUncheckedCreateWithoutAdminInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutAdminInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutAdminInput, NotificationUncheckedUpdateWithoutAdminInput>
  }

  export type NotificationUpdateManyWithWhereWithoutAdminInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutAdminInput>
  }

  export type UserCreateWithoutSettlementsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    students?: StudentCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSettlementsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSettlementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettlementsInput, UserUncheckedCreateWithoutSettlementsInput>
  }

  export type UserUpsertWithoutSettlementsInput = {
    update: XOR<UserUpdateWithoutSettlementsInput, UserUncheckedUpdateWithoutSettlementsInput>
    create: XOR<UserCreateWithoutSettlementsInput, UserUncheckedCreateWithoutSettlementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettlementsInput, UserUncheckedUpdateWithoutSettlementsInput>
  }

  export type UserUpdateWithoutSettlementsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSettlementsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSupportTicketsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    students?: StudentCreateNestedManyWithoutParentInput
  }

  export type UserUncheckedCreateWithoutSupportTicketsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
  }

  export type UserCreateOrConnectWithoutSupportTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
  }

  export type TicketMessageCreateWithoutTicketInput = {
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUncheckedCreateWithoutTicketInput = {
    id?: number
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageCreateOrConnectWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageCreateManyTicketInputEnvelope = {
    data: TicketMessageCreateManyTicketInput | TicketMessageCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSupportTicketsInput = {
    update: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
    create: XOR<UserCreateWithoutSupportTicketsInput, UserUncheckedCreateWithoutSupportTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupportTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupportTicketsInput, UserUncheckedUpdateWithoutSupportTicketsInput>
  }

  export type UserUpdateWithoutSupportTicketsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
  }

  export type UserUncheckedUpdateWithoutSupportTicketsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TicketMessageUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    update: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketMessageCreateWithoutTicketInput, TicketMessageUncheckedCreateWithoutTicketInput>
  }

  export type TicketMessageUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketMessageWhereUniqueInput
    data: XOR<TicketMessageUpdateWithoutTicketInput, TicketMessageUncheckedUpdateWithoutTicketInput>
  }

  export type TicketMessageUpdateManyWithWhereWithoutTicketInput = {
    where: TicketMessageScalarWhereInput
    data: XOR<TicketMessageUpdateManyMutationInput, TicketMessageUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketMessageScalarWhereInput = {
    AND?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    OR?: TicketMessageScalarWhereInput[]
    NOT?: TicketMessageScalarWhereInput | TicketMessageScalarWhereInput[]
    id?: IntFilter<"TicketMessage"> | number
    ticketId?: IntFilter<"TicketMessage"> | number
    senderId?: IntFilter<"TicketMessage"> | number
    senderType?: StringFilter<"TicketMessage"> | string
    message?: StringFilter<"TicketMessage"> | string
    isInternal?: BoolFilter<"TicketMessage"> | boolean
    createdAt?: DateTimeFilter<"TicketMessage"> | Date | string
  }

  export type SupportTicketCreateWithoutMessagesInput = {
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSupportTicketsInput
  }

  export type SupportTicketUncheckedCreateWithoutMessagesInput = {
    id?: number
    userId: number
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
  }

  export type SupportTicketCreateOrConnectWithoutMessagesInput = {
    where: SupportTicketWhereUniqueInput
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
  }

  export type SupportTicketUpsertWithoutMessagesInput = {
    update: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
    create: XOR<SupportTicketCreateWithoutMessagesInput, SupportTicketUncheckedCreateWithoutMessagesInput>
    where?: SupportTicketWhereInput
  }

  export type SupportTicketUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SupportTicketWhereInput
    data: XOR<SupportTicketUpdateWithoutMessagesInput, SupportTicketUncheckedUpdateWithoutMessagesInput>
  }

  export type SupportTicketUpdateWithoutMessagesInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSupportTicketsNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampusTargetCreateWithoutCampusInput = {
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
  }

  export type CampusTargetUncheckedCreateWithoutCampusInput = {
    id?: number
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
  }

  export type CampusTargetCreateOrConnectWithoutCampusInput = {
    where: CampusTargetWhereUniqueInput
    create: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput>
  }

  export type CampusTargetCreateManyCampusInputEnvelope = {
    data: CampusTargetCreateManyCampusInput | CampusTargetCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type GradeFeeCreateWithoutCampusInput = {
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    academicYear?: string
  }

  export type GradeFeeUncheckedCreateWithoutCampusInput = {
    id?: number
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    academicYear?: string
  }

  export type GradeFeeCreateOrConnectWithoutCampusInput = {
    where: GradeFeeWhereUniqueInput
    create: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput>
  }

  export type GradeFeeCreateManyCampusInputEnvelope = {
    data: GradeFeeCreateManyCampusInput | GradeFeeCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutCampusInput = {
    fullName: string
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
    ambassador?: UserCreateNestedOneWithoutReferredStudentsInput
    parent: UserCreateNestedOneWithoutStudentsInput
    referralLead?: ReferralLeadCreateNestedOneWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCampusInput = {
    studentId?: number
    fullName: string
    parentId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentCreateOrConnectWithoutCampusInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput>
  }

  export type StudentCreateManyCampusInputEnvelope = {
    data: StudentCreateManyCampusInput | StudentCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type CampusTargetUpsertWithWhereUniqueWithoutCampusInput = {
    where: CampusTargetWhereUniqueInput
    update: XOR<CampusTargetUpdateWithoutCampusInput, CampusTargetUncheckedUpdateWithoutCampusInput>
    create: XOR<CampusTargetCreateWithoutCampusInput, CampusTargetUncheckedCreateWithoutCampusInput>
  }

  export type CampusTargetUpdateWithWhereUniqueWithoutCampusInput = {
    where: CampusTargetWhereUniqueInput
    data: XOR<CampusTargetUpdateWithoutCampusInput, CampusTargetUncheckedUpdateWithoutCampusInput>
  }

  export type CampusTargetUpdateManyWithWhereWithoutCampusInput = {
    where: CampusTargetScalarWhereInput
    data: XOR<CampusTargetUpdateManyMutationInput, CampusTargetUncheckedUpdateManyWithoutCampusInput>
  }

  export type CampusTargetScalarWhereInput = {
    AND?: CampusTargetScalarWhereInput | CampusTargetScalarWhereInput[]
    OR?: CampusTargetScalarWhereInput[]
    NOT?: CampusTargetScalarWhereInput | CampusTargetScalarWhereInput[]
    id?: IntFilter<"CampusTarget"> | number
    campusId?: IntFilter<"CampusTarget"> | number
    month?: IntFilter<"CampusTarget"> | number
    year?: IntFilter<"CampusTarget"> | number
    leadTarget?: IntFilter<"CampusTarget"> | number
    admissionTarget?: IntFilter<"CampusTarget"> | number
    updatedAt?: DateTimeFilter<"CampusTarget"> | Date | string
  }

  export type GradeFeeUpsertWithWhereUniqueWithoutCampusInput = {
    where: GradeFeeWhereUniqueInput
    update: XOR<GradeFeeUpdateWithoutCampusInput, GradeFeeUncheckedUpdateWithoutCampusInput>
    create: XOR<GradeFeeCreateWithoutCampusInput, GradeFeeUncheckedCreateWithoutCampusInput>
  }

  export type GradeFeeUpdateWithWhereUniqueWithoutCampusInput = {
    where: GradeFeeWhereUniqueInput
    data: XOR<GradeFeeUpdateWithoutCampusInput, GradeFeeUncheckedUpdateWithoutCampusInput>
  }

  export type GradeFeeUpdateManyWithWhereWithoutCampusInput = {
    where: GradeFeeScalarWhereInput
    data: XOR<GradeFeeUpdateManyMutationInput, GradeFeeUncheckedUpdateManyWithoutCampusInput>
  }

  export type GradeFeeScalarWhereInput = {
    AND?: GradeFeeScalarWhereInput | GradeFeeScalarWhereInput[]
    OR?: GradeFeeScalarWhereInput[]
    NOT?: GradeFeeScalarWhereInput | GradeFeeScalarWhereInput[]
    id?: IntFilter<"GradeFee"> | number
    grade?: StringFilter<"GradeFee"> | string
    annualFee_otp?: IntNullableFilter<"GradeFee"> | number | null
    annualFee_wotp?: IntNullableFilter<"GradeFee"> | number | null
    campusId?: IntFilter<"GradeFee"> | number
    academicYear?: StringFilter<"GradeFee"> | string
  }

  export type StudentUpsertWithWhereUniqueWithoutCampusInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCampusInput, StudentUncheckedUpdateWithoutCampusInput>
    create: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCampusInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCampusInput, StudentUncheckedUpdateWithoutCampusInput>
  }

  export type StudentUpdateManyWithWhereWithoutCampusInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCampusInput>
  }

  export type CampusCreateWithoutTargetsInput = {
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gradeFees?: GradeFeeCreateNestedManyWithoutCampusInput
    students?: StudentCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutTargetsInput = {
    id?: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gradeFees?: GradeFeeUncheckedCreateNestedManyWithoutCampusInput
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutTargetsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutTargetsInput, CampusUncheckedCreateWithoutTargetsInput>
  }

  export type CampusUpsertWithoutTargetsInput = {
    update: XOR<CampusUpdateWithoutTargetsInput, CampusUncheckedUpdateWithoutTargetsInput>
    create: XOR<CampusCreateWithoutTargetsInput, CampusUncheckedCreateWithoutTargetsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutTargetsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutTargetsInput, CampusUncheckedUpdateWithoutTargetsInput>
  }

  export type CampusUpdateWithoutTargetsInput = {
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gradeFees?: GradeFeeUpdateManyWithoutCampusNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutTargetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gradeFees?: GradeFeeUncheckedUpdateManyWithoutCampusNestedInput
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type CampusCreateWithoutGradeFeesInput = {
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetCreateNestedManyWithoutCampusInput
    students?: StudentCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutGradeFeesInput = {
    id?: number
    campusName: string
    campusCode: string
    location: string
    grades: string
    maxCapacity?: number
    currentEnrollment?: number
    isActive?: boolean
    campusHeadId?: number | null
    contactEmail?: string | null
    contactPhone?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targets?: CampusTargetUncheckedCreateNestedManyWithoutCampusInput
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutGradeFeesInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutGradeFeesInput, CampusUncheckedCreateWithoutGradeFeesInput>
  }

  export type CampusUpsertWithoutGradeFeesInput = {
    update: XOR<CampusUpdateWithoutGradeFeesInput, CampusUncheckedUpdateWithoutGradeFeesInput>
    create: XOR<CampusCreateWithoutGradeFeesInput, CampusUncheckedCreateWithoutGradeFeesInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutGradeFeesInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutGradeFeesInput, CampusUncheckedUpdateWithoutGradeFeesInput>
  }

  export type CampusUpdateWithoutGradeFeesInput = {
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUpdateManyWithoutCampusNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutGradeFeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    campusName?: StringFieldUpdateOperationsInput | string
    campusCode?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    grades?: StringFieldUpdateOperationsInput | string
    maxCapacity?: IntFieldUpdateOperationsInput | number
    currentEnrollment?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    campusHeadId?: NullableIntFieldUpdateOperationsInput | number | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targets?: CampusTargetUncheckedUpdateManyWithoutCampusNestedInput
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type AdminCreateWithoutNotificationsInput = {
    adminName: string
    adminMobile: string
    assignedCampus?: string | null
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    password?: string | null
    role?: $Enums.AdminRole
    status?: $Enums.AccountStatus
  }

  export type AdminUncheckedCreateWithoutNotificationsInput = {
    adminId?: number
    adminName: string
    adminMobile: string
    assignedCampus?: string | null
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    password?: string | null
    role?: $Enums.AdminRole
    status?: $Enums.AccountStatus
  }

  export type AdminCreateOrConnectWithoutNotificationsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    referrals?: ReferralLeadCreateNestedManyWithoutUserInput
    settlements?: SettlementCreateNestedManyWithoutUserInput
    referredStudents?: StudentCreateNestedManyWithoutAmbassadorInput
    students?: StudentCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    userId?: number
    fullName: string
    mobileNumber: string
    childInAchariya: boolean
    childName?: string | null
    grade?: string | null
    campusId?: number | null
    bankAccountDetails?: string | null
    referralCode?: string | null
    confirmedReferralCount?: number
    yearFeeBenefitPercent?: number
    longTermBenefitPercent?: number
    lastActiveYear?: number | null
    isFiveStarMember?: boolean
    assignedCampus?: string | null
    studentFee?: number
    academicYear?: string
    createdAt?: Date | string
    profileImage?: string | null
    email?: string | null
    address?: string | null
    paymentAmount?: number
    paymentStatus?: string
    transactionId?: string | null
    aadharNo?: string | null
    childEprNo?: string | null
    empId?: string | null
    password?: string | null
    deletionRequestedAt?: Date | string | null
    role?: $Enums.UserRole
    status?: $Enums.AccountStatus
    benefitStatus?: $Enums.AccountStatus
    referrals?: ReferralLeadUncheckedCreateNestedManyWithoutUserInput
    settlements?: SettlementUncheckedCreateNestedManyWithoutUserInput
    referredStudents?: StudentUncheckedCreateNestedManyWithoutAmbassadorInput
    students?: StudentUncheckedCreateNestedManyWithoutParentInput
    supportTickets?: SupportTicketUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type AdminUpsertWithoutNotificationsInput = {
    update: XOR<AdminUpdateWithoutNotificationsInput, AdminUncheckedUpdateWithoutNotificationsInput>
    create: XOR<AdminCreateWithoutNotificationsInput, AdminUncheckedCreateWithoutNotificationsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutNotificationsInput, AdminUncheckedUpdateWithoutNotificationsInput>
  }

  export type AdminUpdateWithoutNotificationsInput = {
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type AdminUncheckedUpdateWithoutNotificationsInput = {
    adminId?: IntFieldUpdateOperationsInput | number
    adminName?: StringFieldUpdateOperationsInput | string
    adminMobile?: StringFieldUpdateOperationsInput | string
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumAdminRoleFieldUpdateOperationsInput | $Enums.AdminRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    referrals?: ReferralLeadUpdateManyWithoutUserNestedInput
    settlements?: SettlementUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    userId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    childInAchariya?: BoolFieldUpdateOperationsInput | boolean
    childName?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    bankAccountDetails?: NullableStringFieldUpdateOperationsInput | string | null
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedReferralCount?: IntFieldUpdateOperationsInput | number
    yearFeeBenefitPercent?: FloatFieldUpdateOperationsInput | number
    longTermBenefitPercent?: FloatFieldUpdateOperationsInput | number
    lastActiveYear?: NullableIntFieldUpdateOperationsInput | number | null
    isFiveStarMember?: BoolFieldUpdateOperationsInput | boolean
    assignedCampus?: NullableStringFieldUpdateOperationsInput | string | null
    studentFee?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    paymentAmount?: IntFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNo?: NullableStringFieldUpdateOperationsInput | string | null
    childEprNo?: NullableStringFieldUpdateOperationsInput | string | null
    empId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    deletionRequestedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    benefitStatus?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    referrals?: ReferralLeadUncheckedUpdateManyWithoutUserNestedInput
    settlements?: SettlementUncheckedUpdateManyWithoutUserNestedInput
    referredStudents?: StudentUncheckedUpdateManyWithoutAmbassadorNestedInput
    students?: StudentUncheckedUpdateManyWithoutParentNestedInput
    supportTickets?: SupportTicketUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignLogCreateWithoutCampaignInput = {
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUncheckedCreateWithoutCampaignInput = {
    id?: number
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogCreateOrConnectWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    create: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLogCreateManyCampaignInputEnvelope = {
    data: CampaignLogCreateManyCampaignInput | CampaignLogCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignLogUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    update: XOR<CampaignLogUpdateWithoutCampaignInput, CampaignLogUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignLogCreateWithoutCampaignInput, CampaignLogUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignLogUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignLogWhereUniqueInput
    data: XOR<CampaignLogUpdateWithoutCampaignInput, CampaignLogUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignLogUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignLogScalarWhereInput
    data: XOR<CampaignLogUpdateManyMutationInput, CampaignLogUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignLogScalarWhereInput = {
    AND?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
    OR?: CampaignLogScalarWhereInput[]
    NOT?: CampaignLogScalarWhereInput | CampaignLogScalarWhereInput[]
    id?: IntFilter<"CampaignLog"> | number
    campaignId?: IntFilter<"CampaignLog"> | number
    runAt?: DateTimeFilter<"CampaignLog"> | Date | string
    status?: StringFilter<"CampaignLog"> | string
    recipientCount?: IntFilter<"CampaignLog"> | number
    sentCount?: IntFilter<"CampaignLog"> | number
    failedCount?: IntFilter<"CampaignLog"> | number
    errorLog?: JsonNullableFilter<"CampaignLog">
  }

  export type CampaignCreateWithoutLogsInput = {
    name: string
    subject: string
    templateBody: string
    type?: string
    status?: string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type CampaignUncheckedCreateWithoutLogsInput = {
    id?: number
    name: string
    subject: string
    templateBody: string
    type?: string
    status?: string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastRunAt?: Date | string | null
  }

  export type CampaignCreateOrConnectWithoutLogsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutLogsInput, CampaignUncheckedCreateWithoutLogsInput>
  }

  export type CampaignUpsertWithoutLogsInput = {
    update: XOR<CampaignUpdateWithoutLogsInput, CampaignUncheckedUpdateWithoutLogsInput>
    create: XOR<CampaignCreateWithoutLogsInput, CampaignUncheckedCreateWithoutLogsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutLogsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutLogsInput, CampaignUncheckedUpdateWithoutLogsInput>
  }

  export type CampaignUpdateWithoutLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    templateBody?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableJsonNullValueInput | InputJsonValue
    schedule?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastRunAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    adminId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ReferralLeadCreateManyUserInput = {
    leadId?: number
    parentName: string
    parentMobile: string
    campusId?: number | null
    campus?: string | null
    gradeInterested?: string | null
    admittedYear?: string | null
    confirmedDate?: Date | string | null
    createdAt?: Date | string
    studentName?: string | null
    leadStatus?: $Enums.LeadStatus
    admissionNumber?: string | null
    section?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type SettlementCreateManyUserInput = {
    id?: number
    amount: number
    status?: string
    paymentMethod?: string | null
    bankReference?: string | null
    payoutDate?: Date | string | null
    processedBy?: number | null
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyAmbassadorInput = {
    studentId?: number
    fullName: string
    parentId: number
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type StudentCreateManyParentInput = {
    studentId?: number
    fullName: string
    campusId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type SupportTicketCreateManyUserInput = {
    id?: number
    subject: string
    category: string
    priority?: string
    status?: string
    assignedAdminId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus?: string | null
    message: string
    resolvedAt?: Date | string | null
    escalationLevel?: number
    lastEscalatedAt?: Date | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralLeadUpdateWithoutUserInput = {
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUpdateOneWithoutReferralLeadNestedInput
  }

  export type ReferralLeadUncheckedUpdateWithoutUserInput = {
    leadId?: IntFieldUpdateOperationsInput | number
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    student?: StudentUncheckedUpdateOneWithoutReferralLeadNestedInput
  }

  export type ReferralLeadUncheckedUpdateManyWithoutUserInput = {
    leadId?: IntFieldUpdateOperationsInput | number
    parentName?: StringFieldUpdateOperationsInput | string
    parentMobile?: StringFieldUpdateOperationsInput | string
    campusId?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    gradeInterested?: NullableStringFieldUpdateOperationsInput | string | null
    admittedYear?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentName?: NullableStringFieldUpdateOperationsInput | string | null
    leadStatus?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettlementUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettlementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    bankReference?: NullableStringFieldUpdateOperationsInput | string | null
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableIntFieldUpdateOperationsInput | number | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutAmbassadorInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parent?: UserUpdateOneRequiredWithoutStudentsNestedInput
    referralLead?: ReferralLeadUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAmbassadorInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUncheckedUpdateManyWithoutAmbassadorInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUpdateWithoutParentInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    ambassador?: UserUpdateOneWithoutReferredStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    referralLead?: ReferralLeadUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUncheckedUpdateManyWithoutParentInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    campusId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SupportTicketUpdateWithoutUserInput = {
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: TicketMessageUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: TicketMessageUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type SupportTicketUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    assignedAdminId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    escalationLevel?: IntFieldUpdateOperationsInput | number
    lastEscalatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyAdminInput = {
    id?: number
    userId?: number | null
    title: string
    message: string
    type: string
    link?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutAdminInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageCreateManyTicketInput = {
    id?: number
    senderId: number
    senderType: string
    message: string
    isInternal?: boolean
    createdAt?: Date | string
  }

  export type TicketMessageUpdateWithoutTicketInput = {
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMessageUncheckedUpdateManyWithoutTicketInput = {
    id?: IntFieldUpdateOperationsInput | number
    senderId?: IntFieldUpdateOperationsInput | number
    senderType?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetCreateManyCampusInput = {
    id?: number
    month: number
    year: number
    leadTarget?: number
    admissionTarget?: number
    updatedAt?: Date | string
  }

  export type GradeFeeCreateManyCampusInput = {
    id?: number
    grade: string
    annualFee_otp?: number | null
    annualFee_wotp?: number | null
    academicYear?: string
  }

  export type StudentCreateManyCampusInput = {
    studentId?: number
    fullName: string
    parentId: number
    grade: string
    section?: string | null
    rollNumber?: string | null
    academicYear?: string
    status?: string
    baseFee?: number
    discountPercent?: number
    referralLeadId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ambassadorId?: number | null
    admissionNumber?: string | null
    selectedFeeType?: $Enums.FeeType | null
    annualFee?: number | null
  }

  export type CampusTargetUpdateWithoutCampusInput = {
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetUncheckedUpdateWithoutCampusInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusTargetUncheckedUpdateManyWithoutCampusInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    leadTarget?: IntFieldUpdateOperationsInput | number
    admissionTarget?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeFeeUpdateWithoutCampusInput = {
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type GradeFeeUncheckedUpdateWithoutCampusInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type GradeFeeUncheckedUpdateManyWithoutCampusInput = {
    id?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    annualFee_otp?: NullableIntFieldUpdateOperationsInput | number | null
    annualFee_wotp?: NullableIntFieldUpdateOperationsInput | number | null
    academicYear?: StringFieldUpdateOperationsInput | string
  }

  export type StudentUpdateWithoutCampusInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
    ambassador?: UserUpdateOneWithoutReferredStudentsNestedInput
    parent?: UserUpdateOneRequiredWithoutStudentsNestedInput
    referralLead?: ReferralLeadUpdateOneWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCampusInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudentUncheckedUpdateManyWithoutCampusInput = {
    studentId?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    parentId?: IntFieldUpdateOperationsInput | number
    grade?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    academicYear?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    baseFee?: IntFieldUpdateOperationsInput | number
    discountPercent?: FloatFieldUpdateOperationsInput | number
    referralLeadId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ambassadorId?: NullableIntFieldUpdateOperationsInput | number | null
    admissionNumber?: NullableStringFieldUpdateOperationsInput | string | null
    selectedFeeType?: NullableEnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType | null
    annualFee?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CampaignLogCreateManyCampaignInput = {
    id?: number
    runAt?: Date | string
    status: string
    recipientCount?: number
    sentCount?: number
    failedCount?: number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUpdateWithoutCampaignInput = {
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUncheckedUpdateWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CampaignLogUncheckedUpdateManyWithoutCampaignInput = {
    id?: IntFieldUpdateOperationsInput | number
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentCount?: IntFieldUpdateOperationsInput | number
    failedCount?: IntFieldUpdateOperationsInput | number
    errorLog?: NullableJsonNullValueInput | InputJsonValue
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketCountOutputTypeDefaultArgs instead
     */
    export type SupportTicketCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampusCountOutputTypeDefaultArgs instead
     */
    export type CampusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReferralLeadDefaultArgs instead
     */
    export type ReferralLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReferralLeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BenefitSlabDefaultArgs instead
     */
    export type BenefitSlabArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BenefitSlabDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemSettingsDefaultArgs instead
     */
    export type SystemSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicYearDefaultArgs instead
     */
    export type AcademicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicYearDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadManagementSettingsDefaultArgs instead
     */
    export type LeadManagementSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadManagementSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SecuritySettingsDefaultArgs instead
     */
    export type SecuritySettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SecuritySettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataRetentionSettingsDefaultArgs instead
     */
    export type DataRetentionSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataRetentionSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolePermissionsDefaultArgs instead
     */
    export type RolePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolePermissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettlementDefaultArgs instead
     */
    export type SettlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettlementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupportTicketDefaultArgs instead
     */
    export type SupportTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupportTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TicketMessageDefaultArgs instead
     */
    export type TicketMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TicketMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampusDefaultArgs instead
     */
    export type CampusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampusTargetDefaultArgs instead
     */
    export type CampusTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampusTargetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradeFeeDefaultArgs instead
     */
    export type GradeFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradeFeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationSettingsDefaultArgs instead
     */
    export type NotificationSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationSettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketingAssetDefaultArgs instead
     */
    export type MarketingAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketingAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtpVerificationDefaultArgs instead
     */
    export type OtpVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtpVerificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignLogDefaultArgs instead
     */
    export type CampaignLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RateLimitDefaultArgs instead
     */
    export type RateLimitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RateLimitDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}